<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Clang.jl</title><link rel="canonical" href="https://JuliaInterop.github.io/Clang.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Clang.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaInterop/Clang.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Clang.annotateTokens-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Any, Any, Any}" href="#Clang.annotateTokens-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Any, Any, Any}"><code>Clang.annotateTokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">annotateTokens(tu::TranslationUnit, tokens, token_num, cursors)</code></pre><p>Annotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.children-Tuple{Clang.LibClang.CXCursor}" href="#Clang.children-Tuple{Clang.LibClang.CXCursor}"><code>Clang.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">children(cursor::CXCursor) -&gt; Vector{CXCursor}
children(cursor::CLCursor) -&gt; Vector{CLCursor}</code></pre><p>Return immediate cursors of the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL480-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.fields-Tuple{Clang.LibClang.CXType}" href="#Clang.fields-Tuple{Clang.LibClang.CXType}"><code>Clang.fields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fields(ty::CXType) -&gt; Vector{CXCursor}
fields(ty::CLType) -&gt; Vector{CLCursor}</code></pre><p>Return a child cursor vector of the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getAddressSpace-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.getAddressSpace-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.getAddressSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getAddressSpace(t::Union{CXType,CLType})</code></pre><p>Returns the address space of the given type. Wrapper for libclang&#39;s <code>clang_getAddressSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getAlignOf-Tuple{Clang.LibClang.CXType}" href="#Clang.getAlignOf-Tuple{Clang.LibClang.CXType}"><code>Clang.getAlignOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getAlignOf(t::CXType) -&gt; Int
getAlignOf(t::CLType) -&gt; Int</code></pre><p>Return the alignment of a type in bytes as per C++[expr.alignof] standard.</p><p>It returns a minus number for layout errors, please convert the result to a <a href="@ref"><code>CXTypeLayoutError</code></a> to see what the error is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL165-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getArgType-Tuple{Clang.LibClang.CXType, Unsigned}" href="#Clang.getArgType-Tuple{Clang.LibClang.CXType, Unsigned}"><code>Clang.getArgType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getArgType(t::CXType, i::Unsigned) -&gt; CXType
getArgType(t::Union{CLFunctionNoProto,CLFunctionProto}, i::Integer) -&gt; CLType</code></pre><p>Return the type of a parameter of a function type. Wrapper for libclang&#39;s <code>clang_getArgType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getArgument-Tuple{Clang.LibClang.CXCursor, Integer}" href="#Clang.getArgument-Tuple{Clang.LibClang.CXCursor, Integer}"><code>Clang.getArgument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getArgument(c::CXCursor, i::Integer) -&gt; CXCursor
getArgument(c::Union{CLFunctionDecl,CLCXXMethod}, i::Integer) -&gt; CLCursor</code></pre><p>Return the argument cursor of a function or method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCanonicalType-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCanonicalType-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCanonicalType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCanonicalType(c::CXCursor) -&gt; CXCursor
getCanonicalType(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the getCanonicalType cursor corresponding to the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCanonicalType-Tuple{Clang.LibClang.CXType}" href="#Clang.getCanonicalType-Tuple{Clang.LibClang.CXType}"><code>Clang.getCanonicalType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCanonicalType(t::CXType) -&gt; CXType
getCanonicalType(t::CLType) -&gt; CLType</code></pre><p>Return the canonical type for a CXType.</p><p>Clang&#39;s type system explicitly models typedefs and all the ways a specific type can be represented. The canonical type is the underlying type with all the &quot;sugar&quot; removed. For example, if &#39;T&#39; is a typedef for &#39;int&#39;, the canonical type for &#39;T&#39; would be &#39;int&#39;. Wrapper for libclang&#39;s <code>clang_getCanonicalType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorDefinition-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorDefinition-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorDefinition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorDefinition(c::CXCursor) -&gt; CXCursor
getCursorDefinition(c::CLCursor) -&gt; CLCursor</code></pre><p>For a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorExtent-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getCursorExtent-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getCursorExtent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorExtent(c::Union{CXCursor,CLCursor}) -&gt; CXSourceRange</code></pre><p>Return the physical extent of the source construct referenced by the given cursor.</p><p>The extent of a cursor starts with the file/line/column pointing at the first character within the source construct that the cursor refers to and ends with the last character within that source construct. For a declaration, the extent covers the declaration itself. For a reference, the extent covers the location of the reference (e.g., where the referenced entity was actually used).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL190-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorLanguage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getCursorLanguage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getCursorLanguage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorLanguage(c::Union{CXCursor,CLCursor}) -&gt; CXLanguageKind</code></pre><p>Return the language of the entity referred to by a given cursor. Return <code>CXLanguage_Invalid</code> if the input cursor is not a decl. Note that, this function has limitations, for example, it cannot distinguish C++ structs from C structs, in both cases, it returns <code>CXLanguage_C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorLexicalParent-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorLexicalParent-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorLexicalParent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorLexicalParent(c::CXCursor) -&gt; CXCursor
getCursorLexicalParent(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the lexical parent of the given cursor. Please checkout libclang&#39;s doc to know more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorLinkage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getCursorLinkage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getCursorLinkage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorLinkage(c::Union{CXCursor,CLCursor}) -&gt; CXLinkageKind</code></pre><p>Return the linkage of the entity referred to by a given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL123-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorLocation-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getCursorLocation-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getCursorLocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorLocation(c::Union{CXCursor,CLCursor}) -&gt; CXSourceLocation</code></pre><p>Return the physical location of the source constructor referenced by the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL184-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorReferenced-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorReferenced-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorReferenced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorReferenced(c::CXCursor) -&gt; CXCursor
getCursorReferenced(c::CLCursor) -&gt; CLCursor</code></pre><p>For a cursor that is a reference, retrieve a cursor representing the entity that it references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorResultType-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorResultType-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorResultType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorResultType(c::CXCursor) -&gt; CXType
getCursorResultType(c::Union{CLFunctionDecl,CLCXXMethod}) -&gt; CLType</code></pre><p>Return the return type associated with a given cursor. This only returns a valid type if the cursor refers to a function or method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorResultType-Tuple{Clang.LibClang.CXType}" href="#Clang.getCursorResultType-Tuple{Clang.LibClang.CXType}"><code>Clang.getCursorResultType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorResultType(t::CXType) -&gt; CXType
getCursorResultType(t::Union{CLFunctionNoProto,CLFunctionProto}) -&gt; CLType</code></pre><p>Return the return type associated with a function type. Wrapper for libclang&#39;s <code>clang_getResultType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorSemanticParent-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorSemanticParent-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorSemanticParent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorSemanticParent(c::CXCursor) -&gt; CXCursor
getCursorSemanticParent(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the semantic parent of the given cursor. Please checkout libclang&#39;s doc to know more.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getCursorType-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getCursorType-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getCursorType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getCursorType(c::CXCursor) -&gt; CXType
getCursorType(c::CLCursor) -&gt; CLType</code></pre><p>Return the type of a CXCursor (if any). To get the cursor from a type, see <a href="#Clang.getTypeDeclaration-Tuple{Clang.LibClang.CXType}"><code>getTypeDeclaration</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getElementType-Tuple{Clang.LibClang.CXType}" href="#Clang.getElementType-Tuple{Clang.LibClang.CXType}"><code>Clang.getElementType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getElementType(t::CXType) -&gt; CXType
getElementType(t::Union{CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray,CLComplex}) -&gt; CLType</code></pre><p>Return the element type of an array, complex, or vector type. Wrapper for libclang&#39;s <code>clang_getElementType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getEnumDeclIntegerType-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getEnumDeclIntegerType-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getEnumDeclIntegerType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getEnumDeclIntegerType(c::CLEnumDecl) -&gt; CLType</code></pre><p>Retrieve the integer type of an enum declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL217-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getFieldDeclBitWidth-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getFieldDeclBitWidth-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getFieldDeclBitWidth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getFieldDeclBitWidth(c::CLFieldDecl) -&gt; Int</code></pre><p>Return the bit width of a bit field declaration as an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL240-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getFunctionTypeCallingConv-Tuple{Union{CLFunctionNoProto, CLFunctionProto, Clang.LibClang.CXType}}" href="#Clang.getFunctionTypeCallingConv-Tuple{Union{CLFunctionNoProto, CLFunctionProto, Clang.LibClang.CXType}}"><code>Clang.getFunctionTypeCallingConv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getFunctionTypeCallingConv(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -&gt; CXCallingConv</code></pre><p>Return the calling convention associated with a function type. Wrapper for libclang&#39;s <code>clang_getFunctionTypeCallingConv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getIncludedFile-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getIncludedFile-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getIncludedFile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getIncludedFile(c::Union{CXCursor,CLCursor}) -&gt; CXFile</code></pre><p>Return the file that is included by the given inclusion directive cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL178-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getNamedType-Tuple{Clang.LibClang.CXType}" href="#Clang.getNamedType-Tuple{Clang.LibClang.CXType}"><code>Clang.getNamedType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getNamedType(t::CXType) -&gt; CXType
getNamedType(t::CLElaborated) -&gt; CLType</code></pre><p>Return the type named by the qualified-id. Wrapper for libclang&#39;s <code>clang_Type_getNamedType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getNullCursor-Tuple{}" href="#Clang.getNullCursor-Tuple{}"><code>Clang.getNullCursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getNullCursor() -&gt; CXCursor</code></pre><p>Return the &quot;NULL&quot; CXCursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getNumArguments-Tuple{Union{CLCXXMethod, CLFunctionDecl, Clang.LibClang.CXCursor}}" href="#Clang.getNumArguments-Tuple{Union{CLCXXMethod, CLFunctionDecl, Clang.LibClang.CXCursor}}"><code>Clang.getNumArguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getNumArguments(c::Union{CXCursor,CLFunctionDecl,CLCXXMethod}) -&gt; Int</code></pre><p>Return the number of non-variadic arguments associated with a given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL247-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getNumArguments-Tuple{Union{CLFunctionNoProto, CLFunctionProto, CLUnexposed, Clang.LibClang.CXType}}" href="#Clang.getNumArguments-Tuple{Union{CLFunctionNoProto, CLFunctionProto, CLUnexposed, Clang.LibClang.CXType}}"><code>Clang.getNumArguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getNumArguments(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -&gt; Int</code></pre><p>Return the number of non-variadic parameters associated with a function type. Wrapper for libclang&#39;s <code>clang_getNumArgTypes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getNumElements-Tuple{Union{CLConstantArray, CLDependentSizedArray, CLIncompleteArray, CLVariableArray, CLVector, Clang.LibClang.CXType}}" href="#Clang.getNumElements-Tuple{Union{CLConstantArray, CLDependentSizedArray, CLIncompleteArray, CLVariableArray, CLVector, Clang.LibClang.CXType}}"><code>Clang.getNumElements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getNumElements(t::Union{CXType,CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray}) -&gt; Int</code></pre><p>Return the number of elements of an array or vector type. Wrapper for libclang&#39;s <code>clang_getNumElements</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getOffsetOf-Tuple{Clang.LibClang.CXType, Any}" href="#Clang.getOffsetOf-Tuple{Clang.LibClang.CXType, Any}"><code>Clang.getOffsetOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getOffsetOf(t::CXType, s) -&gt; Int
getOffsetOf(t::CLType, s::AbstractString) -&gt; Int</code></pre><p>Return the offset of a field named S in a record of type T in bits as it would be returned by <strong>offsetof</strong> as per C++11[18.2p4].</p><p>It returns a minus number for layout errors, please convert the result to a <a href="@ref"><code>CXTypeLayoutError</code></a> to see what the error is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getPointeeType-Tuple{Clang.LibClang.CXType}" href="#Clang.getPointeeType-Tuple{Clang.LibClang.CXType}"><code>Clang.getPointeeType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getPointeeType(t::CXType) -&gt; CXType
getPointeeType(t::CLType) -&gt; CLType</code></pre><p>Return the type of the pointee for pointer types. Wrapper for libclang&#39;s <code>clang_getPointeeType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getSizeOf-Tuple{Clang.LibClang.CXType}" href="#Clang.getSizeOf-Tuple{Clang.LibClang.CXType}"><code>Clang.getSizeOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getSizeOf(t::CXType) -&gt; Int
getSizeOf(t::CLType) -&gt; Int</code></pre><p>Return the size of a type in bytes as per C++[expr.sizeof] standard,</p><p>It returns a minus number for layout errors, please convert the result to a <a href="@ref"><code>CXTypeLayoutError</code></a> to see what the error is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTokenExtent-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}" href="#Clang.getTokenExtent-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}"><code>Clang.getTokenExtent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTokenExtent(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -&gt; CXSourceRange</code></pre><p>Return a source range that covers the given token.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTokenLocation-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}" href="#Clang.getTokenLocation-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}"><code>Clang.getTokenLocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTokenLocation(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -&gt; CXSourceLocation</code></pre><p>Return the source location of the given token.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL66-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTranslationUnit-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.getTranslationUnit-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.getTranslationUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTranslationUnit(c::Union{CXCursor,CLCursor}) -&gt; CXTranslationUnit</code></pre><p>Returns the translation unit that a cursor originated from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTranslationUnitCursor-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}}" href="#Clang.getTranslationUnitCursor-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}}"><code>Clang.getTranslationUnitCursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTranslationUnitCursor(tu::TranslationUnit) -&gt; CLCursor
getTranslationUnitCursor(tu::CXTranslationUnit) -&gt; CXCursor</code></pre><p>Return the cursor that represents the given translation unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/trans_unit.jl#LL66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTypeDeclaration-Tuple{Clang.LibClang.CXType}" href="#Clang.getTypeDeclaration-Tuple{Clang.LibClang.CXType}"><code>Clang.getTypeDeclaration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTypeDeclaration(t::CXType) -&gt; CXCursor
getTypeDeclaration(t::CLType) -&gt; CLCursor</code></pre><p>Return the cursor for the declaration of the given type. To get the type of the cursor, see <a href="@ref"><code>type</code></a>. Wrapper for libclang&#39;s <code>clang_getTypeDeclaration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTypedefDeclUnderlyingType-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getTypedefDeclUnderlyingType-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getTypedefDeclUnderlyingType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTypedefDeclUnderlyingType(c::CLTypedefDecl) -&gt; CLType</code></pre><p>Return the underlying type of a typedef declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL210-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.getTypedefName-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.getTypedefName-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.getTypedefName</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getTypedefName(t::Union{CXType,CLType}) -&gt; String</code></pre><p>Return the typedef name of the given type. Wrapper for libclang&#39;s <code>clang_getTypedefName</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.get_elaborated_cursor-Tuple{Clang.LibClang.CXType}" href="#Clang.get_elaborated_cursor-Tuple{Clang.LibClang.CXType}"><code>Clang.get_elaborated_cursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_elaborated_cursor(ty::CLType) -&gt; CLCursor
get_elaborated_cursor(ty::CXType) -&gt; CXCursor</code></pre><p>Return the cursor of the elaborated type that is referenced by the input type. The input type can be a pointer/array. This function returns <a href="@ref"><code>clang_getNullCursor</code></a> if the input type is not refer to an elaborated type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL289-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.get_file_line_column-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.get_file_line_column-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.get_file_line_column</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_file_line_column(c::Union{CXCursor,CLCursor}) -&gt; (String, Int, Int)</code></pre><p>Return file name, line and column number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL437-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.get_filename-Tuple{Ptr{Nothing}}" href="#Clang.get_filename-Tuple{Ptr{Nothing}}"><code>Clang.get_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_filename(x::CXFile) -&gt; String</code></pre><p>Return the complete file and path name of the given file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL408-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.get_filename-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.get_filename-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.get_filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_filename(c::Union{CXCursor,CLCursor}) -&gt; String</code></pre><p>Return the complete file and path name of the given file referenced by the input cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL421-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.get_function_args-Tuple{CLCursor}" href="#Clang.get_function_args-Tuple{CLCursor}"><code>Clang.get_function_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_function_args(cursor::CLCursor) -&gt; Vector{CLCursor}</code></pre><p>Return function arguments for a given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL502-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.hasAttrs-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.hasAttrs-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.hasAttrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hasAttrs(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Determine whether the given cursor has any attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.has_elaborated_reference-Tuple{Clang.LibClang.CXType}" href="#Clang.has_elaborated_reference-Tuple{Clang.LibClang.CXType}"><code>Clang.has_elaborated_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_elaborated_reference(ty::CLType) -&gt; Bool
has_elaborated_reference(ty::CXType) -&gt; Bool</code></pre><p>Return true if the type is an elaborated type or the type indirectly refers to an elaborated type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL270-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.has_function_reference-Tuple{Clang.LibClang.CXType}" href="#Clang.has_function_reference-Tuple{Clang.LibClang.CXType}"><code>Clang.has_function_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_function_reference(ty::CLType) -&gt; Bool
has_function_reference(ty::CXType) -&gt; Bool</code></pre><p>Return true if the type is a function or the type indirectly refers to a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isAnonymous-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isAnonymous-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isAnonymous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isAnonymous(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if the given cursor represents an anonymous record declaration(C++).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL301-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isAttribute-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isAttribute-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isAttribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isAttribute(k::CXcursorKind) -&gt; Bool
isAttribute(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isBitField-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isBitField-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isBitField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isBitField(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if the cursor specifies a Record member that is a bitfield.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL307-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isConstQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.isConstQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.isConstQualifiedType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isConstQualifiedType(t::Union{CXType,CLType}) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;const&quot; qualifier set, without looking through typedefs that may have added &quot;const&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isConstQualifiedType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isCursorDefinition-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isCursorDefinition-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isCursorDefinition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isCursorDefinition(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if the declaration pointed to by this cursor is also a definition of that entity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL370-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isDeclaration-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isDeclaration-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isDeclaration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isDeclaration(k::CXcursorKind) -&gt; Bool
isDeclaration(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isExpression-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isExpression-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isExpression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isExpression(k::CXcursorKind) -&gt; Bool
isExpression(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isFunctionInlined-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isFunctionInlined-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isFunctionInlined</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isFunctionInlined(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Determine whether a CXCursor that is a function declaration, is an inline declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL281-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isInvalid-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isInvalid-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isInvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isInvalid(k::CXcursorKind) -&gt; Bool
isInvalid(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an valid cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isInvalid-Tuple{Clang.LibClang.CXType}" href="#Clang.isInvalid-Tuple{Clang.LibClang.CXType}"><code>Clang.isInvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isInvalid(t::CXType) -&gt; Bool
isInvalid(t::CLType) -&gt; Bool</code></pre><p>Return true if the type is a valid type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isInvalidDeclaration-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isInvalidDeclaration-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isInvalidDeclaration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isInvalidDeclaration(x::CXcursorKind) -&gt; Bool</code></pre><p>Return true if the given declaration is invalid. A declaration is invalid if it could not be parsed successfully.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isMacroBuiltin-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isMacroBuiltin-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isMacroBuiltin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isMacroBuiltin(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Determine whether a  CXCursor that is a macro, is a builtin one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL275-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isMacroFunctionLike-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isMacroFunctionLike-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isMacroFunctionLike</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isMacroFunctionLike(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Determine whether a CXCursor that is a macro, is function like.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL269-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isNull-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isNull-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isNull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isNull(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if cursor is null.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isPODType-Tuple{Clang.LibClang.CXType}" href="#Clang.isPODType-Tuple{Clang.LibClang.CXType}"><code>Clang.isPODType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isPODType(t::Union{CXType,CLType}) -&gt; Bool</code></pre><p>Return true if the CXType is a plain old data type. Wrapper for libclang&#39;s <code>clang_isPODType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isPreprocessing-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isPreprocessing-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isPreprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isPreprocessing(k::CXcursorKind) -&gt; Bool
isPreprocessing(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a preprocessing element, such as a preprocessor directive or macro instantiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isReference-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isReference-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isReference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isReference(k::CXcursorKind) -&gt; Bool
isReference(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a simple reference. Note that other kinds of cursors (such as expressions) can also refer to other cursors. Use <a href="#Clang.getCursorReferenced-Tuple{Clang.LibClang.CXCursor}"><code>getCursorReferenced</code></a> to determine whether a particular cursor refers to another entity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isRestrictQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.isRestrictQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.isRestrictQualifiedType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isRestrictQualifiedType(t::Union{CXType,CLType}) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;restrict&quot; qualifier set, without looking through typedefs that may have added &quot;restrict&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isRestrictQualifiedType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isStatement-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isStatement-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isStatement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isStatement(k::CXcursorKind) -&gt; Bool
isStatement(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isTranslationUnit-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isTranslationUnit-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isTranslationUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isTranslationUnit(k::CXcursorKind) -&gt; Bool
isTranslationUnit(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a translation unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isUnexposed-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isUnexposed-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isUnexposed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isUnexposed(k::CXcursorKind) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isVariadic-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isVariadic-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isVariadic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isVariadic(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if the given cursor is a variadic function or method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL389-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isVariadic-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.isVariadic-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.isVariadic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isVariadic(t::Union{CXType,CLType}) -&gt; Bool</code></pre><p>Return true if the CXType is a variadic function type. Wrapper for libclang&#39;s <code>clang_isFunctionTypeVariadic</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isVirtualBase-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.isVirtualBase-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.isVirtualBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isVirtualBase(c::Union{CXCursor,CLCursor}) -&gt; Bool</code></pre><p>Return true if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL313-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.isVolatileQualifiedType-Tuple{Clang.LibClang.CXType}" href="#Clang.isVolatileQualifiedType-Tuple{Clang.LibClang.CXType}"><code>Clang.isVolatileQualifiedType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isVolatileQualifiedType(t::Union{CXType,CLType}) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;volatile&quot; qualifier set, without looking through typedefs that may have added &quot;volatile&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isVolatileQualifiedType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.is_forward_declaration-Tuple{CLCursor}" href="#Clang.is_forward_declaration-Tuple{CLCursor}"><code>Clang.is_forward_declaration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_forward_declaration(x::CLCursor) -&gt; Bool</code></pre><p>Return true if the cursor is a forward declaration. Reference: https://joshpeterson.github.io/identifying-a-forward-declaration-with-libclang</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL522-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.is_inclusion_directive-Tuple{CLCursor}" href="#Clang.is_inclusion_directive-Tuple{CLCursor}"><code>Clang.is_inclusion_directive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_inclusion_directive(x::CLCursor) -&gt; Bool</code></pre><p>Return true if the cursor is an inclusion directive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL533-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.is_typedef_anon-Tuple{CLCursor, CLCursor}" href="#Clang.is_typedef_anon-Tuple{CLCursor, CLCursor}"><code>Clang.is_typedef_anon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_typedef_anon(current::CLCursor, next::CLCursor) -&gt; Bool</code></pre><p>Return true if the current cursor is a typedef anonymous struct/enum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL508-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.kind-Tuple{CLCursor}" href="#Clang.kind-Tuple{CLCursor}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kind(c::CLCursor) -&gt; CXCursorKind</code></pre><p>Return the kind of the given cursor. Note this method directly reads CXCursor&#39;s <code>kind</code> field, which won&#39;t invoke additional <code>clang_getCursorKind</code> function calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXCursor}" href="#Clang.kind-Tuple{Clang.LibClang.CXCursor}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kind(c::CXCursor) -&gt; CXCursorKind</code></pre><p>Return the kind of the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXToken}" href="#Clang.kind-Tuple{Clang.LibClang.CXToken}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kind(t::CXToken) -&gt; CXTokenKind
kind(t::CLToken) -&gt; CXTokenKind</code></pre><p>Return the kind of the given token.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXType}" href="#Clang.kind-Tuple{Clang.LibClang.CXType}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kind(t::CXType) -&gt; CXTypeKind
kind(t::CLType) -&gt; CXTypeKind</code></pre><p>Return the kind of the given type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.name-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.name-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">name(c::Union{CXCursor,CLCursor}) -&gt; String</code></pre><p>Return the display name for the entity referenced by this cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL341-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.parse_header" href="#Clang.parse_header"><code>Clang.parse_header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parse_header(
    index::Index,
    header::AbstractString,
    args::Vector{String}=[],
    flags=CXTranslationUnit_None,
) -&gt; TranslationUnit</code></pre><p>Return the TranslationUnit for a given header. This is the main entry point for parsing.</p><p><strong>Arguments</strong></p><ul><li><code>header::AbstractString</code>: the header file to parse.</li><li><code>index::Index</code>: CXIndex pointer (pass to avoid re-allocation).</li><li><code>args::Vector{String}</code>: compiler switches as string array, eg: [&quot;-x&quot;, &quot;c++&quot;, &quot;-fno-elide-type&quot;].</li><li><code>flags</code>: bitwise OR of CXTranslationUnit_Flags.</li></ul><p>See also <a href="#Clang.parse_headers"><code>parse_headers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/trans_unit.jl#LL94-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.parse_headers" href="#Clang.parse_headers"><code>Clang.parse_headers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parse_headers(
    index::Index,
    headers::Vector{String},
    args::Vector{String}=[],
    flags=CXTranslationUnit_None,
) -&gt; Vector{TranslationUnit}</code></pre><p>Return a <a href="#Clang.TranslationUnit"><code>TranslationUnit</code></a> vector for the given headers.</p><p>See also <a href="#Clang.parse_header"><code>parse_header</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/trans_unit.jl#LL125-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.search-Union{Tuple{T}, Tuple{Vector{T}, Function}} where T&lt;:CLCursor" href="#Clang.search-Union{Tuple{T}, Tuple{Vector{T}, Function}} where T&lt;:CLCursor"><code>Clang.search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">search(cursors::Vector{CLCursor}, ismatch::Function) -&gt; Vector{CLCursor}</code></pre><p>Return vector of CLCursors that match predicate. <code>ismatch</code> is a function that accepts a CLCursor argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL459-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.spelling-Tuple{Clang.LibClang.CXTypeKind}" href="#Clang.spelling-Tuple{Clang.LibClang.CXTypeKind}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spelling(kind::CXTypeKind) -&gt; String</code></pre><p>Return the spelling of a given CXTypeKind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.spelling-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}, Clang.LibClang.CXToken}" href="#Clang.spelling-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}, Clang.LibClang.CXToken}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spelling(tu::TranslationUnit, t::CLToken) -&gt; String
spelling(tu::TranslationUnit, t::CXToken) -&gt; String
spelling(tu::CXTranslationUnit, t::CXToken) -&gt; String</code></pre><p>Return the spelling of the given token. The spelling of a token is the textual representation of that token, e.g., the text of an identifier or keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.spelling-Tuple{TranslationUnit}" href="#Clang.spelling-Tuple{TranslationUnit}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spelling(tu::TranslationUnit) -&gt; String</code></pre><p>Return the original translation unit source file name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/trans_unit.jl#LL54-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.spelling-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.spelling-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spelling(c::Union{CXCursor,CLCursor}) -&gt; String</code></pre><p>Return a name for the entity referenced by this cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL327-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.spelling-Tuple{Union{CLType, Clang.LibClang.CXType}}" href="#Clang.spelling-Tuple{Union{CLType, Clang.LibClang.CXType}}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spelling(t::Union{CXType,CLType}) -&gt; String</code></pre><p>Pretty-print the underlying type using the rules of the language of the translation unit from which it came. If the type is invalid, an empty string is returned. Wrapper for libclang&#39;s <code>clang_getTypeSpelling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/type.jl#LL213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.tokenize-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}" href="#Clang.tokenize-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}"><code>Clang.tokenize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tokenize(c::Union{CXCursor,CLCursor}) -&gt; TokenList</code></pre><p>Return a TokenList from the given cursor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.value-Tuple{CLEnumConstantDecl}" href="#Clang.value-Tuple{CLEnumConstantDecl}"><code>Clang.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(c::CLCursor) -&gt; Integer</code></pre><p>Return the integer value of an enum constant declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/cursor.jl#LL224-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.Index" href="#Clang.Index"><code>Clang.Index</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Index(exclude_decls_from_PCH, display_diagnostics)</code></pre><p>Provide a shared context for creating translation units.</p><p><strong>Arguments</strong></p><ul><li><code>exclude_decls_from_PCH</code>: whether we only want to see &quot;local&quot; declarations (that did not come from a previous precompiled header). If false, we want to see all declarations.</li><li><code>display_diagnostics</code>: whether to display diagnostics.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/index.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.TokenList" href="#Clang.TokenList"><code>Clang.TokenList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TokenList</code></pre><p>Tokenizer accessor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/token.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Clang.TranslationUnit" href="#Clang.TranslationUnit"><code>Clang.TranslationUnit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TranslationUnit(idx, source, args)
TranslationUnit(idx, source, args, unsavedFiles, options)</code></pre><p>Parse the given source file and the translation unit corresponding to that file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaInterop/Clang.jl/blob/ef7e6dc73266d99277ec82a75ce123ffdcc71968/src/trans_unit.jl#LL1-L5">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 May 2021 02:53">Sunday 2 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
