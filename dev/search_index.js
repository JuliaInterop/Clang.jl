var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Clang]\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"api/#Clang._cxstring_to_string-Tuple{Clang.LibClang.CXString}","page":"API Reference","title":"Clang._cxstring_to_string","text":"Free and convert a CXString to String. Note this function will free the given CXString so ensure it is not called twice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.annotateTokens-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Any, Any, Any}","page":"API Reference","title":"Clang.annotateTokens","text":"annotateTokens(tu::TranslationUnit, tokens, token_num, cursors)\n\nAnnotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.children-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.children","text":"children(cursor::CXCursor) -> Vector{CXCursor}\nchildren(cursor::CLCursor) -> Vector{CLCursor}\n\nReturn immediate cursors of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.fields-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.fields","text":"fields(ty::CXType) -> Vector{CXCursor}\nfields(ty::CLType) -> Vector{CLCursor}\n\nReturn a child cursor vector of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAddressSpace-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.getAddressSpace","text":"getAddressSpace(t::Union{CXType,CLType})\n\nReturns the address space of the given type. Wrapper for libclang's clang_getAddressSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAlignOf-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getAlignOf","text":"getAlignOf(t::CXType) -> Int\ngetAlignOf(t::CLType) -> Int\n\nReturn the alignment of a type in bytes as per C++[expr.alignof] standard.\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArgType-Tuple{Clang.LibClang.CXType, Unsigned}","page":"API Reference","title":"Clang.getArgType","text":"getArgType(t::CXType, i::Unsigned) -> CXType\ngetArgType(t::Union{CLFunctionNoProto,CLFunctionProto}, i::Integer) -> CLType\n\nReturn the type of a parameter of a function type. Wrapper for libclang's clang_getArgType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArgument-Tuple{Clang.LibClang.CXCursor, Integer}","page":"API Reference","title":"Clang.getArgument","text":"getArgument(c::CXCursor, i::Integer) -> CXCursor\ngetArgument(c::Union{CLFunctionDecl,CLCXXMethod}, i::Integer) -> CLCursor\n\nReturn the argument cursor of a function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArguments-Tuple{Union{Clang.BlockCommand, Clang.InlineCommand}}","page":"API Reference","title":"Clang.getArguments","text":"getArguments(c::Union{BlockCommand, InlineCommand}) -> Vector{String}\n\nReturn the arguments of a command.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsHTML-Tuple{Union{Clang.FullComment, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getAsHTML","text":"getAsHTML(c::Union{CXComment, FullComment})\n\nConvert a comment into an HTML fragment. Check libclang's documentation for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsString-Tuple{Union{Clang.HTMLEndTag, Clang.HTMLStartTag, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getAsString","text":"getAsString(c::Union{CXComment, HTMLStartTag, HTMLEndTag})\n\nConvert an HTML tag to its string representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsXML-Tuple{Union{Clang.FullComment, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getAsXML","text":"getAsXML(c::Union{CXComment, FullComment})\n\nConvert a comment into an XML document.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAttributes-Tuple{Union{Clang.HTMLStartTag, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getAttributes","text":"getAttributes(c::Union{CXComment, HTMLStartTag}) -> Vector{Pair{String, String}}\n\nReturn the attributes of an HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCanonicalType-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCanonicalType","text":"getCanonicalType(c::CXCursor) -> CXCursor\ngetCanonicalType(c::CLCursor) -> CLCursor\n\nReturn the getCanonicalType cursor corresponding to the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCanonicalType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getCanonicalType","text":"getCanonicalType(t::CXType) -> CXType\ngetCanonicalType(t::CLType) -> CLType\n\nReturn the canonical type for a CXType.\n\nClang's type system explicitly models typedefs and all the ways a specific type can be represented. The canonical type is the underlying type with all the \"sugar\" removed. For example, if 'T' is a typedef for 'int', the canonical type for 'T' would be 'int'. Wrapper for libclang's clang_getCanonicalType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCommandName-Tuple{Clang.InlineCommand}","page":"API Reference","title":"Clang.getCommandName","text":"getCommandName(c::InlineCommand) -> String\ngetCommandName(c::BlockCommand) -> String\n\nReturn the command name of a command, e.g. \"brief\" for \\brief blah.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorDefinition-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorDefinition","text":"getCursorDefinition(c::CXCursor) -> CXCursor\ngetCursorDefinition(c::CLCursor) -> CLCursor\n\nFor a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorExtent-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getCursorExtent","text":"getCursorExtent(c::Union{CXCursor,CLCursor}) -> CXSourceRange\n\nReturn the physical extent of the source construct referenced by the given cursor.\n\nThe extent of a cursor starts with the file/line/column pointing at the first character within the source construct that the cursor refers to and ends with the last character within that source construct. For a declaration, the extent covers the declaration itself. For a reference, the extent covers the location of the reference (e.g., where the referenced entity was actually used).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLanguage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getCursorLanguage","text":"getCursorLanguage(c::Union{CXCursor,CLCursor}) -> CXLanguageKind\n\nReturn the language of the entity referred to by a given cursor. Return CXLanguage_Invalid if the input cursor is not a decl. Note that, this function has limitations, for example, it cannot distinguish C++ structs from C structs, in both cases, it returns CXLanguage_C.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLexicalParent-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorLexicalParent","text":"getCursorLexicalParent(c::CXCursor) -> CXCursor\ngetCursorLexicalParent(c::CLCursor) -> CLCursor\n\nReturn the lexical parent of the given cursor. Please checkout libclang's doc to know more.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLinkage-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getCursorLinkage","text":"getCursorLinkage(c::Union{CXCursor,CLCursor}) -> CXLinkageKind\n\nReturn the linkage of the entity referred to by a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLocation-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getCursorLocation","text":"getCursorLocation(c::Union{CXCursor,CLCursor}) -> CXSourceLocation\n\nReturn the physical location of the source constructor referenced by the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorReferenced-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorReferenced","text":"getCursorReferenced(c::CXCursor) -> CXCursor\ngetCursorReferenced(c::CLCursor) -> CLCursor\n\nFor a cursor that is a reference, retrieve a cursor representing the entity that it references.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorResultType-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorResultType","text":"getCursorResultType(c::CXCursor) -> CXType\ngetCursorResultType(c::Union{CLFunctionDecl,CLCXXMethod}) -> CLType\n\nReturn the return type associated with a given cursor. This only returns a valid type if the cursor refers to a function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorResultType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getCursorResultType","text":"getCursorResultType(t::CXType) -> CXType\ngetCursorResultType(t::Union{CLFunctionNoProto,CLFunctionProto}) -> CLType\n\nReturn the return type associated with a function type. Wrapper for libclang's clang_getResultType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorSemanticParent-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorSemanticParent","text":"getCursorSemanticParent(c::CXCursor) -> CXCursor\ngetCursorSemanticParent(c::CLCursor) -> CLCursor\n\nReturn the semantic parent of the given cursor. Please checkout libclang's doc to know more.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorType-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getCursorType","text":"getCursorType(c::CXCursor) -> CXType\ngetCursorType(c::CLCursor) -> CLType\n\nReturn the type of a CXCursor (if any). To get the cursor from a type, see getTypeDeclaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getDirection-Tuple{Union{Clang.ParamCommand, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getDirection","text":"getDirection(c::Union{CXComment, ParamCommand})\n\nReturn the parameter passing direction ([in], [out], [in,out]) or missing if the direction is not specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getElementType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getElementType","text":"getElementType(t::CXType) -> CXType\ngetElementType(t::Union{CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray,CLComplex}) -> CLType\n\nReturn the element type of an array, complex, or vector type. Wrapper for libclang's clang_getElementType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getEnumDeclIntegerType-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getEnumDeclIntegerType","text":"getEnumDeclIntegerType(c::CLEnumDecl) -> CLType\n\nRetrieve the integer type of an enum declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getFieldDeclBitWidth-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getFieldDeclBitWidth","text":"getFieldDeclBitWidth(c::CLFieldDecl) -> Int\n\nReturn the bit width of a bit field declaration as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getFunctionTypeCallingConv-Tuple{Union{CLFunctionNoProto, CLFunctionProto, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.getFunctionTypeCallingConv","text":"getFunctionTypeCallingConv(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -> CXCallingConv\n\nReturn the calling convention associated with a function type. Wrapper for libclang's clang_getFunctionTypeCallingConv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getIncludedFile-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getIncludedFile","text":"getIncludedFile(c::Union{CXCursor,CLCursor}) -> CXFile\n\nReturn the file that is included by the given inclusion directive cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getIndex-Tuple{Union{Clang.ParamCommand, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getIndex","text":"getIndex(c::Union{CXComment, ParamCommand})\n\nReturn zero-based parameter index in function prototype or missing if the parameter is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNamedType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getNamedType","text":"getNamedType(t::CXType) -> CXType\ngetNamedType(t::CLElaborated) -> CLType\n\nReturn the type named by the qualified-id. Wrapper for libclang's clang_Type_getNamedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNullCursor-Tuple{}","page":"API Reference","title":"Clang.getNullCursor","text":"getNullCursor() -> CXCursor\n\nReturn the \"NULL\" CXCursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumArguments-Tuple{Union{CLCXXMethod, CLFunctionDecl, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getNumArguments","text":"getNumArguments(c::Union{CXCursor,CLFunctionDecl,CLCXXMethod}) -> Int\n\nReturn the number of non-variadic arguments associated with a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumArguments-Tuple{Union{CLFunctionNoProto, CLFunctionProto, CLUnexposed, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.getNumArguments","text":"getNumArguments(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -> Int\n\nReturn the number of non-variadic parameters associated with a function type. Wrapper for libclang's clang_getNumArgTypes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumElements-Tuple{Union{CLConstantArray, CLDependentSizedArray, CLIncompleteArray, CLVariableArray, CLVector, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.getNumElements","text":"getNumElements(t::Union{CXType,CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray}) -> Int\n\nReturn the number of elements of an array or vector type. Wrapper for libclang's clang_getNumElements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getOffsetOf-Tuple{Clang.LibClang.CXType, Any}","page":"API Reference","title":"Clang.getOffsetOf","text":"getOffsetOf(t::CXType, s) -> Int\ngetOffsetOf(t::CLType, s::AbstractString) -> Int\n\nReturn the offset of a field named S in a record of type T in bits as it would be returned by offsetof as per C++11[18.2p4].\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParagraph-Tuple{Clang.LibClang.CXComment}","page":"API Reference","title":"Clang.getParagraph","text":"getParagraph(c::CXComment)\ngetParagraph(c::BlockCommand)\n\nReturn the paragraph argument of a given command.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParamName-Tuple{Clang.ParamCommand}","page":"API Reference","title":"Clang.getParamName","text":"getParamName(c::ParamCommand) -> String\n\nReturn the name of a parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParsedComment-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getParsedComment","text":"getParsedComment(c::CXCursor) -> CXComment\ngetParsedComment(c::CLCursor) -> CLComment\n\nReturn the parsed AST of doxygen comment associated with the given node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getPointeeType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getPointeeType","text":"getPointeeType(t::CXType) -> CXType\ngetPointeeType(t::CLType) -> CLType\n\nReturn the type of the pointee for pointer types. Wrapper for libclang's clang_getPointeeType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getRenderKind-Tuple{Union{Clang.InlineCommand, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getRenderKind","text":"getRenderKind(c::Union{CXComment, InlineCommand}) -> CXCommentInlineCommandRenderKind\n\nReturn the most appropriate rendering mode, chosen on command semantics in Doxygen.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getSizeOf-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getSizeOf","text":"getSizeOf(t::CXType) -> Int\ngetSizeOf(t::CLType) -> Int\n\nReturn the size of a type in bytes as per C++[expr.sizeof] standard,\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getSourceCode-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getSourceCode","text":"getSourceCode(cursor::Union{CXCursor, CLCursor}) -> String\n\nGet source code for the cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTagName-Tuple{Union{Clang.HTMLEndTag, Clang.HTMLStartTag, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.getTagName","text":"getTagName(c::Union{CXComment, HTMLStartTag, HTMLEndTag})\n\nReturn the tag name of a HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getText-Tuple{Clang.Text}","page":"API Reference","title":"Clang.getText","text":"getText(c::Text) -> String\ngetText(c::VerbatimBlockLine) -> String\ngetText(c::VerbatimLine) -> String\n\nGet the text content assiciated with the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTokenExtent-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}","page":"API Reference","title":"Clang.getTokenExtent","text":"getTokenExtent(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -> CXSourceRange\n\nReturn a source range that covers the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTokenLocation-Tuple{Union{Ptr{Clang.LibClang.CXTranslationUnitImpl}, TranslationUnit}, Union{CLToken, Clang.LibClang.CXToken}}","page":"API Reference","title":"Clang.getTokenLocation","text":"getTokenLocation(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -> CXSourceLocation\n\nReturn the source location of the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTranslationUnit-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.getTranslationUnit","text":"getTranslationUnit(c::Union{CXCursor,CLCursor}) -> CXTranslationUnit\n\nReturns the translation unit that a cursor originated from.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTranslationUnitCursor-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}}","page":"API Reference","title":"Clang.getTranslationUnitCursor","text":"getTranslationUnitCursor(tu::TranslationUnit) -> CLCursor\ngetTranslationUnitCursor(tu::CXTranslationUnit) -> CXCursor\n\nReturn the cursor that represents the given translation unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypeDeclaration-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.getTypeDeclaration","text":"getTypeDeclaration(t::CXType) -> CXCursor\ngetTypeDeclaration(t::CLType) -> CLCursor\n\nReturn the cursor for the declaration of the given type. To get the type of the cursor, see type. Wrapper for libclang's clang_getTypeDeclaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypedefDeclUnderlyingType-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.getTypedefDeclUnderlyingType","text":"getTypedefDeclUnderlyingType(c::CLTypedefDecl) -> CLType\n\nReturn the underlying type of a typedef declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypedefName-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.getTypedefName","text":"getTypedefName(t::Union{CXType,CLType}) -> String\n\nReturn the typedef name of the given type. Wrapper for libclang's clang_getTypedefName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_elaborated_cursor-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.get_elaborated_cursor","text":"get_elaborated_cursor(ty::CLType) -> CLCursor\nget_elaborated_cursor(ty::CXType) -> CXCursor\n\nReturn the cursor of the elaborated type that is referenced by the input type. The input type can be a pointer/array. This function returns clang_getNullCursor if the input type is not refer to an elaborated type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_file_line_column-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.get_file_line_column","text":"get_file_line_column(c::Union{CXCursor,CLCursor}) -> (String, Int, Int)\n\nReturn file name, line and column number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_filename-Tuple{Ptr{Nothing}}","page":"API Reference","title":"Clang.get_filename","text":"get_filename(x::CXFile) -> String\n\nReturn the complete file and path name of the given file\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_filename-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.get_filename","text":"get_filename(c::Union{CXCursor,CLCursor}) -> String\n\nReturn the complete file and path name of the given file referenced by the input cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_function_args-Tuple{CLCursor}","page":"API Reference","title":"Clang.get_function_args","text":"get_function_args(cursor::CLCursor) -> Vector{CLCursor}\n\nReturn function arguments for a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.hasAttrs-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.hasAttrs","text":"hasAttrs(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether the given cursor has any attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.has_elaborated_reference-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.has_elaborated_reference","text":"has_elaborated_reference(ty::CLType) -> Bool\nhas_elaborated_reference(ty::CXType) -> Bool\n\nReturn true if the type is an elaborated type or the type indirectly refers to an elaborated type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.has_function_reference-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.has_function_reference","text":"has_function_reference(ty::CLType) -> Bool\nhas_function_reference(ty::CXType) -> Bool\n\nReturn true if the type is a function or the type indirectly refers to a function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isAnonymous-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isAnonymous","text":"isAnonymous(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the given cursor represents an anonymous record declaration(C++).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isAttribute-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isAttribute","text":"isAttribute(k::CXcursorKind) -> Bool\nisAttribute(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isBitField-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isBitField","text":"isBitField(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the cursor specifies a Record member that is a bitfield.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isConstQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.isConstQualifiedType","text":"isConstQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"const\" qualifier set, without looking through typedefs that may have added \"const\" at a different level. Wrapper for libclang's clang_isConstQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isCursorDefinition-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isCursorDefinition","text":"isCursorDefinition(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the declaration pointed to by this cursor is also a definition of that entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isDeclaration-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isDeclaration","text":"isDeclaration(k::CXcursorKind) -> Bool\nisDeclaration(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isExpression-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isExpression","text":"isExpression(k::CXcursorKind) -> Bool\nisExpression(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isFunctionInlined-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isFunctionInlined","text":"isFunctionInlined(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a CXCursor that is a function declaration, is an inline declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalid-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isInvalid","text":"isInvalid(k::CXcursorKind) -> Bool\nisInvalid(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an valid cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalid-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.isInvalid","text":"isInvalid(t::CXType) -> Bool\nisInvalid(t::CLType) -> Bool\n\nReturn true if the type is a valid type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalidDeclaration-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isInvalidDeclaration","text":"isInvalidDeclaration(x::CXcursorKind) -> Bool\n\nReturn true if the given declaration is invalid. A declaration is invalid if it could not be parsed successfully.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isMacroBuiltin-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isMacroBuiltin","text":"isMacroBuiltin(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a  CXCursor that is a macro, is a builtin one.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isMacroFunctionLike-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isMacroFunctionLike","text":"isMacroFunctionLike(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a CXCursor that is a macro, is function like.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isNull-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isNull","text":"isNull(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if cursor is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isPODType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.isPODType","text":"isPODType(t::Union{CXType,CLType}) -> Bool\n\nReturn true if the CXType is a plain old data type. Wrapper for libclang's clang_isPODType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isPreprocessing-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isPreprocessing","text":"isPreprocessing(k::CXcursorKind) -> Bool\nisPreprocessing(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a preprocessing element, such as a preprocessor directive or macro instantiation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isReference-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isReference","text":"isReference(k::CXcursorKind) -> Bool\nisReference(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a simple reference. Note that other kinds of cursors (such as expressions) can also refer to other cursors. Use getCursorReferenced to determine whether a particular cursor refers to another entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isRestrictQualifiedType-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.isRestrictQualifiedType","text":"isRestrictQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"restrict\" qualifier set, without looking through typedefs that may have added \"restrict\" at a different level. Wrapper for libclang's clang_isRestrictQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isSelfClosing-Tuple{Union{Clang.HTMLStartTag, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.isSelfClosing","text":"isSelfClosing(c::Union{CXComment, HTMLStartTag})\n\nReturn whether a tag is self-closing (for example, <br />).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isStatement-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isStatement","text":"isStatement(k::CXcursorKind) -> Bool\nisStatement(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a statement.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isTranslationUnit-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isTranslationUnit","text":"isTranslationUnit(k::CXcursorKind) -> Bool\nisTranslationUnit(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a translation unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isUnexposed-Tuple{Clang.LibClang.CXCursorKind}","page":"API Reference","title":"Clang.isUnexposed","text":"isUnexposed(k::CXcursorKind) -> Bool\n\nReturn true if the given cursor kind represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVariadic-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isVariadic","text":"isVariadic(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the given cursor is a variadic function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVariadic-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.isVariadic","text":"isVariadic(t::Union{CXType,CLType}) -> Bool\n\nReturn true if the CXType is a variadic function type. Wrapper for libclang's clang_isFunctionTypeVariadic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVirtualBase-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.isVirtualBase","text":"isVirtualBase(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVolatileQualifiedType-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.isVolatileQualifiedType","text":"isVolatileQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"volatile\" qualifier set, without looking through typedefs that may have added \"volatile\" at a different level. Wrapper for libclang's clang_isVolatileQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isWhiteSpace-Tuple{Union{Clang.CLComment, Clang.LibClang.CXComment}}","page":"API Reference","title":"Clang.isWhiteSpace","text":"isWhiteSpace(c::Union{CXComment, CLComment}) -> Bool\n\nReturn whether a CXParagraph or CXText is contains only white space. Return false for other kinds of comment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_forward_declaration-Tuple{CLCursor}","page":"API Reference","title":"Clang.is_forward_declaration","text":"is_forward_declaration(x::CLCursor) -> Bool\n\nReturn true if the cursor is a forward declaration. Reference: https://joshpeterson.github.io/identifying-a-forward-declaration-with-libclang\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_inclusion_directive-Tuple{CLCursor}","page":"API Reference","title":"Clang.is_inclusion_directive","text":"is_inclusion_directive(x::CLCursor) -> Bool\n\nReturn true if the cursor is an inclusion directive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_typedef_anon-Tuple{CLCursor, CLCursor}","page":"API Reference","title":"Clang.is_typedef_anon","text":"is_typedef_anon(current::CLCursor, next::CLCursor) -> Bool\n\nReturn true if the current cursor is a typedef anonymous struct/enum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CLCursor}","page":"API Reference","title":"Clang.kind","text":"kind(c::CLCursor) -> CXCursorKind\n\nReturn the kind of the given cursor. Note this method directly reads CXCursor's kind field, which won't invoke additional clang_getCursorKind function calls.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{Clang.LibClang.CXComment}","page":"API Reference","title":"Clang.kind","text":"kind(c::Union{CXComment, CXComment}) -> CXCommentKind\n\nReturn the kind of a comment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{Clang.LibClang.CXCursor}","page":"API Reference","title":"Clang.kind","text":"kind(c::CXCursor) -> CXCursorKind\n\nReturn the kind of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{Clang.LibClang.CXToken}","page":"API Reference","title":"Clang.kind","text":"kind(t::CXToken) -> CXTokenKind\nkind(t::CLToken) -> CXTokenKind\n\nReturn the kind of the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{Clang.LibClang.CXType}","page":"API Reference","title":"Clang.kind","text":"kind(t::CXType) -> CXTypeKind\nkind(t::CLType) -> CXTypeKind\n\nReturn the kind of the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.name-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.name","text":"name(c::Union{CXCursor,CLCursor}) -> String\n\nReturn the display name for the entity referenced by this cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.parse_header","page":"API Reference","title":"Clang.parse_header","text":"parse_header(\n    index::Index,\n    header::AbstractString,\n    args::Vector{String}=[],\n    flags=CXTranslationUnit_None,\n) -> TranslationUnit\n\nReturn the TranslationUnit for a given header. This is the main entry point for parsing.\n\nArguments\n\nheader::AbstractString: the header file to parse.\nindex::Index: CXIndex pointer (pass to avoid re-allocation).\nargs::Vector{String}: compiler switches as string array, eg: [\"-x\", \"c++\", \"-fno-elide-type\"].\nflags: bitwise OR of CXTranslationUnit_Flags.\n\nSee also parse_headers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clang.parse_headers","page":"API Reference","title":"Clang.parse_headers","text":"parse_headers(\n    index::Index,\n    headers::Vector{String},\n    args::Vector{String}=[],\n    flags=CXTranslationUnit_None,\n) -> Vector{TranslationUnit}\n\nReturn a TranslationUnit vector for the given headers.\n\nSee also parse_header.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clang.search-Union{Tuple{T}, Tuple{Vector{T}, Function}} where T<:CLCursor","page":"API Reference","title":"Clang.search","text":"search(cursors::Vector{CLCursor}, ismatch::Function) -> Vector{CLCursor}\n\nReturn vector of CLCursors that match predicate. ismatch is a function that accepts a CLCursor argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Clang.LibClang.CXTypeKind}","page":"API Reference","title":"Clang.spelling","text":"spelling(kind::CXTypeKind) -> String\n\nReturn the spelling of a given CXTypeKind.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Ptr{Clang.LibClang.CXTranslationUnitImpl}, Clang.LibClang.CXToken}","page":"API Reference","title":"Clang.spelling","text":"spelling(tu::TranslationUnit, t::CLToken) -> String\nspelling(tu::TranslationUnit, t::CXToken) -> String\nspelling(tu::CXTranslationUnit, t::CXToken) -> String\n\nReturn the spelling of the given token. The spelling of a token is the textual representation of that token, e.g., the text of an identifier or keyword.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{TranslationUnit}","page":"API Reference","title":"Clang.spelling","text":"spelling(tu::TranslationUnit) -> String\n\nReturn the original translation unit source file name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.spelling","text":"spelling(c::Union{CXCursor,CLCursor}) -> String\n\nReturn a name for the entity referenced by this cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Union{CLType, Clang.LibClang.CXType}}","page":"API Reference","title":"Clang.spelling","text":"spelling(t::Union{CXType,CLType}) -> String\n\nPretty-print the underlying type using the rules of the language of the translation unit from which it came. If the type is invalid, an empty string is returned. Wrapper for libclang's clang_getTypeSpelling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.tokenize-Tuple{Union{CLCursor, Clang.LibClang.CXCursor}}","page":"API Reference","title":"Clang.tokenize","text":"tokenize(c::Union{CXCursor,CLCursor}) -> TokenList\n\nReturn a TokenList from the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.value-Tuple{CLEnumConstantDecl}","page":"API Reference","title":"Clang.value","text":"value(c::CLCursor) -> Integer\n\nReturn the integer value of an enum constant declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.Index","page":"API Reference","title":"Clang.Index","text":"Index(exclude_decls_from_PCH, display_diagnostics)\n\nProvide a shared context for creating translation units.\n\nArguments\n\nexclude_decls_from_PCH: whether we only want to see \"local\" declarations (that did not come from a previous precompiled header). If false, we want to see all declarations.\ndisplay_diagnostics: whether to display diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Clang.TokenList","page":"API Reference","title":"Clang.TokenList","text":"TokenList\n\nTokenizer accessor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Clang.TranslationUnit","page":"API Reference","title":"Clang.TranslationUnit","text":"TranslationUnit(idx, source, args)\nTranslationUnit(idx, source, args, unsavedFiles, options)\n\nParse the given source file and the translation unit corresponding to that file.\n\n\n\n\n\n","category":"type"},{"location":"generator/#Generator-Tutorial","page":"Generator Tutorial","title":"Generator Tutorial","text":"","category":"section"},{"location":"generator/#Variadic-Function","page":"Generator Tutorial","title":"Variadic Function","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"With the help of @ccall macro, variadic C functions can be from Julia, for example, @ccall printf(\"%d\\n\"::Cstring; 123::Cint)::Cint can be used to call the C function printf. Note that those arguments after the semicolon ; are variadic arguments.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"If wrap_variadic_function in codegen section of options is set to true, Clang.jl will generate wrappers for variadic C functions, for example, printf will be wrapped as:","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"@generated function printf(fmt, va_list...)\n        :(@ccall(libexample.printf(fmt::Ptr{Cchar}; $(to_c_type_pairs(va_list)...))::Cint))\n    end","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"It can be called just like normal Julia functions without specifying types: LibExample.printf(\"%d\\n\", 123).","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"note: Note\nAlthough variadic functions are supported, the C type va_list can not be used from Julia.","category":"page"},{"location":"generator/#Type-Correspondence","page":"Generator Tutorial","title":"Type Correspondence","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"However, variadic C functions must be called with the correct argument types. The most useful ones are listed below:","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"C type ccall signature Julia type\nIntegers and floating point numbers the same type the same type\nStruct T a concrete Julia struct T with the same layout T\nPointer (T*) Ref{T} or Ptr{T} Ref{T} or Ptr{T} or any array type\nString (char*) Cstring or Ptr{Cchar} String","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"As observed from the table, if you want to pass strings or arrays to C, you need to annotate the type as Ptr{T} or Ref{T} (or Cstring), otherwise the struct that represents the String or Arraytype instead of the buffer itself will be passed. There are two methods to pass arguments of these types:","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"directly use @ccall macro: @ccall printf(\"%s\\n\"; \"hello\"::Cstring)::Cint. You can also create wrappers for common use cases of this.\noverload to_c_type to map Julia type to correct ccall signature type: add to_c_type(::Type{String}) = Cstring to prologue (prologue can be added by setting prologue_file_path in options). Then all arguments of String will be annotated as Cstring.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"For a complete tutorial on calling C functions, refer to Calling C and Fortran Code in the Julia manual.","category":"page"},{"location":"#Clang","page":"Introduction","title":"Clang","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides a Julia language wrapper for libclang: the stable, C-exported interface to the LLVM Clang compiler. The libclang API documentation provides background on the functionality available through libclang, and thus through the Julia wrapper. The repository also hosts related tools built on top of libclang functionality.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Now, the package provides an out-of-box installation experience on Linux, macOS and Windows. You could simply install it by running:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add Clang","category":"page"},{"location":"#C-bindings-generator","page":"Introduction","title":"C-bindings generator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package includes a generator to create Julia wrappers for C libraries from a collection of header files. The following declarations are currently supported:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function: translated to Julia ccall(va_list and vararg argument are not supported)\nstruct: translated to Julia struct\nenum: translated to CEnum\nunion: translated to Julia struct\ntypedef: translated to Julia typealias to underlying intrinsic type\nmacro: limited support(see src/wrap_c.jl)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is a simple example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Clang\nusing Clang_jll # `pkg> activate Clang`\n\n# LIBCLANG_HEADERS are those headers to be wrapped.\nconst LIBCLANG_INCLUDE = joinpath(dirname(Clang_jll.libclang_path), \"..\", \"include\", \"clang-c\") |> normpath\nconst LIBCLANG_HEADERS = [joinpath(LIBCLANG_INCLUDE, header) for header in readdir(LIBCLANG_INCLUDE) if endswith(header, \".h\")]\n\nwc = init(; headers = LIBCLANG_HEADERS,\n            output_file = joinpath(@__DIR__, \"libclang_api.jl\"),\n            common_file = joinpath(@__DIR__, \"libclang_common.jl\"),\n            clang_includes = vcat(LIBCLANG_INCLUDE, CLANG_INCLUDE),\n            clang_args = [\"-I\", joinpath(LIBCLANG_INCLUDE, \"..\")],\n            header_wrapped = (root, current)->root == current,\n            header_library = x->\"libclang\",\n            clang_diagnostics = true,\n            )\n\nrun(wc)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that it might complain about missing some std headers, e.g. fatal error: 'time.h' file not found, which could be fixed by adding -Istdlib/include/on/your/specific/platform to clang_args, for example,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# on macOS\nusing Clang: find_std_headers\nfor header in find_std_headers()\n    push!(clang_args, \"-I\"*header)\nend","category":"page"},{"location":"#Build-a-custom-C-bindings-generator","page":"Introduction","title":"Build a custom C-bindings generator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A custom C-bindings generator tends to be used on large codebases, often with multiple API versions to support. Building a generator requires some customization effort, so for small libraries the initial investment may not pay off.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The above-mentioned C-bindings generator only exposes several entry points for customization. In fact, it's actually not that hard to directly build your own C-bindings generator, for example, the following script is used for generating LibClang, you could refer to LibClang Tutorial for further details.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Write a config file generator.toml:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[general]\nlibrary_name = \"libclang\"\noutput_file_path = \"./LibClang.jl\"\nmodule_name = \"LibClang\"\njll_pkg_name = \"Clang_jll\"\nexport_symbol_prefixes = [\"CX\", \"clang_\"]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"and a Julia script generator.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Clang.Generators\nusing Clang.LibClang.Clang_jll\n\ncd(@__DIR__)\n\ninclude_dir = joinpath(Clang_jll.artifact_dir, \"include\") |> normpath\nclang_dir = joinpath(include_dir, \"clang-c\")\n\noptions = load_options(joinpath(@__DIR__, \"generator.toml\"))\n\n# add compiler flags, e.g. \"-DXXXXXXXXX\"\nargs = get_default_args()\npush!(args, \"-I$include_dir\")\n\nheaders = [joinpath(clang_dir, header) for header in readdir(clang_dir) if endswith(header, \".h\")]\n# there is also an experimental `detect_headers` function for auto-detecting top-level headers in the directory\n# headers = detect_headers(clang_dir, args)\n\n# create context\nctx = create_context(headers, args, options)\n\n# run generator\nbuild!(ctx)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please refer to this toml file for a full list of configuration options.","category":"page"},{"location":"#v0.12-example","page":"Introduction","title":"v0.12 example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The generator above is the recommended generator for v0.14 and above. There was another generator wrappper before, here is an example.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Clang\nusing Clang_jll # `pkg> activate Clang`\n\nconst LIBCLANG_INCLUDE = joinpath(dirname(Clang_jll.libclang_path), \"..\", \"include\", \"clang-c\") |> normpath\nconst LIBCLANG_HEADERS = [joinpath(LIBCLANG_INCLUDE, header) for header in readdir(LIBCLANG_INCLUDE) if endswith(header, \".h\")]\n\n# create a work context\nctx = DefaultContext()\n\n# parse headers\nparse_headers!(ctx, LIBCLANG_HEADERS,\n               args=[\"-I\", joinpath(LIBCLANG_INCLUDE, \"..\")],\n               includes=vcat(LIBCLANG_INCLUDE, CLANG_INCLUDE),\n               )\n\n# settings\nctx.libname = \"libclang\"\nctx.options[\"is_function_strictly_typed\"] = false\nctx.options[\"is_struct_mutable\"] = false\n\n# write output\napi_file = joinpath(@__DIR__, \"libclang_api.jl\")\napi_stream = open(api_file, \"w\")\n\nfor trans_unit in ctx.trans_units\n    root_cursor = getcursor(trans_unit)\n    push!(ctx.cursor_stack, root_cursor)\n    header = spelling(root_cursor)\n    @info \"wrapping header: $header ...\"\n    # loop over all of the child cursors and wrap them, if appropriate.\n    ctx.children = children(root_cursor)\n    for (i, child) in enumerate(ctx.children)\n        child_name = name(child)\n        child_header = get_filename(child)\n        ctx.children_index = i\n        # choose which cursor to wrap\n        startswith(child_name, \"__\") && continue  # skip compiler definitions\n        child_name in keys(ctx.common_buffer) && continue  # already wrapped\n        child_header != header && continue  # skip if cursor filename is not in the headers to be wrapped\n\n        wrap!(ctx, child)\n    end\n    @info \"writing $(api_file)\"\n    println(api_stream, \"# Julia wrapper for header: $(basename(header))\")\n    println(api_stream, \"# Automatically generated using Clang.jl\\n\")\n    print_buffer(api_stream, ctx.api_buffer)\n    empty!(ctx.api_buffer)  # clean up api_buffer for the next header\nend\nclose(api_stream)\n\n# write \"common\" definitions: types, typealiases, etc.\ncommon_file = joinpath(@__DIR__, \"libclang_common.jl\")\nopen(common_file, \"w\") do f\n    println(f, \"# Automatically generated using Clang.jl\\n\")\n    print_buffer(f, dump_to_buffer(ctx.common_buffer))\nend\n\n# uncomment the following code to generate dependency and template files\n# copydeps(dirname(api_file))\n# print_template(joinpath(dirname(api_file), \"LibTemplate.jl\"))","category":"page"},{"location":"#LibClang","page":"Introduction","title":"LibClang","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"LibClang is a thin wrapper over libclang. It's one-to-one mapped to the libclang APIs. By using Clang.LibClang, all of the CX/clang_-prefixed libclang APIs are imported into the current namespace, with which you could build up your own tools from the scratch. If you are unfamiliar with the Clang AST, a good starting point is the Introduction to the Clang AST.","category":"page"},{"location":"tutorial/#LibClang-Tutorial","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Clang is an open-source compiler built on the LLVM framework and targeting C, C++, and Objective-C (LLVM is also the JIT backend for Julia). Due to a highly modular design, Clang has in recent years become the core of a growing number of projects utilizing pieces of the compiler, such as tools for source-to-source translation, static analysis and security evaluation, and editor tools for code completion, formatting, etc.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"While LLVM and Clang are written in C++, the Clang project maintains a C-exported interface called \"libclang\" which provides access to the abstract syntax tree and type representations. Thanks to the ubiquity of support for C calling conventions, a number of languages have utilized libclang as a basis for tooling related to C and C++.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The Clang.jl Julia package wraps libclang, provides a small convenience API for Julia-style programming, and provides a C-to-Julia wrapper generator built on libclang functionality.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Here is the header file example.h used in the following examples:  ","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"// example.h\nstruct ExStruct {\n    int    kind;\n    char*  name;\n    float* data;\n};\n\nvoid* ExFunction (int kind, char* name, float* data) {\n    struct ExStruct st;\n    st.kind = kind;\n    st.name = name;\n    st.data = data;\n}","category":"page"},{"location":"tutorial/#Printing-Struct-Fields","page":"LibClang Tutorial","title":"Printing Struct Fields","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To motivate the discussion with a succinct example, consider this struct:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"struct ExStruct {\n    int    kind;\n    char*  name;\n    float* data;\n};","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Parsing and querying the fields of this struct requires just a few lines of code:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> using Clang\n\njulia> trans_unit = Clang.parse_header(Index(), \"example.h\")\nTranslationUnit(Ptr{Nothing} @0x00007fe13cdc8a00, Index(Ptr{Nothing} @0x00007fe13cc8dde0, 0, 1))\n\njulia> root_cursor = Clang.getTranslationUnitCursor(trans_unit)\nCLCursor (CLTranslationUnit) example.h\n\njulia> struct_cursor = search(root_cursor, \"ExStruct\") |> only\nCLCursor (CLStructDecl) ExStruct\n\njulia> for c in children(struct_cursor)  # print children\n           println(\"Cursor: \", c, \"\\n  Kind: \", kind(c), \"\\n  Name: \", name(c), \"\\n  Type: \", Clang.getCursorType(c))\n       end\nCursor: CLCursor (CLFieldDecl) kind\n  Kind: CXCursor_FieldDecl(6)\n  Name: kind\n  Type: CLType (CLInt)\nCursor: CLCursor (CLFieldDecl) name\n  Kind: CXCursor_FieldDecl(6)\n  Name: name\n  Type: CLType (CLPointer)\nCursor: CLCursor (CLFieldDecl) data\n  Kind: CXCursor_FieldDecl(6)\n  Name: data\n  Type: CLType (CLPointer)","category":"page"},{"location":"tutorial/#AST-Representation","page":"LibClang Tutorial","title":"AST Representation","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Let's examine the example above, starting with the variable trans_unit:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> trans_unit\nTranslationUnit(Ptr{Nothing} @0x00007fa9ac6a9f90, Index(Ptr{Nothing} @0x00007fa9ac6b4080, 0, 1))","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"A TranslationUnit is the entry point to the libclang AST. In the example above, trans_unit is a TranslationUnit for the parsed file example.h. The libclang AST is represented as a directed acyclic graph of cursor nodes carrying three pieces of essential information:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Kind: purpose of cursor node\nType: type of the object represented by cursor\nChildren: list of child nodes","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> root_cursor\nCLCursor (CLTranslationUnit) example.h","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"root_cursor is the root cursor node of the TranslationUnit.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"In Clang.jl the cursor type is encapsulated by a Julia type deriving from the abstract type CLCursor. Under the hood, libclang represents each cursor (CXCursor) kind and type (CXType) as an enum value. These enum values are used to automatically map all CXCursor and CXType objects to Julia types. Thus, it is possible to write multiple-dispatch methods against CLCursor or CLType variables.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> dump(root_cursor)\nCLTranslationUnit\n  cursor: Clang.LibClang.CXCursor\n    kind: Clang.LibClang.CXCursorKind CXCursor_TranslationUnit(300)\n    xdata: Int32 0\n    data: Tuple{Ptr{Nothing},Ptr{Nothing},Ptr{Nothing}}\n      1: Ptr{Nothing} @0x00007fe13b3552e8\n      2: Ptr{Nothing} @0x0000000000000001\n      3: Ptr{Nothing} @0x00007fe13cdc8a00","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Under the hood, libclang represents each cursor kind and type as an enum value. These enums are translated into Julia as a subtype of Cenum:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> dump(Clang.LibClang.CXCursorKind)\nClang.LibClang.CXCursorKind <: Clang.LibClang.CEnum.Cenum{UInt32}","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The example demonstrates two different ways of accessing child nodes of a given cursor. Here, the children function returns an iterator over the child nodes of the given cursor:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> children(struct_cursor)\n3-element Array{CLCursor,1}:\n CLCursor (CLFieldDecl) kind\n CLCursor (CLFieldDecl) name\n CLCursor (CLFieldDecl) data","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"And here, the search function returns a list of child node(s) matching the given name:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> search(root_cursor, \"ExStruct\")\n1-element Array{CLCursor,1}:\n CLCursor (CLStructDecl) ExStruct","category":"page"},{"location":"tutorial/#Type-representation","page":"LibClang Tutorial","title":"Type representation","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The above example also demonstrates querying of the type associated with a given cursor using the helper function type. In the output:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Cursor: CLCursor (CLFieldDecl) kind\n  Kind: CXCursor_FieldDecl(6)\n  Name: kind\n  Type: CLType (CLInt)\nCursor: CLCursor (CLFieldDecl) name\n  Kind: CXCursor_FieldDecl(6)\n  Name: name\n  Type: CLType (CLPointer)\nCursor: CLCursor (CLFieldDecl) data\n  Kind: CXCursor_FieldDecl(6)\n  Name: data\n  Type: CLType (CLPointer)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Each CLFieldDecl cursor has an associated CLType object, with an identity reflecting the field type for the given struct member. It is critical to note the difference between the representation for the kind field and the name and data fields. kind is represented directly as an CLInt object, but name and data are represented as CLPointer CLTypes. As explored in the next section, the full type of the CLPointer can be queried to retrieve the full char * and float * types of these members. User-defined types are captured using a similar scheme.","category":"page"},{"location":"tutorial/#Function-Arguments-and-Types","page":"LibClang Tutorial","title":"Function Arguments and Types","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To further explore type representations, consider the following function (included in example.h):","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"void* ExFunction (int kind, char* name, float* data) {\n    struct ExStruct st;\n    st.kind = kind;\n    st.name = name;\n    st.data = data;\n}","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To find the cursor for this function declaration, we use function search to retrieve nodes of kind  CXCursor_FunctionDecl , and select the final one in the list:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> using Clang.LibClang  # CXCursor_FunctionDecl is exposed from LibClang\n\njulia> fdecl = search(root_cursor, CXCursor_FunctionDecl) |> only\nCLCursor (CLFunctionDecl) ExFunction(int, char *, float *)\n\njulia> fdecl_children = [c for c in children(fdecl)]\n4-element Array{CLCursor,1}:\n CLCursor (CLParmDecl) kind\n CLCursor (CLParmDecl) name\n CLCursor (CLParmDecl) data\n CLCursor (CLCompoundStmt)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The first three children are CLParmDecl cursors with the same name as the arguments in the function signature. Checking the types of the CLParmDecl cursors indicates a similarity to the function signature:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> [Clang.getCursorType(t) for t in fdecl_children[1:3]]\n3-element Array{CLType,1}:\n CLType (CLInt)     \n CLType (CLPointer)\n CLType (CLPointer)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"And, finally, retrieving the target type of each CLPointer argument confirms that these cursors represent the function argument type declaration:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> [Clang.getPointeeType(Clang.getCursorType(t)) for t in fdecl_children[2:3]]\n2-element Array{CLType,1}:\n CLType (CLChar_S)\n CLType (CLFloat)  ","category":"page"},{"location":"tutorial/#Printing-Indented-Cursor-Hierarchy","page":"LibClang Tutorial","title":"Printing Indented Cursor Hierarchy","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"As a closing example, here is a simple, indented AST printer using CLType- and CLCursor-related functions, and utilizing various aspects of Julia's type system.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"printind(ind::Int, st...) = println(join([repeat(\" \", 2*ind), st...]))\n\nprintobj(cursor::CLCursor) = printobj(0, cursor)\nprintobj(t::CLType) = join(typeof(t), \" \", spelling(t))\nprintobj(t::CLInt) = t\nprintobj(t::CLPointer) = Clang.getPointeeType(t)\nprintobj(ind::Int, t::CLType) = printind(ind, printobj(t))\n\nfunction printobj(ind::Int, cursor::Union{CLFieldDecl, CLParmDecl})\n    printind(ind+1, typeof(cursor), \" \", printobj(Clang.getCursorType(cursor)), \" \", name(cursor))\nend\n\nfunction printobj(ind::Int, node::Union{CLCursor, CLStructDecl, CLCompoundStmt,\n                                        CLFunctionDecl, CLBinaryOperator})\n    printind(ind, \" \", typeof(node), \" \", name(node))\n    for c in children(node)\n        printobj(ind + 1, c)\n    end\nend","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> printobj(root_cursor)\n CLTranslationUnit example.h\n   CLStructDecl ExStruct\n      CLFieldDecl CLType (CLInt)  kind\n      CLFieldDecl CLType (CLChar_S)  name\n      CLFieldDecl CLType (CLFloat)  data\n   CLFunctionDecl ExFunction(int, char *, float *)\n      CLParmDecl CLType (CLInt)  kind\n      CLParmDecl CLType (CLChar_S)  name\n      CLParmDecl CLType (CLFloat)  data\n     CLCompoundStmt\n       CLDeclStmt\n         CLVarDecl st\n           CLTypeRef struct ExStruct\n       CLBinaryOperator\n         CLMemberRefExpr kind\n           CLDeclRefExpr st\n         CLUnexposedExpr kind\n           CLDeclRefExpr kind\n       CLBinaryOperator\n         CLMemberRefExpr name\n           CLDeclRefExpr st\n         CLUnexposedExpr name\n           CLDeclRefExpr name\n       CLBinaryOperator\n         CLMemberRefExpr data\n           CLDeclRefExpr st\n         CLUnexposedExpr data\n           CLDeclRefExpr data","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Note that a generic printobj function has been defined for the abstract CLType and CLCursor types, and multiple dispatch is used to define the printers for various specific types needing custom behavior. In particular, the following function handles all cursor types for which recursive printing of child nodes is required:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"function printobj(ind::Int, node::Union{CLCursor, CLStructDecl, CLCompoundStmt, CLFunctionDecl})","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Now, printobj has been moved into Clang.jl with a new name: dumpobj.","category":"page"},{"location":"tutorial/#Parsing-Summary","page":"LibClang Tutorial","title":"Parsing Summary","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"As discussed above, there are several key aspects of the Clang.jl/libclang API:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"tree of Cursor nodes representing the AST, notes have unique children.\neach Cursor node has a Julia type identifying the syntactic construct represented by the node.\neach node also has an associated CLType referencing either intrinsic or user-defined datatypes.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"There are a number of details omitted from this post, especially concerning the full variety of CLCursor and CLType representations available via libclang. For further information, please see the libclang documentation.","category":"page"},{"location":"tutorial/#Acknowledgement","page":"LibClang Tutorial","title":"Acknowledgement","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Eli Bendersky's post Parsing C++ in Python with Clang has been an extremely helpful reference.","category":"page"}]
}
