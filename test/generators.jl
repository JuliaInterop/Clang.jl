using Clang
using Clang.Generators
using Clang.LibClang.Clang_jll
using Test
using Clang.Generators: StructDefinition, StructMutualRef, strip_comment_markers

include("rewriter.jl")

@testset "Generators" begin
    INCLUDE_DIR = normpath(Clang_jll.artifact_dir, "include")
    CLANG_C_DIR = joinpath(INCLUDE_DIR, "clang-c")

    options = load_options(joinpath(@__DIR__, "test.toml"))

    # add compiler flags
    args = get_default_args()
    push!(args, "-I$INCLUDE_DIR")

    # search top-level headers
    headers = detect_headers(CLANG_C_DIR, args)

    # add extra definition
    @add_def time_t AbstractJuliaSIT JuliaCtime_t Ctime_t

    # create context
    ctx = create_context(headers, args, options)

    # build without printing so we can do custom rewriting
    build!(ctx, BUILDSTAGE_NO_PRINTING)

    rewrite!(ctx.dag)

    # print
    @test_logs (:info, "Done!") match_mode=:any build!(ctx, BUILDSTAGE_PRINTING_ONLY)
end

@testset "Comments" begin
    @test strip_comment_markers("/* abc */") == ["abc "]
    @test strip_comment_markers("/** abc */") == ["abc "]
    @test strip_comment_markers("/*< abc */") == ["abc "]
    @test strip_comment_markers("/// hello") == ["hello"]
    @test strip_comment_markers("/**\n * line1\n * line2\n */") == ["line1", "line2"]
    @test strip_comment_markers("/*!\n * line1\n * line2\n */") == ["line1", "line2"]
    @test strip_comment_markers("    /// line1\n    /// line2") == ["line1", "line2"]
    @test strip_comment_markers("//! line1\n//! line2") == ["line1", "line2"]
    @test strip_comment_markers("//! line1") == ["line1"]
    @test strip_comment_markers("//< line1") == ["line1"]
end

@testset "Resolve dependency" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "dependency.h")
    options = Dict("general" => Dict{String,Any}(
            "output_file_path" => joinpath(@__DIR__, "LibDependency.jl")))
    ctx = create_context(headers, args, options)
    build!(ctx)
    @test include("LibDependency.jl") isa Any
end

# See:
# - https://github.com/JuliaInterop/Clang.jl/discussions/440
# - https://github.com/JuliaInterop/Clang.jl/pull/441
@testset "Cycle detection" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "cycle-detection.h")
    ctx = create_context(headers, args)
    build!(ctx)

    # In this particular case there is only one cycle in B, so only B should be
    # a StructMutualRef.
    mutual_ref_nodes = [node for node in ctx.dag.nodes if node.type == StructMutualRef()]
    @test length(mutual_ref_nodes) == 1
    @test mutual_ref_nodes[1].id == :B
end

# Check the Base.unsafe_convert() specializations that are generated by emit!()
# for TypedefMutualRef's. These use the original struct in their signatures to
# avoid method ambiguities with Base, so they must be emitted after the struct.
@testset "TypedefMutualRef method ambiguity" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "method-ambiguity.h")
    ctx = create_context(headers, args)
    build!(ctx)

    # Find the StructDefinition node
    struct_idx = findfirst(x -> x.id == :foo_struct && x.type isa StructDefinition,
                           ctx.dag.nodes)
    node = ctx.dag.nodes[struct_idx]

    # There should be three expressions, one for the struct and the other two
    # for the Base.unsafe_convert() specializations.
    @test length(node.exprs) == 3
    # The first expression should be the for the struct
    @test node.exprs[1].head == :struct
    # And the others should be functions (in compact form, hence the :(=) comparison)
    @test node.exprs[2].head == :(=)
    @test node.exprs[3].head == :(=)
end

@testset "Sanity checking" begin
    ctx = create_context(joinpath(@__DIR__, "include/sanity-checks.h"), get_default_args())
    @test_logs (:warn, r"function-like macro .* foo") match_mode = :any build!(ctx)
    @test_logs (:warn, r"function .* post") match_mode = :any build!(ctx)
end

@testset "Issue 320" begin
    args = get_default_args()
    dir = joinpath(@__DIR__, "sys")
    push!(args, "-isystem$dir")
    headers = [joinpath(@__DIR__, "include", "test.h")]
    ctx = create_context(headers, args)
    @add_def stat
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any
end

@testset "Escape anonymous name with var\"\"" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "escape-with-var.h")
    options = Dict("general" => Dict{String,Any}(
            "output_file_path" => joinpath(@__DIR__, "LibEscapeWithVar.jl")))
    ctx = create_context(headers, args, options)
    build!(ctx)
    @test include("LibEscapeWithVar.jl") isa Any
end

@testset "Issue 307" begin
    args = get_default_args()
    dir = joinpath(@__DIR__, "sys")
    push!(args, "-isystem$dir")
    headers = joinpath(@__DIR__, "include", "struct-in-union.h")
    ctx = create_context(headers, args)
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any

    headers = joinpath(@__DIR__, "include", "nested-struct.h")
    ctx = create_context(headers, args)
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any

    headers = joinpath(@__DIR__, "include", "nested-declaration.h")
    ctx = create_context(headers, args)
    @test_broken try
        build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any
        true
    catch
        false
    end
end

@testset "Issue 327" begin
    tu = parse_header(Index(), joinpath(@__DIR__, "include/void-type.h"))
    root = Clang.getTranslationUnitCursor(tu)
    func = children(root)[]
    ret_type = Clang.getCursorResultType(func)
    @test ret_type isa CLVoid
end

@testset "Issue 355" begin
    tu = parse_header(Index(), joinpath(@__DIR__, "include/return-funcptr.h"))
    root = Clang.getTranslationUnitCursor(tu)
    func = children(root)[3]
    @test length(get_function_args(func)) == 1
end

@testset "macros" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro.h"), get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "#368" begin
    ctx = create_context(joinpath(@__DIR__, "include/union-in-struct.h"),
                         get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
    @test ctx.dag.nodes[end].id == :A
    @test ctx.dag.nodes[end].type isa Generators.StructLayout
end

@testset "Issue 376" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro-dependency.h"), get_default_args())
    @test build!(ctx) isa Any
end

@testset "Issue 233" begin
    ctx = create_context(joinpath(@__DIR__, "include/union-in-anon-struct.h"), get_default_args())
    @test build!(ctx) isa Any
end

@testset "Issue 389" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro.h"), get_default_args())
    build!(ctx)
    @test ctx.dag.nodes[ctx.dag.ids[:foo]].type isa AbstractFunctionNodeType
end

@testset "Issue 392" begin
    ctx = create_context([joinpath(@__DIR__, "include/a.h"),
                          joinpath(@__DIR__, "include/dup_a.h")], get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 412" begin
    ctx = create_context([joinpath(@__DIR__, "include/enum.h")], get_default_args())
    @test_throws Exception build!(ctx)
end

@testset "Issue 412 - no audit" begin
    options = Dict("general" => Dict{String,Any}("no_audit" => true))
    ctx = create_context([joinpath(@__DIR__, "include/enum.h")], get_default_args(), options)
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 452 - StructMutualRef" begin
    ctx = create_context([joinpath(@__DIR__, "include/struct-mutual-ref.h")], get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 455 - skip static functions" begin
    options = Dict("general" => Dict{String,Any}("skip_static_functions" => true))
    ctx = create_context([joinpath(@__DIR__, "include/static.h")], get_default_args(), options)
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

# Test the documentation parser
@testset "Documentation" begin
    function doc_callback(node::ExprNode, doc::Vector{String})
        return vcat(doc, "callback")
    end

    mktemp() do path, io
        # Generate the bindings
        options = Dict("general" => Dict{String, Any}("output_file_path" => path,
                                                      "extract_c_comment_style" => "doxygen",
                                                      "callback_documentation" => doc_callback))
        ctx = create_context([joinpath(@__DIR__, "include/documentation.h")], get_default_args(), options)
        build!(ctx)

        # Load into a temporary module to avoid polluting the global namespace
        m = Module()
        Base.include(m, path)

        # Do some sanity checks on the docstring
        docstring = string(@doc m.doxygen_func)
        docstring_has = occursin(docstring)
        @test docstring_has("!!! compat \"Deprecated\"")
        @test docstring_has("# Arguments")
        @test docstring_has(" * `foo`: A parameter")
        @test docstring_has("# Returns")
        @test docstring_has("Whatever I want")
        @test docstring_has("!!! danger \"Known bug\"")
        @test docstring_has("# See also")
        @test docstring_has("quux()")
        @test docstring_has("callback")
    end
end

@testset "Struct getproperty()/setproperty!()" begin
    options = Dict("general" => Dict{String, Any}("auto_mutability" => true,
                                                  "auto_mutability_with_new" => false,
                                                  "auto_mutability_includelist" => ["WithFields"]),
                   "codegen" => Dict{String, Any}("field_access_method_list" => ["WithFields", "Other"]))

    # Test the default getproperty()/setproperty!() behaviour
    mktemp() do path, io
        options["general"]["output_file_path"] = path
        ctx = create_context([joinpath(@__DIR__, "include/struct-properties.h")], get_default_args(), options)
        build!(ctx)

        println(read(path, String))

        m = Module()
        Base.include(m, path)

        # We now have to run in the latest world to use the new definitions
        Base.invokelatest() do
            obj = m.WithFields(1, C_NULL, m.Other(42), C_NULL, m.TypedefStruct(1), (1, 1))

            GC.@preserve obj begin
                obj_ptr = Ptr{m.WithFields}(pointer_from_objref(obj))

                # The default getproperty() should basically always return a
                # pointer to the field (except for bitfields, which are tested
                # elsewhere).
                @test obj_ptr.int_value isa Ptr{Cint}
                @test obj_ptr.int_ptr isa Ptr{Ptr{Cint}}
                @test obj_ptr.struct_value isa Ptr{m.Other}
                @test obj_ptr.typedef_struct_value isa Ptr{m.TypedefStruct}
                @test obj_ptr.array isa Ptr{NTuple{2, Cint}}

                # Sanity test
                int_value = unsafe_load(obj_ptr.int_value)
                @test int_value == obj.int_value

                # Test setproperty!()
                obj_ptr.int_value = int_value + 1
                @test unsafe_load(obj_ptr.int_value) == int_value + 1
            end
        end
    end

    # Test the auto_field_dereference option
    mktemp() do path, io
        options["general"]["output_file_path"] = path
        options["codegen"]["auto_field_dereference"] = true
        ctx = create_context([joinpath(@__DIR__, "include/struct-properties.h")], get_default_args(), options)
        build!(ctx)

        println(read(path, String))

        m = Module()
        Base.include(m, path)

        # We now have to run in the latest world to use the new definitions
        Base.invokelatest() do
            obj = m.WithFields(1, C_NULL, m.Other(42), C_NULL, m.TypedefStruct(1), (1, 1))

            GC.@preserve obj begin
                obj_ptr = Ptr{m.WithFields}(pointer_from_objref(obj))

                # Test getproperty()
                @test obj_ptr.int_value isa Cint
                @test obj_ptr.int_value == obj.int_value
                @test obj_ptr.int_ptr isa Ptr{Cint}

                @test obj_ptr.struct_value isa Ptr{m.Other}
                @test obj_ptr.struct_value.i == obj.struct_value.i
                @test obj_ptr.struct_ptr isa Ptr{m.Other}
                @test obj_ptr.typedef_struct_value isa Ptr{m.TypedefStruct}

                @test obj_ptr.array isa Ptr{NTuple{2, Cint}}

                field_exception_t = @static if VERSION >= v"1.12.0-DEV"
                    FieldError
                else
                    ErrorException
                end
                @test_throws field_exception_t obj_ptr.foo

                # Test @ptr
                val_ptr = @eval m @ptr $obj_ptr.int_value
                @test val_ptr isa Ptr{Cint}
                int_ptr = @eval m @ptr $obj_ptr.int_ptr
                @test int_ptr isa Ptr{Ptr{Cint}}

                @test_throws LoadError (@eval m @ptr $obj_ptr)
                @test_throws field_exception_t (@eval m @ptr $obj_ptr.foo)

                # Test setproperty!()
                new_value = obj.int_value * 2
                obj_ptr.int_value = new_value
                @test obj.int_value == new_value

                new_value = obj.struct_value.i * 2
                obj_ptr.struct_value.i = new_value
                @test obj.struct_value.i == new_value

                @test_throws field_exception_t obj_ptr.foo = 1
            end
        end
    end
end
