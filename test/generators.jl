using Clang
using Clang.Generators
using Clang.LibClang.Clang_jll
using Test
using Clang.Generators: StructDefinition, StructMutualRef, strip_comment_markers

include("rewriter.jl")

@testset "Generators" begin
    INCLUDE_DIR = normpath(Clang_jll.artifact_dir, "include")
    CLANG_C_DIR = joinpath(INCLUDE_DIR, "clang-c")

    options = load_options(joinpath(@__DIR__, "test.toml"))

    # add compiler flags
    args = get_default_args()
    push!(args, "-I$INCLUDE_DIR")

    # search top-level headers
    headers = detect_headers(CLANG_C_DIR, args)

    # add extra definition
    @add_def time_t AbstractJuliaSIT JuliaCtime_t Ctime_t

    # create context
    ctx = create_context(headers, args, options)

    # build without printing so we can do custom rewriting
    build!(ctx, BUILDSTAGE_NO_PRINTING)

    rewrite!(ctx.dag)

    # print
    @test_logs (:info, "Done!") match_mode=:any build!(ctx, BUILDSTAGE_PRINTING_ONLY)
end

@testset "Comments" begin
    @test strip_comment_markers("/* abc */") == ["abc "]
    @test strip_comment_markers("/** abc */") == ["abc "]
    @test strip_comment_markers("/*< abc */") == ["abc "]
    @test strip_comment_markers("/// hello") == ["hello"]
    @test strip_comment_markers("/**\n * line1\n * line2\n */") == ["line1", "line2"]
    @test strip_comment_markers("/*!\n * line1\n * line2\n */") == ["line1", "line2"]
    @test strip_comment_markers("    /// line1\n    /// line2") == ["line1", "line2"]
    @test strip_comment_markers("//! line1\n//! line2") == ["line1", "line2"]
    @test strip_comment_markers("//! line1") == ["line1"]
    @test strip_comment_markers("//< line1") == ["line1"]
end

@testset "Resolve dependency" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "dependency.h")
    options = Dict("general" => Dict{String,Any}(
            "output_file_path" => joinpath(@__DIR__, "LibDependency.jl")))
    ctx = create_context(headers, args, options)
    build!(ctx)
    @test include("LibDependency.jl") isa Any
end

# See:
# - https://github.com/JuliaInterop/Clang.jl/discussions/440
# - https://github.com/JuliaInterop/Clang.jl/pull/441
@testset "Cycle detection" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "cycle-detection.h")
    ctx = create_context(headers, args)
    build!(ctx)

    # In this particular case there is only one cycle in B, so only B should be
    # a StructMutualRef.
    mutual_ref_nodes = [node for node in ctx.dag.nodes if node.type == StructMutualRef()]
    @test length(mutual_ref_nodes) == 1
    @test mutual_ref_nodes[1].id == :B
end

# Check the Base.unsafe_convert() specializations that are generated by emit!()
# for TypedefMutualRef's. These use the original struct in their signatures to
# avoid method ambiguities with Base, so they must be emitted after the struct.
@testset "TypedefMutualRef method ambiguity" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "method-ambiguity.h")
    ctx = create_context(headers, args)
    build!(ctx)

    # Find the StructDefinition node
    struct_idx = findfirst(x -> x.id == :foo_struct && x.type isa StructDefinition,
                           ctx.dag.nodes)
    node = ctx.dag.nodes[struct_idx]

    # There should be three expressions, one for the struct and the other two
    # for the Base.unsafe_convert() specializations.
    @test length(node.exprs) == 3
    # The first expression should be the for the struct
    @test node.exprs[1].head == :struct
    # And the others should be functions (in compact form, hence the :(=) comparison)
    @test node.exprs[2].head == :(=)
    @test node.exprs[3].head == :(=)
end

@testset "Issue 320" begin
    args = get_default_args()
    dir = joinpath(@__DIR__, "sys")
    push!(args, "-isystem$dir")
    headers = [joinpath(@__DIR__, "include", "test.h")]
    ctx = create_context(headers, args)
    @add_def stat
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any
end

@testset "Escape anonymous name with var\"\"" begin
    args = get_default_args()
    headers = joinpath(@__DIR__, "include", "escape-with-var.h")
    options = Dict("general" => Dict{String,Any}(
            "output_file_path" => joinpath(@__DIR__, "LibEscapeWithVar.jl")))
    ctx = create_context(headers, args, options)
    build!(ctx)
    @test include("LibEscapeWithVar.jl") isa Any
end

@testset "Issue 307" begin
    args = get_default_args()
    dir = joinpath(@__DIR__, "sys")
    push!(args, "-isystem$dir")
    headers = joinpath(@__DIR__, "include", "struct-in-union.h")
    ctx = create_context(headers, args)
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any

    headers = joinpath(@__DIR__, "include", "nested-struct.h")
    ctx = create_context(headers, args)
    @test build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any

    headers = joinpath(@__DIR__, "include", "nested-declaration.h")
    ctx = create_context(headers, args)
    @test_broken try
        build!(ctx, BUILDSTAGE_NO_PRINTING) isa Any
        true
    catch
        false
    end
end

@testset "Issue 327" begin
    tu = parse_header(Index(), joinpath(@__DIR__, "include/void-type.h"))
    root = Clang.getTranslationUnitCursor(tu)
    func = children(root)[]
    ret_type = Clang.getCursorResultType(func)
    @test ret_type isa CLVoid
end

@testset "Issue 355" begin
    tu = parse_header(Index(), joinpath(@__DIR__, "include/return-funcptr.h"))
    root = Clang.getTranslationUnitCursor(tu)
    func = children(root)[3]
    @test length(get_function_args(func)) == 1
end

@testset "macros" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro.h"), get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "#368" begin
    ctx = create_context(joinpath(@__DIR__, "include/union-in-struct.h"),
                         get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
    @test ctx.dag.nodes[end].id == :A
    @test ctx.dag.nodes[end].type isa Generators.StructLayout
end

@testset "Issue 376" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro-dependency.h"), get_default_args())
    @test build!(ctx) isa Any
end

@testset "Issue 233" begin
    ctx = create_context(joinpath(@__DIR__, "include/union-in-anon-struct.h"), get_default_args())
    @test build!(ctx) isa Any
end

@testset "Issue 389" begin
    ctx = create_context(joinpath(@__DIR__, "include/macro.h"), get_default_args())
    build!(ctx)
    @test ctx.dag.nodes[ctx.dag.ids[:foo]].type isa AbstractFunctionNodeType
end

@testset "Issue 392" begin
    ctx = create_context([joinpath(@__DIR__, "include/a.h"),
                          joinpath(@__DIR__, "include/dup_a.h")], get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 412" begin
    ctx = create_context([joinpath(@__DIR__, "include/enum.h")], get_default_args())
    @test_throws Exception build!(ctx)
end

@testset "Issue 412 - no audit" begin
    options = Dict("general" => Dict{String,Any}("no_audit" => true))
    ctx = create_context([joinpath(@__DIR__, "include/enum.h")], get_default_args(), options)
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 452 - StructMutualRef" begin
    ctx = create_context([joinpath(@__DIR__, "include/struct-mutual-ref.h")], get_default_args())
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

@testset "Issue 455 - skip static functions" begin
    options = Dict("general" => Dict{String,Any}("skip_static_functions" => true))
    ctx = create_context([joinpath(@__DIR__, "include/static.h")], get_default_args(), options)
    @test_logs (:info, "Done!") match_mode = :any build!(ctx)
end

# Test the documentation parser
@testset "Documentation" begin
    function doc_callback(node::ExprNode, doc::Vector{String})
        return vcat(doc, "callback")
    end

    mktemp() do path, io
        # Generate the bindings
        options = Dict("general" => Dict{String, Any}("output_file_path" => path,
                                                      "extract_c_comment_style" => "doxygen",
                                                      "callback_documentation" => doc_callback))
        ctx = create_context([joinpath(@__DIR__, "include/documentation.h")], get_default_args(), options)
        build!(ctx)

        # Load into a temporary module to avoid polluting the global namespace
        m = Module()
        Base.include(m, path)

        # Do some sanity checks on the docstring
        docstring = string(@doc m.doxygen_func)
        docstring_has = occursin(docstring)
        @test docstring_has("!!! compat \"Deprecated\"")
        @test docstring_has("### Parameters")
        @test docstring_has(" * `foo`: A parameter")
        @test docstring_has("### Returns")
        @test docstring_has("Whatever I want")
        @test docstring_has("!!! danger \"Known bug\"")
        @test docstring_has("### See also")
        @test docstring_has("quux()")
        @test docstring_has("callback")
    end
end
