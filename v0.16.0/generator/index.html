<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generator Tutorial · Clang.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaInterop.github.io/Clang.jl/generator/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Clang.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Generator Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Tutorial-on-wrapping-a-JLL-package"><span>Tutorial on wrapping a JLL package</span></a></li><li><a class="tocitem" href="#Variadic-Function"><span>Variadic Function</span></a></li></ul></li><li><a class="tocitem" href="../tutorial/">LibClang Tutorial</a></li><li><a class="tocitem" href="../libclang/">LibClang Wrapper API Reference</a></li><li><a class="tocitem" href="../api/">Clang API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Generator Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generator Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaInterop/Clang.jl/blob/master/docs/src/generator.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Generator-Tutorial"><a class="docs-heading-anchor" href="#Generator-Tutorial">Generator Tutorial</a><a id="Generator-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Tutorial" title="Permalink"></a></h1><h2 id="Tutorial-on-wrapping-a-JLL-package"><a class="docs-heading-anchor" href="#Tutorial-on-wrapping-a-JLL-package">Tutorial on wrapping a JLL package</a><a id="Tutorial-on-wrapping-a-JLL-package-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-on-wrapping-a-JLL-package" title="Permalink"></a></h2><p>In most situations, Clang.jl is used to export a Julia interface to a C library managed by a JLL package. A JLL package wraps an artifact which provides a shared library that can be called with the <code>ccall</code> syntax and headers suitable for a C compiler. Clang.jl can translate the C headers into Julia files that can be directly used like normal Julia functions and types.</p><p>The general workflow of wrapping a JLL package is as follows.</p><ol><li>Locate the C headers relative to the artifact directory.</li><li>Find the compiler flags needed to parse these headers.</li><li>Create a <code>.toml</code> file with generator options.</li><li>Build a context with the above three and run.</li><li>Test and troubleshoot the wrapper.</li></ol><h3 id="Create-a-default-generator"><a class="docs-heading-anchor" href="#Create-a-default-generator">Create a default generator</a><a id="Create-a-default-generator-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-default-generator" title="Permalink"></a></h3><p>A generator context consists of a list of headers, a list of compiler flags, and generator options. The example below creates a typical context and runs the generator.</p><pre><code class="language-julia hljs">using Clang.Generators
using Clang.LibClang.Clang_jll

cd(@__DIR__)

include_dir = normpath(Clang_jll.artifact_dir, &quot;include&quot;)

# wrapper generator options
options = load_options(joinpath(@__DIR__, &quot;generator.toml&quot;))

# add compiler flags, e.g. &quot;-DXXXXXXXXX&quot;
args = get_default_args()
push!(args, &quot;-I$include_dir&quot;)

# only wrap libclang headers in include/clang-c
header_dir = joinpath(include_dir, &quot;clang-c&quot;)
headers = [joinpath(header_dir, header) for header in readdir(header_dir) if endswith(header, &quot;.h&quot;)]

# create context
ctx = create_context(headers, args, options)

# run generator
build!(ctx)</code></pre><p>You can also use the experimental <code>detect_headers</code> function to automatically detect top-level headers in the directory.</p><pre><code class="language-julia hljs">headers = detect_headers(header_dir, args)</code></pre><p>You also need an options file <code>generator.toml</code> that to make this script work, you can refer to <a href="https://github.com/JuliaInterop/Clang.jl/blob/master/gen/generator.toml">this toml file</a> for a reference.</p><h3 id="Skipping-specific-symbols"><a class="docs-heading-anchor" href="#Skipping-specific-symbols">Skipping specific symbols</a><a id="Skipping-specific-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Skipping-specific-symbols" title="Permalink"></a></h3><p>The C header may contain some symbols that are not correctly handled by Clang.jl or may need manual wrapping. For example, julia provides <code>tm</code> as <code>Libc.TmStruct</code>, so you may not want to map it to a new struct. As a workaround, you can skip these symbols. After that, if this symbol is needed, you can add it back in the prologue. Prologue is specified by the <code>prologue_file_path</code> option.</p><ul><li>Add the symbol to <code>output_ignorelist</code> to avoid it from being wrapped.</li><li>If the symbol is in system headers and causes Clang.jl to error before printing, apart from posting an issue, write <code>@add_def symbol_name</code> before generating to suppress it from being wrapped.</li></ul><h3 id="Rewrite-expressions-before-printing"><a class="docs-heading-anchor" href="#Rewrite-expressions-before-printing">Rewrite expressions before printing</a><a id="Rewrite-expressions-before-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Rewrite-expressions-before-printing" title="Permalink"></a></h3><p>You can also modify the generated wrapped before it is printed. Clang.jl separates the building process into generating and printing processes. You can run these two processes separately and rewrite the expressions before printing.</p><pre><code class="language-julia hljs"># build without printing so we can do custom rewriting
build!(ctx, BUILDSTAGE_NO_PRINTING)

# custom rewriter
function rewrite!(e::Expr)
end

function rewrite!(dag::ExprDAG)
    for node in get_nodes(dag)
        for expr in get_exprs(node)
            rewrite!(expr)
        end
    end
end

rewrite!(ctx.dag)

# print
build!(ctx, BUILDSTAGE_PRINTING_ONLY)</code></pre><h3 id="Multi-platform-configuration"><a class="docs-heading-anchor" href="#Multi-platform-configuration">Multi-platform configuration</a><a id="Multi-platform-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-platform-configuration" title="Permalink"></a></h3><p>Some headers may contain system-dependent symbols such as <code>long</code> or <code>char</code>, or system-independent symbols may be resolved to system-dependent ones. For example, <code>time_t</code> is usually just a 64-bit unsigned integer, but implementations may conditionally implement it as <code>long</code> or <code>long long</code>, which is not portable. You can skip these symbols and add them back manually as in <a href="#Skipping-specific-symbols">Skipping specific symbols</a>. If the differences are too large to be manually fixed, you can generate wrappers for each platform as in <a href="https://github.com/Gnimuc/LibClang.jl/blob/v0.61.0/gen/generator.jl">LibClang.jl</a>.</p><h2 id="Variadic-Function"><a class="docs-heading-anchor" href="#Variadic-Function">Variadic Function</a><a id="Variadic-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Variadic-Function" title="Permalink"></a></h2><p>With the help of <code>@ccall</code> macro, variadic C functions can be called from Julia. For example, <code>@ccall printf(&quot;%d\n&quot;::Cstring; 123::Cint)::Cint</code> can be used to call the C function <code>printf</code>. Note that those arguments after the semicolon <code>;</code> are variadic arguments.</p><p>If <code>wrap_variadic_function</code> in <code>codegen</code> section of options is set to <code>true</code>, <code>Clang.jl</code> will generate wrappers for variadic C functions. For example, <code>printf</code> will be wrapped as follows.</p><pre><code class="language-julia hljs">@generated function printf(fmt, va_list...)
        :(@ccall(libexample.printf(fmt::Ptr{Cchar}; $(to_c_type_pairs(va_list)...))::Cint))
    end</code></pre><p>It can be called just like normal Julia functions without specifying types: <code>LibExample.printf(&quot;%d\n&quot;, 123)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Although variadic functions are supported, the C type <code>va_list</code> cannot be used from Julia.</p></div></div><h3 id="Type-Correspondence"><a class="docs-heading-anchor" href="#Type-Correspondence">Type Correspondence</a><a id="Type-Correspondence-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Correspondence" title="Permalink"></a></h3><p>However, variadic C functions must be called with the correct argument types. The most useful ones are listed below.</p><table><tr><th style="text-align: right">C type</th><th style="text-align: right">ccall signature</th><th style="text-align: right">Julia type</th></tr><tr><td style="text-align: right">Integers and floating point numbers</td><td style="text-align: right">the same type</td><td style="text-align: right">the same type</td></tr><tr><td style="text-align: right">Struct <code>T</code></td><td style="text-align: right">a concrete Julia struct <code>T</code> with the same layout</td><td style="text-align: right"><code>T</code></td></tr><tr><td style="text-align: right">Pointer (<code>T*</code>)</td><td style="text-align: right"><code>Ref{T}</code> or <code>Ptr{T}</code></td><td style="text-align: right"><code>Ref{T}</code> or <code>Ptr{T}</code> or any array type</td></tr><tr><td style="text-align: right">String (<code>char*</code>)</td><td style="text-align: right"><code>Cstring</code> or <code>Ptr{Cchar}</code></td><td style="text-align: right"><code>String</code></td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Ref</code> is not a concrete type but an abstract type in Julia. For example, <code>Ref(1)</code> is <code>Base.RefValue(1)</code>, which cannot be directly passed to C.</p></div></div><p>As observed from the table, if you want to pass strings or arrays to C, you need to annotate the type as <code>Ptr{T}</code> or <code>Ref{T}</code> (or <code>Cstring</code>). Otherwise, the struct that represents the <code>String</code> or <code>Array</code> type instead of the buffer itself will be passed. There are two methods to pass arguments of these types:</p><ul><li>Directly use the @ccall macro: <code>@ccall printf(&quot;%s\n&quot;; &quot;hello&quot;::Cstring)::Cint</code>. You can also create wrappers for common use cases of this.</li><li>Overload <code>to_c_type</code> to map Julia type to correct ccall signature type: add <code>to_c_type(::Type{String}) = Cstring</code> to prologue (prologue can be added by setting <code>prologue_file_path</code> in options). Then all arguments of type <code>String</code> will be annotated as <code>Cstring</code>.</li></ul><p>The above type correspondence can be implemented by including the following lines in the prologue.</p><pre><code class="language-julia hljs">to_c_type(::Type{&lt;:AbstractString}) = Cstring # or Ptr{Cchar}
to_c_type(t::Type{&lt;:Union{AbstractArray,Ref}}) = Ptr{eltype(t)}</code></pre><p>For a complete tutorial on calling C functions, refer to <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Calling-C-and-Fortran-Code">Calling C and Fortran Code</a> in the Julia manual.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../tutorial/">LibClang Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 20 August 2022 15:24">Saturday 20 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
