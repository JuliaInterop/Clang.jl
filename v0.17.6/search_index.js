var documenterSearchIndex = {"docs":
[{"location":"api/#Clang-API-Reference","page":"Clang API Reference","title":"Clang API Reference","text":"","category":"section"},{"location":"api/","page":"Clang API Reference","title":"Clang API Reference","text":"Modules = [Clang]\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"api/#Clang._cxstring_to_string-Tuple{CXString}","page":"Clang API Reference","title":"Clang._cxstring_to_string","text":"Free and convert a CXString to String. Note this function will free the given CXString so ensure it is not called twice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.annotateTokens-Tuple{Union{Ptr{CXTranslationUnitImpl}, TranslationUnit}, Any, Any, Any}","page":"Clang API Reference","title":"Clang.annotateTokens","text":"annotateTokens(tu::TranslationUnit, tokens, token_num, cursors)\n\nAnnotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.children-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.children","text":"children(cursor::CXCursor) -> Vector{CXCursor}\nchildren(cursor::CLCursor) -> Vector{CLCursor}\n\nReturn immediate cursors of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.fields-Tuple{CXType}","page":"Clang API Reference","title":"Clang.fields","text":"fields(ty::CXType) -> Vector{CXCursor}\nfields(ty::CLType) -> Vector{CLCursor}\n\nReturn a child cursor vector of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAddressSpace-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.getAddressSpace","text":"getAddressSpace(t::Union{CXType,CLType})\n\nReturns the address space of the given type. Wrapper for libclang's clang_getAddressSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAlignOf-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getAlignOf","text":"getAlignOf(t::CXType) -> Int\ngetAlignOf(t::CLType) -> Int\n\nReturn the alignment of a type in bytes as per C++[expr.alignof] standard.\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArgType-Tuple{CXType, Unsigned}","page":"Clang API Reference","title":"Clang.getArgType","text":"getArgType(t::CXType, i::Unsigned) -> CXType\ngetArgType(t::Union{CLFunctionNoProto,CLFunctionProto}, i::Integer) -> CLType\n\nReturn the type of a parameter of a function type. Wrapper for libclang's clang_getArgType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArgument-Tuple{CXCursor, Integer}","page":"Clang API Reference","title":"Clang.getArgument","text":"getArgument(c::CXCursor, i::Integer) -> CXCursor\ngetArgument(c::Union{CLFunctionDecl,CLCXXMethod,CLConstructor,CLFunctionTemplate}, i::Integer) -> CLCursor\n\nReturn the argument cursor of a function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getArguments-Tuple{Union{Clang.BlockCommand, Clang.InlineCommand}}","page":"Clang API Reference","title":"Clang.getArguments","text":"getArguments(c::Union{BlockCommand, InlineCommand}) -> Vector{String}\n\nReturn the arguments of a command.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsHTML-Tuple{Union{Clang.FullComment, CXComment}}","page":"Clang API Reference","title":"Clang.getAsHTML","text":"getAsHTML(c::Union{CXComment, FullComment})\n\nConvert a comment into an HTML fragment. Check libclang's documentation for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsString-Tuple{Union{Clang.HTMLEndTag, Clang.HTMLStartTag, CXComment}}","page":"Clang API Reference","title":"Clang.getAsString","text":"getAsString(c::Union{CXComment, HTMLStartTag, HTMLEndTag})\n\nConvert an HTML tag to its string representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAsXML-Tuple{Union{Clang.FullComment, CXComment}}","page":"Clang API Reference","title":"Clang.getAsXML","text":"getAsXML(c::Union{CXComment, FullComment})\n\nConvert a comment into an XML document.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getAttributes-Tuple{Union{Clang.HTMLStartTag, CXComment}}","page":"Clang API Reference","title":"Clang.getAttributes","text":"getAttributes(c::Union{CXComment, HTMLStartTag}) -> Vector{Pair{String, String}}\n\nReturn the attributes of an HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCanonicalCursor-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCanonicalCursor","text":"getCanonicalCursor(c::CXCursor) -> CXCursor\ngetCanonicalCursor(c::CLCursor) -> CLCursor\n\nReturn the getCanonicalCursor cursor corresponding to the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCanonicalType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getCanonicalType","text":"getCanonicalType(t::CXType) -> CXType\ngetCanonicalType(t::CLType) -> CLType\n\nReturn the canonical type for a CXType.\n\nClang's type system explicitly models typedefs and all the ways a specific type can be represented. The canonical type is the underlying type with all the \"sugar\" removed. For example, if 'T' is a typedef for 'int', the canonical type for 'T' would be 'int'. Wrapper for libclang's clang_getCanonicalType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCommandName-Tuple{Clang.InlineCommand}","page":"Clang API Reference","title":"Clang.getCommandName","text":"getCommandName(c::InlineCommand) -> String\ngetCommandName(c::BlockCommand) -> String\n\nReturn the command name of a command, e.g. \"brief\" for \\brief blah.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCompileCommands-Tuple{CLCompilationDatabase, AbstractString}","page":"Clang API Reference","title":"Clang.getCompileCommands","text":"getCompileCommands(db::CLCompilationDatabase, file::AbstractString)\n\nGet all compile commands for a file given its complete path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCompileCommands-Tuple{CLCompilationDatabase}","page":"Clang API Reference","title":"Clang.getCompileCommands","text":"getCompileCommands(db::CLCompilationDatabase)\n\nGet all compile commands from a compilation database.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorDefinition-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorDefinition","text":"getCursorDefinition(c::CXCursor) -> CXCursor\ngetCursorDefinition(c::CLCursor) -> CLCursor\n\nFor a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorExtent-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getCursorExtent","text":"getCursorExtent(c::Union{CXCursor,CLCursor}) -> CXSourceRange\n\nReturn the physical extent of the source construct referenced by the given cursor.\n\nThe extent of a cursor starts with the file/line/column pointing at the first character within the source construct that the cursor refers to and ends with the last character within that source construct. For a declaration, the extent covers the declaration itself. For a reference, the extent covers the location of the reference (e.g., where the referenced entity was actually used).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLanguage-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getCursorLanguage","text":"getCursorLanguage(c::Union{CXCursor,CLCursor}) -> CXLanguageKind\n\nReturn the language of the entity referred to by a given cursor. Return CXLanguage_Invalid if the input cursor is not a decl. Note that, this function has limitations, for example, it cannot distinguish C++ structs from C structs, in both cases, it returns CXLanguage_C.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLexicalParent-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorLexicalParent","text":"getCursorLexicalParent(c::CXCursor) -> CXCursor\ngetCursorLexicalParent(c::CLCursor) -> CLCursor\n\nReturn the lexical parent of the given cursor. Please checkout libclang's doc to know more.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLinkage-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getCursorLinkage","text":"getCursorLinkage(c::Union{CXCursor,CLCursor}) -> CXLinkageKind\n\nReturn the linkage of the entity referred to by a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorLocation-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getCursorLocation","text":"getCursorLocation(c::Union{CXCursor,CLCursor}) -> CXSourceLocation\n\nReturn the physical location of the source constructor referenced by the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorReferenced-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorReferenced","text":"getCursorReferenced(c::CXCursor) -> CXCursor\ngetCursorReferenced(c::CLCursor) -> CLCursor\n\nFor a cursor that is a reference, retrieve a cursor representing the entity that it references.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorResultType-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorResultType","text":"getCursorResultType(c::CXCursor) -> CXType\ngetCursorResultType(c::Union{CLFunctionDecl,CLCXXMethod}) -> CLType\n\nReturn the return type associated with a given cursor. This only returns a valid type if the cursor refers to a function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorResultType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getCursorResultType","text":"getCursorResultType(t::CXType) -> CXType\ngetCursorResultType(t::Union{CLFunctionNoProto,CLFunctionProto}) -> CLType\n\nReturn the return type associated with a function type. Wrapper for libclang's clang_getResultType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorSemanticParent-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorSemanticParent","text":"getCursorSemanticParent(c::CXCursor) -> CXCursor\ngetCursorSemanticParent(c::CLCursor) -> CLCursor\n\nReturn the semantic parent of the given cursor. Please checkout libclang's doc to know more.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getCursorType-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getCursorType","text":"getCursorType(c::CXCursor) -> CXType\ngetCursorType(c::CLCursor) -> CLType\n\nReturn the type of a CXCursor (if any). To get the cursor from a type, see getTypeDeclaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getDirection-Tuple{Union{Clang.ParamCommand, CXComment}}","page":"Clang API Reference","title":"Clang.getDirection","text":"getDirection(c::Union{CXComment, ParamCommand})\n\nReturn the parameter passing direction ([in], [out], [in,out]) or missing if the direction is not specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getElementType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getElementType","text":"getElementType(t::CXType) -> CXType\ngetElementType(t::Union{CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray,CLComplex}) -> CLType\n\nReturn the element type of an array, complex, or vector type. Wrapper for libclang's clang_getElementType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getEnumDeclIntegerType-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getEnumDeclIntegerType","text":"getEnumDeclIntegerType(c::CLEnumDecl) -> CLType\n\nRetrieve the integer type of an enum declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getFieldDeclBitWidth-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getFieldDeclBitWidth","text":"getFieldDeclBitWidth(c::CLFieldDecl) -> Int\n\nReturn the bit width of a bit field declaration as an integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getFunctionTypeCallingConv-Tuple{Union{CLFunctionNoProto, CLFunctionProto, CXType}}","page":"Clang API Reference","title":"Clang.getFunctionTypeCallingConv","text":"getFunctionTypeCallingConv(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -> CXCallingConv\n\nReturn the calling convention associated with a function type. Wrapper for libclang's clang_getFunctionTypeCallingConv.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getIncludedFile-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getIncludedFile","text":"getIncludedFile(c::Union{CXCursor,CLCursor}) -> CXFile\n\nReturn the file that is included by the given inclusion directive cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getIndex-Tuple{Union{Clang.ParamCommand, CXComment}}","page":"Clang API Reference","title":"Clang.getIndex","text":"getIndex(c::Union{CXComment, ParamCommand})\n\nReturn zero-based parameter index in function prototype or missing if the parameter is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNamedType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getNamedType","text":"getNamedType(t::CXType) -> CXType\ngetNamedType(t::CLElaborated) -> CLType\n\nReturn the type named by the qualified-id. Wrapper for libclang's clang_Type_getNamedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNullCursor-Tuple{}","page":"Clang API Reference","title":"Clang.getNullCursor","text":"getNullCursor() -> CXCursor\n\nReturn the \"NULL\" CXCursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumArguments-Tuple{Union{CLFunctionNoProto, CLFunctionProto, CLUnexposed, CXType}}","page":"Clang API Reference","title":"Clang.getNumArguments","text":"getNumArguments(t::Union{CXType,CLFunctionNoProto,CLFunctionProto}) -> Int\n\nReturn the number of non-variadic parameters associated with a function type. Wrapper for libclang's clang_getNumArgTypes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumArguments-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getNumArguments","text":"getNumArguments(c::Union{CXCursor,CLCursor}) -> Int\n\nReturn the number of non-variadic arguments associated with a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getNumElements-Tuple{Union{CLConstantArray, CLDependentSizedArray, CLIncompleteArray, CLVariableArray, CLVector, CXType}}","page":"Clang API Reference","title":"Clang.getNumElements","text":"getNumElements(t::Union{CXType,CLVector,CLConstantArray,CLIncompleteArray,CLVariableArray,CLDependentSizedArray}) -> Int\n\nReturn the number of elements of an array or vector type. Wrapper for libclang's clang_getNumElements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getOffsetOf-Tuple{CXType, Any}","page":"Clang API Reference","title":"Clang.getOffsetOf","text":"getOffsetOf(t::CXType, s) -> Int\ngetOffsetOf(t::CLType, s::AbstractString) -> Int\n\nReturn the offset of a field named S in a record of type T in bits as it would be returned by offsetof as per C++11[18.2p4].\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getOffsetOfField-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getOffsetOfField","text":"getOffsetOfField(c::Union{CXCursor,CLCursor}) -> Int\n\nReturn the offset of the field represented by the cursor in bits as it would be returned by offsetof as per C++11[18.2p4]. It returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParagraph-Tuple{CXComment}","page":"Clang API Reference","title":"Clang.getParagraph","text":"getParagraph(c::CXComment)\ngetParagraph(c::BlockCommand)\n\nReturn the paragraph argument of a given command.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParamName-Tuple{Clang.ParamCommand}","page":"Clang API Reference","title":"Clang.getParamName","text":"getParamName(c::ParamCommand) -> String\n\nReturn the name of a parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getParsedComment-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getParsedComment","text":"getParsedComment(c::CXCursor) -> CXComment\ngetParsedComment(c::CLCursor) -> CLComment\n\nReturn the parsed AST of doxygen comment associated with the given node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getPointeeType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getPointeeType","text":"getPointeeType(t::CXType) -> CXType\ngetPointeeType(t::CLType) -> CLType\n\nReturn the type of the pointee for pointer types. Wrapper for libclang's clang_getPointeeType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getRenderKind-Tuple{Union{Clang.InlineCommand, CXComment}}","page":"Clang API Reference","title":"Clang.getRenderKind","text":"getRenderKind(c::Union{CXComment, InlineCommand}) -> CXCommentInlineCommandRenderKind\n\nReturn the most appropriate rendering mode, chosen on command semantics in Doxygen.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getSizeOf-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getSizeOf","text":"getSizeOf(t::CXType) -> Int\ngetSizeOf(t::CLType) -> Int\n\nReturn the size of a type in bytes as per C++[expr.sizeof] standard,\n\nIt returns a minus number for layout errors, please convert the result to a CXTypeLayoutError to see what the error is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getSourceCode-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getSourceCode","text":"getSourceCode(cursor::Union{CXCursor, CLCursor}) -> String\n\nGet source code for the cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTagName-Tuple{Union{Clang.HTMLEndTag, Clang.HTMLStartTag, CXComment}}","page":"Clang API Reference","title":"Clang.getTagName","text":"getTagName(c::Union{CXComment, HTMLStartTag, HTMLEndTag})\n\nReturn the tag name of a HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getText-Tuple{Clang.Text}","page":"Clang API Reference","title":"Clang.getText","text":"getText(c::Text) -> String\ngetText(c::VerbatimBlockLine) -> String\ngetText(c::VerbatimLine) -> String\n\nGet the text content assiciated with the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTokenExtent-Tuple{Union{Ptr{CXTranslationUnitImpl}, TranslationUnit}, Union{CXToken, CLToken}}","page":"Clang API Reference","title":"Clang.getTokenExtent","text":"getTokenExtent(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -> CXSourceRange\n\nReturn a source range that covers the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTokenLocation-Tuple{Union{Ptr{CXTranslationUnitImpl}, TranslationUnit}, Union{CXToken, CLToken}}","page":"Clang API Reference","title":"Clang.getTokenLocation","text":"getTokenLocation(tu::Union{CXTranslationUnit,TranslationUnit}, t::Union{CXToken,CLToken}) -> CXSourceLocation\n\nReturn the source location of the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTranslationUnit-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.getTranslationUnit","text":"getTranslationUnit(c::Union{CXCursor,CLCursor}) -> CXTranslationUnit\n\nReturns the translation unit that a cursor originated from.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTranslationUnitCursor-Tuple{Ptr{CXTranslationUnitImpl}}","page":"Clang API Reference","title":"Clang.getTranslationUnitCursor","text":"getTranslationUnitCursor(tu::TranslationUnit) -> CLCursor\ngetTranslationUnitCursor(tu::CXTranslationUnit) -> CXCursor\n\nReturn the cursor that represents the given translation unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypeDeclaration-Tuple{CXType}","page":"Clang API Reference","title":"Clang.getTypeDeclaration","text":"getTypeDeclaration(t::CXType) -> CXCursor\ngetTypeDeclaration(t::CLType) -> CLCursor\n\nReturn the cursor for the declaration of the given type. To get the type of the cursor, see type. Wrapper for libclang's clang_getTypeDeclaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypedefDeclUnderlyingType-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.getTypedefDeclUnderlyingType","text":"getTypedefDeclUnderlyingType(c::CLTypedefDecl) -> CLType\n\nReturn the underlying type of a typedef declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.getTypedefName-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.getTypedefName","text":"getTypedefName(t::Union{CXType,CLType}) -> String\n\nReturn the typedef name of the given type. Wrapper for libclang's clang_getTypedefName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_elaborated_cursor-Tuple{CXType}","page":"Clang API Reference","title":"Clang.get_elaborated_cursor","text":"get_elaborated_cursor(ty::CLType) -> CLCursor\nget_elaborated_cursor(ty::CXType) -> CXCursor\n\nReturn the cursor of the elaborated type that is referenced by the input type. The input type can be a pointer/array. This function returns clang_getNullCursor if the input type is not refer to an elaborated type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_file_line_column-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.get_file_line_column","text":"get_file_line_column(c::Union{CXCursor,CLCursor}) -> (String, Int, Int)\n\nReturn file name, line and column number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_filename-Tuple{Ptr{Nothing}}","page":"Clang API Reference","title":"Clang.get_filename","text":"get_filename(x::CXFile) -> String\n\nReturn the complete file and path name of the given file\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_filename-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.get_filename","text":"get_filename(c::Union{CXCursor,CLCursor}) -> String\n\nReturn the complete file and path name of the given file referenced by the input cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.get_function_args-Tuple{CLCursor}","page":"Clang API Reference","title":"Clang.get_function_args","text":"get_function_args(cursor::CLCursor) -> Vector{CLCursor}\n\nReturn function arguments for a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.hasAttrs-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.hasAttrs","text":"hasAttrs(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether the given cursor has any attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.has_elaborated_reference-Tuple{CXType}","page":"Clang API Reference","title":"Clang.has_elaborated_reference","text":"has_elaborated_reference(ty::CLType) -> Bool\nhas_elaborated_reference(ty::CXType) -> Bool\n\nReturn true if the type is an elaborated type or the type indirectly refers to an elaborated type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.has_function_reference-Tuple{CXType}","page":"Clang API Reference","title":"Clang.has_function_reference","text":"has_function_reference(ty::CLType) -> Bool\nhas_function_reference(ty::CXType) -> Bool\n\nReturn true if the type is a function or the type indirectly refers to a function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isAnonymous-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isAnonymous","text":"isAnonymous(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the given cursor represents an anonymous record declaration(C++).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isAttribute-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isAttribute","text":"isAttribute(k::CXcursorKind) -> Bool\nisAttribute(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isBitField-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isBitField","text":"isBitField(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the cursor specifies a Record member that is a bitfield.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isConstQualifiedType-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.isConstQualifiedType","text":"isConstQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"const\" qualifier set, without looking through typedefs that may have added \"const\" at a different level. Wrapper for libclang's clang_isConstQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isCursorDefinition-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isCursorDefinition","text":"isCursorDefinition(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the declaration pointed to by this cursor is also a definition of that entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isDeclaration-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isDeclaration","text":"isDeclaration(k::CXcursorKind) -> Bool\nisDeclaration(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isExpression-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isExpression","text":"isExpression(k::CXcursorKind) -> Bool\nisExpression(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isFunctionInlined-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isFunctionInlined","text":"isFunctionInlined(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a CXCursor that is a function declaration, is an inline declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalid-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isInvalid","text":"isInvalid(k::CXcursorKind) -> Bool\nisInvalid(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents an valid cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalid-Tuple{CXType}","page":"Clang API Reference","title":"Clang.isInvalid","text":"isInvalid(t::CXType) -> Bool\nisInvalid(t::CLType) -> Bool\n\nReturn true if the type is a valid type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isInvalidDeclaration-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isInvalidDeclaration","text":"isInvalidDeclaration(x::CXcursorKind) -> Bool\n\nReturn true if the given declaration is invalid. A declaration is invalid if it could not be parsed successfully.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isMacroBuiltin-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isMacroBuiltin","text":"isMacroBuiltin(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a  CXCursor that is a macro, is a builtin one.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isMacroFunctionLike-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isMacroFunctionLike","text":"isMacroFunctionLike(c::Union{CXCursor,CLCursor}) -> Bool\n\nDetermine whether a CXCursor that is a macro, is function like.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isNull-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isNull","text":"isNull(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if cursor is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isPODType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.isPODType","text":"isPODType(t::Union{CXType,CLType}) -> Bool\n\nReturn true if the CXType is a plain old data type. Wrapper for libclang's clang_isPODType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isPreprocessing-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isPreprocessing","text":"isPreprocessing(k::CXcursorKind) -> Bool\nisPreprocessing(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a preprocessing element, such as a preprocessor directive or macro instantiation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isReference-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isReference","text":"isReference(k::CXcursorKind) -> Bool\nisReference(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a simple reference. Note that other kinds of cursors (such as expressions) can also refer to other cursors. Use getCursorReferenced to determine whether a particular cursor refers to another entity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isRestrictQualifiedType-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.isRestrictQualifiedType","text":"isRestrictQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"restrict\" qualifier set, without looking through typedefs that may have added \"restrict\" at a different level. Wrapper for libclang's clang_isRestrictQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isSelfClosing-Tuple{Union{Clang.HTMLStartTag, CXComment}}","page":"Clang API Reference","title":"Clang.isSelfClosing","text":"isSelfClosing(c::Union{CXComment, HTMLStartTag})\n\nReturn whether a tag is self-closing (for example, <br />).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isStatement-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isStatement","text":"isStatement(k::CXcursorKind) -> Bool\nisStatement(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a statement.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isTranslationUnit-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isTranslationUnit","text":"isTranslationUnit(k::CXcursorKind) -> Bool\nisTranslationUnit(c::CLCursor) -> Bool\n\nReturn true if the given cursor kind represents a translation unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isUnexposed-Tuple{CXCursorKind}","page":"Clang API Reference","title":"Clang.isUnexposed","text":"isUnexposed(k::CXcursorKind) -> Bool\n\nReturn true if the given cursor kind represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVariadic-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isVariadic","text":"isVariadic(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the given cursor is a variadic function or method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVariadic-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.isVariadic","text":"isVariadic(t::Union{CXType,CLType}) -> Bool\n\nReturn true if the CXType is a variadic function type. Wrapper for libclang's clang_isFunctionTypeVariadic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVirtualBase-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.isVirtualBase","text":"isVirtualBase(c::Union{CXCursor,CLCursor}) -> Bool\n\nReturn true if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isVolatileQualifiedType-Tuple{CXType}","page":"Clang API Reference","title":"Clang.isVolatileQualifiedType","text":"isVolatileQualifiedType(t::Union{CXType,CLType}) -> Bool\n\nDetermine whether a CXType has the \"volatile\" qualifier set, without looking through typedefs that may have added \"volatile\" at a different level. Wrapper for libclang's clang_isVolatileQualifiedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.isWhiteSpace-Tuple{Union{CXComment, Clang.CLComment}}","page":"Clang API Reference","title":"Clang.isWhiteSpace","text":"isWhiteSpace(c::Union{CXComment, CLComment}) -> Bool\n\nReturn whether a CXParagraph or CXText is contains only white space. Return false for other kinds of comment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_forward_declaration-Tuple{CLCursor}","page":"Clang API Reference","title":"Clang.is_forward_declaration","text":"is_forward_declaration(x::CLCursor) -> Bool\n\nReturn true if the cursor is a forward declaration. Reference: https://joshpeterson.github.io/identifying-a-forward-declaration-with-libclang\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_inclusion_directive-Tuple{CLCursor}","page":"Clang API Reference","title":"Clang.is_inclusion_directive","text":"is_inclusion_directive(x::CLCursor) -> Bool\n\nReturn true if the cursor is an inclusion directive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.is_typedef_anon-Tuple{CLCursor, CLCursor}","page":"Clang API Reference","title":"Clang.is_typedef_anon","text":"is_typedef_anon(current::CLCursor, next::CLCursor) -> Bool\n\nReturn true if the current cursor is a typedef anonymous struct/enum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CLCursor}","page":"Clang API Reference","title":"Clang.kind","text":"kind(c::CLCursor) -> CXCursorKind\n\nReturn the kind of the given cursor. Note this method directly reads CXCursor's kind field, which won't invoke additional clang_getCursorKind function calls.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CXComment}","page":"Clang API Reference","title":"Clang.kind","text":"kind(c::Union{CXComment, CXComment}) -> CXCommentKind\n\nReturn the kind of a comment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CXCursor}","page":"Clang API Reference","title":"Clang.kind","text":"kind(c::CXCursor) -> CXCursorKind\n\nReturn the kind of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CXToken}","page":"Clang API Reference","title":"Clang.kind","text":"kind(t::CXToken) -> CXTokenKind\nkind(t::CLToken) -> CXTokenKind\n\nReturn the kind of the given token.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.kind-Tuple{CXType}","page":"Clang API Reference","title":"Clang.kind","text":"kind(t::CXType) -> CXTypeKind\nkind(t::CLType) -> CXTypeKind\n\nReturn the kind of the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.name-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.name","text":"name(c::Union{CXCursor,CLCursor}) -> String\n\nReturn the display name for the entity referenced by this cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.parse_header","page":"Clang API Reference","title":"Clang.parse_header","text":"parse_header(\n    index::Index,\n    header::AbstractString,\n    args::Vector{String}=[],\n    flags=CXTranslationUnit_None,\n) -> TranslationUnit\n\nReturn the TranslationUnit for a given header. This is the main entry point for parsing.\n\nArguments\n\nheader::AbstractString: the header file to parse.\nindex::Index: CXIndex pointer (pass to avoid re-allocation).\nargs::Vector{String}: compiler switches as string array, eg: [\"-x\", \"c++\", \"-fno-elide-type\"].\nflags: bitwise OR of CXTranslationUnit_Flags.\n\nSee also parse_headers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clang.parse_headers","page":"Clang API Reference","title":"Clang.parse_headers","text":"parse_headers(\n    index::Index,\n    headers::Vector{String},\n    args::Vector{String}=[],\n    flags=CXTranslationUnit_None,\n) -> Vector{TranslationUnit}\n\nReturn a TranslationUnit vector for the given headers.\n\nSee also parse_header.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clang.remove_ranges-Tuple{Any}","page":"Clang API Reference","title":"Clang.remove_ranges","text":"Remove FirstXX and LastXX from enumerations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.search-Union{Tuple{T}, Tuple{Vector{T}, Function}} where T<:CLCursor","page":"Clang API Reference","title":"Clang.search","text":"search(cursors::Vector{CLCursor}, ismatch::Function) -> Vector{CLCursor}\n\nReturn vector of CLCursors that match predicate. ismatch is a function that accepts a CLCursor argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{CXTypeKind}","page":"Clang API Reference","title":"Clang.spelling","text":"spelling(kind::CXTypeKind) -> String\n\nReturn the spelling of a given CXTypeKind.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Ptr{CXTranslationUnitImpl}, CXToken}","page":"Clang API Reference","title":"Clang.spelling","text":"spelling(tu::TranslationUnit, t::CLToken) -> String\nspelling(tu::TranslationUnit, t::CXToken) -> String\nspelling(tu::CXTranslationUnit, t::CXToken) -> String\n\nReturn the spelling of the given token. The spelling of a token is the textual representation of that token, e.g., the text of an identifier or keyword.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{TranslationUnit}","page":"Clang API Reference","title":"Clang.spelling","text":"spelling(tu::TranslationUnit) -> String\n\nReturn the original translation unit source file name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.spelling","text":"spelling(c::Union{CXCursor,CLCursor}) -> String\n\nReturn a name for the entity referenced by this cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.spelling-Tuple{Union{CXType, CLType}}","page":"Clang API Reference","title":"Clang.spelling","text":"spelling(t::Union{CXType,CLType}) -> String\n\nPretty-print the underlying type using the rules of the language of the translation unit from which it came. If the type is invalid, an empty string is returned. Wrapper for libclang's clang_getTypeSpelling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.tokenize-Tuple{Union{CXCursor, CLCursor}}","page":"Clang API Reference","title":"Clang.tokenize","text":"tokenize(c::Union{CXCursor,CLCursor}) -> TokenList\n\nReturn a TokenList from the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.value-Tuple{CLEnumConstantDecl}","page":"Clang API Reference","title":"Clang.value","text":"value(c::CLCursor) -> Integer\n\nReturn the integer value of an enum constant declaration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.CLCompilationDatabase-Tuple{AbstractString}","page":"Clang API Reference","title":"Clang.CLCompilationDatabase","text":"CLCompilationDatabase(path::AbstractString)\n\nCreates a compilation database from the database found in directory path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Clang.CLCompileCommand","page":"Clang API Reference","title":"Clang.CLCompileCommand","text":"CLCompileCommand\n\nRepresents a command to compile the specific file. Call getDirectory, getArguments and getArguments to get its attributes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Clang.Index","page":"Clang API Reference","title":"Clang.Index","text":"Index(exclude_decls_from_PCH, display_diagnostics)\n\nProvide a shared context for creating translation units.\n\nArguments\n\nexclude_decls_from_PCH: whether we only want to see \"local\" declarations (that did not come from a previous precompiled header). If false, we want to see all declarations.\ndisplay_diagnostics: whether to display diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Clang.TokenList","page":"Clang API Reference","title":"Clang.TokenList","text":"TokenList\n\nTokenizer accessor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Clang.TranslationUnit","page":"Clang API Reference","title":"Clang.TranslationUnit","text":"TranslationUnit(idx, source, args)\nTranslationUnit(idx, source, args, unsavedFiles, options)\n\nParse the given source file and the translation unit corresponding to that file.\n\n\n\n\n\n","category":"type"},{"location":"generator/#Generator-Tutorial","page":"Generator Tutorial","title":"Generator Tutorial","text":"","category":"section"},{"location":"generator/#Tutorial-on-wrapping-a-JLL-package","page":"Generator Tutorial","title":"Tutorial on wrapping a JLL package","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"In most situations, Clang.jl is used to export a Julia interface to a C library managed by a JLL package. A JLL package wraps an artifact which provides a shared library that can be called with the ccall syntax and headers suitable for a C compiler. Clang.jl can translate the C headers into Julia files that can be directly used like normal Julia functions and types.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"The general workflow of wrapping a JLL package is as follows.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"Locate the C headers relative to the artifact directory.\nFind the compiler flags needed to parse these headers.\nCreate a .toml file with generator options.\nBuild a context with the above three and run.\nTest and troubleshoot the wrapper.","category":"page"},{"location":"generator/#Create-a-default-generator","page":"Generator Tutorial","title":"Create a default generator","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"A generator context consists of a list of headers, a list of compiler flags, and generator options. The example below creates a typical context and runs the generator.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"using Clang.Generators\nusing Clang.LibClang.Clang_jll\n\ncd(@__DIR__)\n\ninclude_dir = normpath(Clang_jll.artifact_dir, \"include\")\n\n# wrapper generator options\noptions = load_options(joinpath(@__DIR__, \"generator.toml\"))\n\n# add compiler flags, e.g. \"-DXXXXXXXXX\"\nargs = get_default_args()\npush!(args, \"-I$include_dir\")\n\n# only wrap libclang headers in include/clang-c\nheader_dir = joinpath(include_dir, \"clang-c\")\nheaders = [joinpath(header_dir, header) for header in readdir(header_dir) if endswith(header, \".h\")]\n\n# create context\nctx = create_context(headers, args, options)\n\n# run generator\nbuild!(ctx)","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"You can also use the experimental detect_headers function to automatically detect top-level headers in the directory.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"headers = detect_headers(header_dir, args)","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"You also need an options file generator.toml that to make this script work, you can refer to this toml file for a reference.","category":"page"},{"location":"generator/#Skipping-specific-symbols","page":"Generator Tutorial","title":"Skipping specific symbols","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"The C header may contain some symbols that are not correctly handled by Clang.jl or may need manual wrapping. For example, julia provides tm as Libc.TmStruct, so you may not want to map it to a new struct. As a workaround, you can skip these symbols. After that, if this symbol is needed, you can add it back in the prologue. Prologue is specified by the prologue_file_path option.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"Add the symbol to output_ignorelist to avoid it from being wrapped.\nIf the symbol is in system headers and causes Clang.jl to error before printing, apart from posting an issue, write @add_def symbol_name before generating to suppress it from being wrapped.","category":"page"},{"location":"generator/#Rewrite-expressions-before-printing","page":"Generator Tutorial","title":"Rewrite expressions before printing","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"You can also modify the generated wrapped before it is printed. Clang.jl separates the building process into generating and printing processes. You can run these two processes separately and rewrite the expressions before printing.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"# build without printing so we can do custom rewriting\nbuild!(ctx, BUILDSTAGE_NO_PRINTING)\n\n# custom rewriter\nfunction rewrite!(e::Expr)\nend\n\nfunction rewrite!(dag::ExprDAG)\n    for node in get_nodes(dag)\n        for expr in get_exprs(node)\n            rewrite!(expr)\n        end\n    end\nend\n\nrewrite!(ctx.dag)\n\n# print\nbuild!(ctx, BUILDSTAGE_PRINTING_ONLY)","category":"page"},{"location":"generator/#Multi-platform-configuration","page":"Generator Tutorial","title":"Multi-platform configuration","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"Some headers may contain system-dependent symbols such as long or char, or system-independent symbols may be resolved to system-dependent ones. For example, time_t is usually just a 64-bit unsigned integer, but implementations may conditionally implement it as long or long long, which is not portable. You can skip these symbols and add them back manually as in Skipping specific symbols. If the differences are too large to be manually fixed, you can generate wrappers for each platform as in LibClang.jl.","category":"page"},{"location":"generator/#Variadic-Function","page":"Generator Tutorial","title":"Variadic Function","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"With the help of @ccall macro, variadic C functions can be called from Julia. For example, @ccall printf(\"%d\\n\"::Cstring; 123::Cint)::Cint can be used to call the C function printf. Note that those arguments after the semicolon ; are variadic arguments.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"If wrap_variadic_function in codegen section of options is set to true, Clang.jl will generate wrappers for variadic C functions. For example, printf will be wrapped as follows.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"@generated function printf(fmt, va_list...)\n        :(@ccall(libexample.printf(fmt::Ptr{Cchar}; $(to_c_type_pairs(va_list)...))::Cint))\n    end","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"It can be called just like normal Julia functions without specifying types: LibExample.printf(\"%d\\n\", 123).","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"note: Note\nAlthough variadic functions are supported, the C type va_list cannot be used from Julia.","category":"page"},{"location":"generator/#Type-Correspondence","page":"Generator Tutorial","title":"Type Correspondence","text":"","category":"section"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"However, variadic C functions must be called with the correct argument types. The most useful ones are listed below.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"C type ccall signature Julia type\nIntegers and floating point numbers the same type the same type\nStruct T a concrete Julia struct T with the same layout T\nPointer (T*) Ref{T} or Ptr{T} Ref{T} or Ptr{T} or any array type\nString (char*) Cstring or Ptr{Cchar} String","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"note: Note\nRef is not a concrete type but an abstract type in Julia. For example, Ref(1) is Base.RefValue(1), which cannot be directly passed to C.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"As observed from the table, if you want to pass strings or arrays to C, you need to annotate the type as Ptr{T} or Ref{T} (or Cstring). Otherwise, the struct that represents the String or Array type instead of the buffer itself will be passed. There are two methods to pass arguments of these types:","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"Directly use the @ccall macro: @ccall printf(\"%s\\n\"; \"hello\"::Cstring)::Cint. You can also create wrappers for common use cases of this.\nOverload to_c_type to map Julia type to correct ccall signature type: add to_c_type(::Type{String}) = Cstring to prologue (prologue can be added by setting prologue_file_path in options). Then all arguments of type String will be annotated as Cstring.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"The above type correspondence can be implemented by including the following lines in the prologue.","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"to_c_type(::Type{<:AbstractString}) = Cstring # or Ptr{Cchar}\nto_c_type(t::Type{<:Union{AbstractArray,Ref}}) = Ptr{eltype(t)}","category":"page"},{"location":"generator/","page":"Generator Tutorial","title":"Generator Tutorial","text":"For a complete tutorial on calling C functions, refer to Calling C and Fortran Code in the Julia manual.","category":"page"},{"location":"libclang/#LibClang-API-Reference","page":"LibClang Wrapper API Reference","title":"LibClang API Reference","text":"","category":"section"},{"location":"libclang/","page":"LibClang Wrapper API Reference","title":"LibClang Wrapper API Reference","text":"Clang.jl supports dumping original C documentation in comments, below is the documentation generated from libclang's comments.","category":"page"},{"location":"libclang/","page":"LibClang Wrapper API Reference","title":"LibClang Wrapper API Reference","text":"CurrentModule = LibClang","category":"page"},{"location":"libclang/","page":"LibClang Wrapper API Reference","title":"LibClang Wrapper API Reference","text":"Modules = [LibClang]\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"libclang/#Clang.LibClang.clang_BlockCommandComment_getArgText-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_BlockCommandComment_getArgText","text":"clang_BlockCommandComment_getArgText(Comment, ArgIdx)\n\nParameters\n\nComment: a CXComment_BlockCommand AST node.\nArgIdx: argument index (zero-based).\n\nReturns\n\ntext of the specified word-like argument.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_BlockCommandComment_getCommandName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_BlockCommandComment_getCommandName","text":"clang_BlockCommandComment_getCommandName(Comment)\n\nParameters\n\nComment: a CXComment_BlockCommand AST node.\n\nReturns\n\nname of the block command.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_BlockCommandComment_getNumArgs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_BlockCommandComment_getNumArgs","text":"clang_BlockCommandComment_getNumArgs(Comment)\n\nParameters\n\nComment: a CXComment_BlockCommand AST node.\n\nReturns\n\nnumber of word-like arguments.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_BlockCommandComment_getParagraph-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_BlockCommandComment_getParagraph","text":"clang_BlockCommandComment_getParagraph(Comment)\n\nParameters\n\nComment: a CXComment_BlockCommand or CXComment_VerbatimBlockCommand AST node.\n\nReturns\n\nparagraph argument of the block command.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXCursorSet_contains-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXCursorSet_contains","text":"clang_CXCursorSet_contains(cset, cursor)\n\nQueries a CXCursorSet to see if it contains a specific CXCursor.\n\nReturns\n\nnon-zero if the set contains the specified cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXCursorSet_insert-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXCursorSet_insert","text":"clang_CXCursorSet_insert(cset, cursor)\n\nInserts a CXCursor into a CXCursorSet.\n\nReturns\n\nzero if the CXCursor was already in the set, and non-zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXIndex_getGlobalOptions-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXIndex_getGlobalOptions","text":"clang_CXIndex_getGlobalOptions(arg1)\n\nGets the general options associated with a CXIndex.\n\nReturns\n\nA bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that are associated with the given CXIndex object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXIndex_setGlobalOptions-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXIndex_setGlobalOptions","text":"clang_CXIndex_setGlobalOptions(arg1, options)\n\nSets general options associated with a CXIndex.\n\nFor example:\n\n CXIndex idx = ...;\n clang_CXIndex_setGlobalOptions(idx,\n     clang_CXIndex_getGlobalOptions(idx) |\n     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n\nParameters\n\noptions: A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXIndex_setInvocationEmissionPathOption-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXIndex_setInvocationEmissionPathOption","text":"clang_CXIndex_setInvocationEmissionPathOption(arg1, Path)\n\nSets the invocation emission path option in a CXIndex.\n\nThe invocation emission path specifies a path which will contain log files for certain libclang invocations. A null value (default) implies that libclang invocations are not logged..\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_create-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_create","text":"clang_CXRewriter_create(TU)\n\nCreate CXRewriter.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_dispose","text":"clang_CXRewriter_dispose(Rew)\n\nFree the given CXRewriter.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_insertTextBefore-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_insertTextBefore","text":"clang_CXRewriter_insertTextBefore(Rew, Loc, Insert)\n\nInsert the specified string at the specified location in the original buffer.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_overwriteChangedFiles-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_overwriteChangedFiles","text":"clang_CXRewriter_overwriteChangedFiles(Rew)\n\nSave all changed files to disk. Returns 1 if any files were not saved successfully, returns 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_removeText-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_removeText","text":"clang_CXRewriter_removeText(Rew, ToBeRemoved)\n\nRemove the specified range.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_replaceText-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_replaceText","text":"clang_CXRewriter_replaceText(Rew, ToBeReplaced, Replacement)\n\nReplace the specified range of characters in the input with the specified replacement.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXRewriter_writeMainFileToStdOut-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXRewriter_writeMainFileToStdOut","text":"clang_CXRewriter_writeMainFileToStdOut(Rew)\n\nWrite out rewritten version of the main file to stdout.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXConstructor_isConvertingConstructor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXConstructor_isConvertingConstructor","text":"clang_CXXConstructor_isConvertingConstructor(C)\n\nDetermine if a C++ constructor is a converting constructor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXConstructor_isCopyConstructor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXConstructor_isCopyConstructor","text":"clang_CXXConstructor_isCopyConstructor(C)\n\nDetermine if a C++ constructor is a copy constructor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXConstructor_isDefaultConstructor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXConstructor_isDefaultConstructor","text":"clang_CXXConstructor_isDefaultConstructor(C)\n\nDetermine if a C++ constructor is the default constructor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXConstructor_isMoveConstructor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXConstructor_isMoveConstructor","text":"clang_CXXConstructor_isMoveConstructor(C)\n\nDetermine if a C++ constructor is a move constructor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXField_isMutable-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXField_isMutable","text":"clang_CXXField_isMutable(C)\n\nDetermine if a C++ field is declared 'mutable'.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXMethod_isConst-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXMethod_isConst","text":"clang_CXXMethod_isConst(C)\n\nDetermine if a C++ member function or member function template is declared 'const'.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXMethod_isDefaulted-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXMethod_isDefaulted","text":"clang_CXXMethod_isDefaulted(C)\n\nDetermine if a C++ method is declared '= default'.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXMethod_isPureVirtual-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXMethod_isPureVirtual","text":"clang_CXXMethod_isPureVirtual(C)\n\nDetermine if a C++ member function or member function template is pure virtual.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXMethod_isStatic-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXMethod_isStatic","text":"clang_CXXMethod_isStatic(C)\n\nDetermine if a C++ member function or member function template is declared 'static'.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXMethod_isVirtual-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXMethod_isVirtual","text":"clang_CXXMethod_isVirtual(C)\n\nDetermine if a C++ member function or member function template is explicitly declared 'virtual' or if it overrides a virtual method from one of the base classes.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CXXRecord_isAbstract-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CXXRecord_isAbstract","text":"clang_CXXRecord_isAbstract(C)\n\nDetermine if a C++ record is abstract, i.e. whether a class or struct has a pure virtual member function.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Comment_getChild-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Comment_getChild","text":"clang_Comment_getChild(Comment, ChildIdx)\n\nParameters\n\nComment: AST node of any kind.\nChildIdx: child index (zero-based).\n\nReturns\n\nthe specified child of the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Comment_getKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Comment_getKind","text":"clang_Comment_getKind(Comment)\n\nParameters\n\nComment: AST node of any kind.\n\nReturns\n\nthe type of the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Comment_getNumChildren-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Comment_getNumChildren","text":"clang_Comment_getNumChildren(Comment)\n\nParameters\n\nComment: AST node of any kind.\n\nReturns\n\nnumber of children of the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Comment_isWhitespace-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Comment_isWhitespace","text":"clang_Comment_isWhitespace(Comment)\n\nA CXComment_Paragraph node is considered whitespace if it contains only CXComment_Text nodes that are empty or whitespace.\n\nOther AST nodes (except CXComment_Paragraph and CXComment_Text) are never considered whitespace.\n\nReturns\n\nnon-zero if Comment is whitespace.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompilationDatabase_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompilationDatabase_dispose","text":"clang_CompilationDatabase_dispose(arg1)\n\nFree the given compilation database\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompilationDatabase_fromDirectory-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompilationDatabase_fromDirectory","text":"clang_CompilationDatabase_fromDirectory(BuildDir, ErrorCode)\n\nCreates a compilation database from the database found in directory buildDir. For example, CMake can output a compile_commands.json which can be used to build the database.\n\nIt must be freed by clang_CompilationDatabase_dispose.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompilationDatabase_getAllCompileCommands-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompilationDatabase_getAllCompileCommands","text":"clang_CompilationDatabase_getAllCompileCommands(arg1)\n\nGet all the compile commands in the given compilation database.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompilationDatabase_getCompileCommands-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompilationDatabase_getCompileCommands","text":"clang_CompilationDatabase_getCompileCommands(arg1, CompleteFileName)\n\nFind the compile commands used for a file. The compile commands must be freed by clang_CompileCommands_dispose.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getArg-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getArg","text":"clang_CompileCommand_getArg(arg1, I)\n\nGet the I'th argument value in the compiler invocations\n\nInvariant : - argument 0 is the compiler executable\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getDirectory-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getDirectory","text":"clang_CompileCommand_getDirectory(arg1)\n\nGet the working directory where the CompileCommand was executed from\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getFilename-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getFilename","text":"clang_CompileCommand_getFilename(arg1)\n\nGet the filename associated with the CompileCommand.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getMappedSourceContent-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getMappedSourceContent","text":"clang_CompileCommand_getMappedSourceContent(arg1, I)\n\nGet the I'th mapped source content for the compiler invocation.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getMappedSourcePath-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getMappedSourcePath","text":"clang_CompileCommand_getMappedSourcePath(arg1, I)\n\nGet the I'th mapped source path for the compiler invocation.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getNumArgs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getNumArgs","text":"clang_CompileCommand_getNumArgs(arg1)\n\nGet the number of arguments in the compiler invocation.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommand_getNumMappedSources-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommand_getNumMappedSources","text":"clang_CompileCommand_getNumMappedSources(arg1)\n\nGet the number of source mappings for the compiler invocation.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommands_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommands_dispose","text":"clang_CompileCommands_dispose(arg1)\n\nFree the given CompileCommands\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommands_getCommand-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommands_getCommand","text":"clang_CompileCommands_getCommand(arg1, I)\n\nGet the I'th CompileCommand for a file\n\nNote : 0 <= i < clang_CompileCommands_getSize(CXCompileCommands)\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_CompileCommands_getSize-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_CompileCommands_getSize","text":"clang_CompileCommands_getSize(arg1)\n\nGet the number of CompileCommand we have for a file\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_Evaluate-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_Evaluate","text":"clang_Cursor_Evaluate(C)\n\nIf cursor is a statement declaration tries to evaluate the statement and if its variable, tries to evaluate its initializer, into its corresponding type. If it's an expression, tries to evaluate the expression.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getArgument-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getArgument","text":"clang_Cursor_getArgument(C, i)\n\nRetrieve the argument cursor of a function or method.\n\nThe argument cursor can be determined for calls as well as for declarations of functions or methods. For other cursors and for invalid indices, an invalid cursor is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getBriefCommentText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getBriefCommentText","text":"clang_Cursor_getBriefCommentText(C)\n\nGiven a cursor that represents a documentable entity (e.g., declaration), return the associated\n\n; otherwise return the\n\nfirst paragraph.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getCXXManglings-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getCXXManglings","text":"clang_Cursor_getCXXManglings(arg1)\n\nRetrieve the CXStrings representing the mangled symbols of the C++ constructor or destructor at the cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getCommentRange-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getCommentRange","text":"clang_Cursor_getCommentRange(C)\n\nGiven a cursor that represents a declaration, return the associated comment's source range. The range may include multiple consecutive comments with whitespace in between.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getMangling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getMangling","text":"clang_Cursor_getMangling(arg1)\n\nRetrieve the CXString representing the mangled name of the cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getModule-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getModule","text":"clang_Cursor_getModule(C)\n\nGiven a CXCursor_ModuleImportDecl cursor, return the associated module.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getNumArguments-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getNumArguments","text":"clang_Cursor_getNumArguments(C)\n\nRetrieve the number of non-variadic arguments associated with a given cursor.\n\nThe number of arguments can be determined for calls as well as for declarations of functions or methods. For other cursors -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getNumTemplateArguments-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getNumTemplateArguments","text":"clang_Cursor_getNumTemplateArguments(C)\n\nReturns the number of template args of a function decl representing a template specialization.\n\nIf the argument cursor cannot be converted into a template function declaration, -1 is returned.\n\nFor example, for the following declaration and specialization: template <typename T, int kInt, bool kBool> void foo() { ... }\n\ntemplate <> void foo<float, -7, true>();\n\nThe value 3 would be returned from this call.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCDeclQualifiers-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCDeclQualifiers","text":"clang_Cursor_getObjCDeclQualifiers(C)\n\nGiven a cursor that represents an Objective-C method or parameter declaration, return the associated Objective-C qualifiers for the return type or the parameter respectively. The bits are formed from CXObjCDeclQualifierKind.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCManglings-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCManglings","text":"clang_Cursor_getObjCManglings(arg1)\n\nRetrieve the CXStrings representing the mangled symbols of the ObjC class interface or implementation at the cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCPropertyAttributes-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCPropertyAttributes","text":"clang_Cursor_getObjCPropertyAttributes(C, reserved)\n\nGiven a cursor that represents a property declaration, return the associated property attributes. The bits are formed from CXObjCPropertyAttrKind.\n\nParameters\n\nreserved: Reserved for future use, pass 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCPropertyGetterName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCPropertyGetterName","text":"clang_Cursor_getObjCPropertyGetterName(C)\n\nGiven a cursor that represents a property declaration, return the name of the method that implements the getter.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCPropertySetterName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCPropertySetterName","text":"clang_Cursor_getObjCPropertySetterName(C)\n\nGiven a cursor that represents a property declaration, return the name of the method that implements the setter, if any.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getObjCSelectorIndex-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getObjCSelectorIndex","text":"clang_Cursor_getObjCSelectorIndex(arg1)\n\nIf the cursor points to a selector identifier in an Objective-C method or message expression, this returns the selector index.\n\nAfter getting a cursor with #clang_getCursor, this can be called to determine if the location points to a selector identifier.\n\nReturns\n\nThe selector index if the cursor is an Objective-C method or message expression and the cursor is pointing to a selector identifier, or -1 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getOffsetOfField-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getOffsetOfField","text":"clang_Cursor_getOffsetOfField(C)\n\nReturn the offset of the field represented by the Cursor.\n\nIf the cursor is not a field declaration, -1 is returned. If the cursor semantic parent is not a record field declaration, CXTypeLayoutError_Invalid is returned. If the field's type declaration is an incomplete type, CXTypeLayoutError_Incomplete is returned. If the field's type declaration is a dependent type, CXTypeLayoutError_Dependent is returned. If the field's name S is not found, CXTypeLayoutError_InvalidFieldName is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getParsedComment-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getParsedComment","text":"clang_Cursor_getParsedComment(C)\n\nGiven a cursor that represents a documentable entity (e.g., declaration), return the associated parsed comment as a CXComment_FullComment AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getRawCommentText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getRawCommentText","text":"clang_Cursor_getRawCommentText(C)\n\nGiven a cursor that represents a declaration, return the associated comment text, including comment markers.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getReceiverType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getReceiverType","text":"clang_Cursor_getReceiverType(C)\n\nGiven a cursor pointing to an Objective-C message or property reference, or C++ method call, returns the CXType of the receiver.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getSpellingNameRange-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getSpellingNameRange","text":"clang_Cursor_getSpellingNameRange(arg1, pieceIndex, options)\n\nRetrieve a range for a piece that forms the cursors spelling name. Most of the times there is only one range for the complete spelling but for Objective-C methods and Objective-C message expressions, there are multiple pieces for each selector identifier.\n\nParameters\n\npieceIndex: the index of the spelling name piece. If this is greater than the actual number of pieces, it will return a NULL (invalid) range.\noptions: Reserved.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getStorageClass-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getStorageClass","text":"clang_Cursor_getStorageClass(arg1)\n\nReturns the storage class for a function or variable declaration.\n\nIf the passed in Cursor is not a function or variable declaration, CX_SC_Invalid is returned else the storage class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getTemplateArgumentKind-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getTemplateArgumentKind","text":"clang_Cursor_getTemplateArgumentKind(C, I)\n\nRetrieve the kind of the I'th template argument of the CXCursor C.\n\nIf the argument CXCursor does not represent a FunctionDecl, an invalid template argument kind is returned.\n\nFor example, for the following declaration and specialization: template <typename T, int kInt, bool kBool> void foo() { ... }\n\ntemplate <> void foo<float, -7, true>();\n\nFor I = 0, 1, and 2, Type, Integral, and Integral will be returned, respectively.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getTemplateArgumentType-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getTemplateArgumentType","text":"clang_Cursor_getTemplateArgumentType(C, I)\n\nRetrieve a CXType representing the type of a TemplateArgument of a function decl representing a template specialization.\n\nIf the argument CXCursor does not represent a FunctionDecl whose I'th template argument has a kind of CXTemplateArgKind_Integral, an invalid type is returned.\n\nFor example, for the following declaration and specialization: template <typename T, int kInt, bool kBool> void foo() { ... }\n\ntemplate <> void foo<float, -7, true>();\n\nIf called with I = 0, \"float\", will be returned. Invalid types will be returned for I == 1 or 2.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getTemplateArgumentUnsignedValue-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getTemplateArgumentUnsignedValue","text":"clang_Cursor_getTemplateArgumentUnsignedValue(C, I)\n\nRetrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as an unsigned long long.\n\nIt is undefined to call this function on a CXCursor that does not represent a FunctionDecl or whose I'th template argument is not an integral value.\n\nFor example, for the following declaration and specialization: template <typename T, int kInt, bool kBool> void foo() { ... }\n\ntemplate <> void foo<float, 2147483649, true>();\n\nIf called with I = 1 or 2, 2147483649 or true will be returned, respectively. For I == 0, this function's behavior is undefined.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getTemplateArgumentValue-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getTemplateArgumentValue","text":"clang_Cursor_getTemplateArgumentValue(C, I)\n\nRetrieve the value of an Integral TemplateArgument (of a function decl representing a template specialization) as a signed long long.\n\nIt is undefined to call this function on a CXCursor that does not represent a FunctionDecl or whose I'th template argument is not an integral value.\n\nFor example, for the following declaration and specialization: template <typename T, int kInt, bool kBool> void foo() { ... }\n\ntemplate <> void foo<float, -7, true>();\n\nIf called with I = 1 or 2, -7 or true will be returned, respectively. For I == 0, this function's behavior is undefined.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getTranslationUnit-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getTranslationUnit","text":"clang_Cursor_getTranslationUnit(arg1)\n\nReturns the translation unit that a cursor originated from.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_getVarDeclInitializer-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_getVarDeclInitializer","text":"clang_Cursor_getVarDeclInitializer(cursor)\n\nIf cursor refers to a variable declaration and it has initializer returns cursor referring to the initializer otherwise return null cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_hasAttrs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_hasAttrs","text":"clang_Cursor_hasAttrs(C)\n\nDetermine whether the given cursor has any attributes.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_hasVarDeclExternalStorage-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_hasVarDeclExternalStorage","text":"clang_Cursor_hasVarDeclExternalStorage(cursor)\n\nIf cursor refers to a variable declaration that has external storage returns 1. If cursor refers to a variable declaration that doesn't have external storage returns 0. Otherwise returns -1.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_hasVarDeclGlobalStorage-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_hasVarDeclGlobalStorage","text":"clang_Cursor_hasVarDeclGlobalStorage(cursor)\n\nIf cursor refers to a variable declaration that has global storage returns 1. If cursor refers to a variable declaration that doesn't have global storage returns 0. Otherwise returns -1.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isAnonymous-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isAnonymous","text":"clang_Cursor_isAnonymous(C)\n\nDetermine whether the given cursor represents an anonymous tag or namespace\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isAnonymousRecordDecl-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isAnonymousRecordDecl","text":"clang_Cursor_isAnonymousRecordDecl(C)\n\nDetermine whether the given cursor represents an anonymous record declaration.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isBitField-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isBitField","text":"clang_Cursor_isBitField(C)\n\nReturns non-zero if the cursor specifies a Record member that is a bitfield.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isDynamicCall-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isDynamicCall","text":"clang_Cursor_isDynamicCall(C)\n\nGiven a cursor pointing to a C++ method call or an Objective-C message, returns non-zero if the method/message is \"dynamic\", meaning:\n\nFor a C++ method: the call is virtual. For an Objective-C message: the receiver is an object instance, not 'super' or a specific class.\n\nIf the method/message is \"static\" or the cursor does not point to a method/message, it will return zero.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isExternalSymbol-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isExternalSymbol","text":"clang_Cursor_isExternalSymbol(C, language, definedIn, isGenerated)\n\nReturns non-zero if the given cursor points to a symbol marked with external_source_symbol attribute.\n\nParameters\n\nlanguage: If non-NULL, and the attribute is present, will be set to the 'language' string from the attribute.\ndefinedIn: If non-NULL, and the attribute is present, will be set to the 'definedIn' string from the attribute.\nisGenerated: If non-NULL, and the attribute is present, will be set to non-zero if the 'generated_declaration' is set in the attribute.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isFunctionInlined-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isFunctionInlined","text":"clang_Cursor_isFunctionInlined(C)\n\nDetermine whether a CXCursor that is a function declaration, is an inline declaration.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isInlineNamespace-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isInlineNamespace","text":"clang_Cursor_isInlineNamespace(C)\n\nDetermine whether the given cursor represents an inline namespace declaration.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isMacroBuiltin-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isMacroBuiltin","text":"clang_Cursor_isMacroBuiltin(C)\n\nDetermine whether a CXCursor that is a macro, is a builtin one.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isMacroFunctionLike-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isMacroFunctionLike","text":"clang_Cursor_isMacroFunctionLike(C)\n\nDetermine whether a CXCursor that is a macro, is function like.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isNull-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isNull","text":"clang_Cursor_isNull(cursor)\n\nReturns non-zero if cursor is null.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isObjCOptional-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isObjCOptional","text":"clang_Cursor_isObjCOptional(C)\n\nGiven a cursor that represents an Objective-C method or property declaration, return non-zero if the declaration was affected by \"\\@optional\". Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Cursor_isVariadic-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Cursor_isVariadic","text":"clang_Cursor_isVariadic(C)\n\nReturns non-zero if the given cursor is a variadic function or method.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EnumDecl_isScoped-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EnumDecl_isScoped","text":"clang_EnumDecl_isScoped(C)\n\nDetermine if an enum declaration refers to a scoped enum.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_dispose","text":"clang_EvalResult_dispose(E)\n\nDisposes the created Eval memory.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getAsDouble-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getAsDouble","text":"clang_EvalResult_getAsDouble(E)\n\nReturns the evaluation result as double if the kind is double.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getAsInt-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getAsInt","text":"clang_EvalResult_getAsInt(E)\n\nReturns the evaluation result as integer if the kind is Int.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getAsLongLong-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getAsLongLong","text":"clang_EvalResult_getAsLongLong(E)\n\nReturns the evaluation result as a long long integer if the kind is Int. This prevents overflows that may happen if the result is returned with clang_EvalResult_getAsInt.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getAsStr-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getAsStr","text":"clang_EvalResult_getAsStr(E)\n\nReturns the evaluation result as a constant string if the kind is other than Int or float. User must not free this pointer, instead call clang_EvalResult_dispose on the CXEvalResult returned by clang_Cursor_Evaluate.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getAsUnsigned-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getAsUnsigned","text":"clang_EvalResult_getAsUnsigned(E)\n\nReturns the evaluation result as an unsigned integer if the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_getKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_getKind","text":"clang_EvalResult_getKind(E)\n\nReturns the kind of the evaluated result.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_EvalResult_isUnsignedInt-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_EvalResult_isUnsignedInt","text":"clang_EvalResult_isUnsignedInt(E)\n\nReturns a non-zero value if the kind is Int and the evaluation result resulted in an unsigned integer.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_File_isEqual-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_File_isEqual","text":"clang_File_isEqual(file1, file2)\n\nReturns non-zero if the file1 and file2 point to the same file, or they are both NULL.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_File_tryGetRealPathName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_File_tryGetRealPathName","text":"clang_File_tryGetRealPathName(file)\n\nReturns the real path name of file.\n\nAn empty string may be returned. Use clang_getFileName() in that case.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_FullComment_getAsHTML-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_FullComment_getAsHTML","text":"clang_FullComment_getAsHTML(Comment)\n\nConvert a given full parsed comment to an HTML fragment.\n\nSpecific details of HTML layout are subject to change. Don't try to parse this HTML back into an AST, use other APIs instead.\n\nCurrently the following CSS classes are used:\n\n\"para-brief\" for\n\nand equivalent commands;\n\n\"para-returns\" for \\returns paragraph and equivalent commands;\n\"word-returns\" for the \"Returns\" word in \\returns paragraph.\n\nFunction argument documentation is rendered as a <dl> list with arguments sorted in function prototype order. CSS classes used:\n\n\"param-name-index-NUMBER\" for parameter name (<dt>);\n\"param-descr-index-NUMBER\" for parameter description (<dd>);\n\"param-name-index-invalid\" and \"param-descr-index-invalid\" are used if parameter index is invalid.\n\nTemplate parameter documentation is rendered as a <dl> list with parameters sorted in template parameter list order. CSS classes used:\n\n\"tparam-name-index-NUMBER\" for parameter name (<dt>);\n\"tparam-descr-index-NUMBER\" for parameter description (<dd>);\n\"tparam-name-index-other\" and \"tparam-descr-index-other\" are used for names inside template template parameters;\n\"tparam-name-index-invalid\" and \"tparam-descr-index-invalid\" are used if parameter position is invalid.\n\nParameters\n\nComment: a CXComment_FullComment AST node.\n\nReturns\n\nstring containing an HTML fragment.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_FullComment_getAsXML-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_FullComment_getAsXML","text":"clang_FullComment_getAsXML(Comment)\n\nConvert a given full parsed comment to an XML document.\n\nA Relax NG schema for the XML can be found in comment-xml-schema.rng file inside clang source tree.\n\nParameters\n\nComment: a CXComment_FullComment AST node.\n\nReturns\n\nstring containing an XML document.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLStartTagComment_isSelfClosing-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLStartTagComment_isSelfClosing","text":"clang_HTMLStartTagComment_isSelfClosing(Comment)\n\nParameters\n\nComment: a CXComment_HTMLStartTag AST node.\n\nReturns\n\nnon-zero if tag is self-closing (for example, <br />).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLStartTag_getAttrName-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLStartTag_getAttrName","text":"clang_HTMLStartTag_getAttrName(Comment, AttrIdx)\n\nParameters\n\nComment: a CXComment_HTMLStartTag AST node.\nAttrIdx: attribute index (zero-based).\n\nReturns\n\nname of the specified attribute.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLStartTag_getAttrValue-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLStartTag_getAttrValue","text":"clang_HTMLStartTag_getAttrValue(Comment, AttrIdx)\n\nParameters\n\nComment: a CXComment_HTMLStartTag AST node.\nAttrIdx: attribute index (zero-based).\n\nReturns\n\nvalue of the specified attribute.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLStartTag_getNumAttrs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLStartTag_getNumAttrs","text":"clang_HTMLStartTag_getNumAttrs(Comment)\n\nParameters\n\nComment: a CXComment_HTMLStartTag AST node.\n\nReturns\n\nnumber of attributes (name-value pairs) attached to the start tag.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLTagComment_getAsString-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLTagComment_getAsString","text":"clang_HTMLTagComment_getAsString(Comment)\n\nConvert an HTML tag AST node to string.\n\nParameters\n\nComment: a CXComment_HTMLStartTag or CXComment_HTMLEndTag AST node.\n\nReturns\n\nstring containing an HTML tag.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_HTMLTagComment_getTagName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_HTMLTagComment_getTagName","text":"clang_HTMLTagComment_getTagName(Comment)\n\nParameters\n\nComment: a CXComment_HTMLStartTag or CXComment_HTMLEndTag AST node.\n\nReturns\n\nHTML tag name.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_IndexAction_create-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_IndexAction_create","text":"clang_IndexAction_create(CIdx)\n\nAn indexing action/session, to be applied to one or multiple translation units.\n\nParameters\n\nCIdx: The index object with which the index action will be associated.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_IndexAction_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_IndexAction_dispose","text":"clang_IndexAction_dispose(arg1)\n\nDestroy the given index action.\n\nThe index action must not be destroyed until all of the translation units created within that index action have been destroyed.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_InlineCommandComment_getArgText-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_InlineCommandComment_getArgText","text":"clang_InlineCommandComment_getArgText(Comment, ArgIdx)\n\nParameters\n\nComment: a CXComment_InlineCommand AST node.\nArgIdx: argument index (zero-based).\n\nReturns\n\ntext of the specified argument.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_InlineCommandComment_getCommandName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_InlineCommandComment_getCommandName","text":"clang_InlineCommandComment_getCommandName(Comment)\n\nParameters\n\nComment: a CXComment_InlineCommand AST node.\n\nReturns\n\nname of the inline command.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_InlineCommandComment_getNumArgs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_InlineCommandComment_getNumArgs","text":"clang_InlineCommandComment_getNumArgs(Comment)\n\nParameters\n\nComment: a CXComment_InlineCommand AST node.\n\nReturns\n\nnumber of command arguments.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_InlineCommandComment_getRenderKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_InlineCommandComment_getRenderKind","text":"clang_InlineCommandComment_getRenderKind(Comment)\n\nParameters\n\nComment: a CXComment_InlineCommand AST node.\n\nReturns\n\nthe most appropriate rendering mode, chosen on command semantics in Doxygen.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_InlineContentComment_hasTrailingNewline-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_InlineContentComment_hasTrailingNewline","text":"clang_InlineContentComment_hasTrailingNewline(Comment)\n\nReturns\n\nnon-zero if Comment is inline content and has a newline immediately following it in the comment text. Newlines between paragraphs do not count.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Location_isFromMainFile-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Location_isFromMainFile","text":"clang_Location_isFromMainFile(location)\n\nReturns non-zero if the given source location is in the main file of the corresponding translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Location_isInSystemHeader-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Location_isInSystemHeader","text":"clang_Location_isInSystemHeader(location)\n\nReturns non-zero if the given source location is in a system header.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ModuleMapDescriptor_create-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ModuleMapDescriptor_create","text":"clang_ModuleMapDescriptor_create(options)\n\nCreate a CXModuleMapDescriptor object. Must be disposed with clang_ModuleMapDescriptor_dispose().\n\nParameters\n\noptions: is reserved, always pass 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ModuleMapDescriptor_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ModuleMapDescriptor_dispose","text":"clang_ModuleMapDescriptor_dispose(arg1)\n\nDispose a CXModuleMapDescriptor object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ModuleMapDescriptor_setFrameworkModuleName-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ModuleMapDescriptor_setFrameworkModuleName","text":"clang_ModuleMapDescriptor_setFrameworkModuleName(arg1, name)\n\nSets the framework module name that the module.map describes.\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ModuleMapDescriptor_setUmbrellaHeader-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ModuleMapDescriptor_setUmbrellaHeader","text":"clang_ModuleMapDescriptor_setUmbrellaHeader(arg1, name)\n\nSets the umbrella header name that the module.map describes.\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ModuleMapDescriptor_writeToBuffer-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ModuleMapDescriptor_writeToBuffer","text":"clang_ModuleMapDescriptor_writeToBuffer(arg1, options, out_buffer_ptr, out_buffer_size)\n\nWrite out the CXModuleMapDescriptor object to a char buffer.\n\nParameters\n\noptions: is reserved, always pass 0.\nout_buffer_ptr: pointer to receive the buffer pointer, which should be disposed using clang_free().\nout_buffer_size: pointer to receive the buffer size.\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getASTFile-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getASTFile","text":"clang_Module_getASTFile(Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nthe module file where the provided module object came from.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getFullName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getFullName","text":"clang_Module_getFullName(Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nthe full name of the module, e.g. \"std.vector\".\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getName","text":"clang_Module_getName(Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nthe name of the module, e.g. for the 'std.vector' sub-module it will return \"vector\".\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getNumTopLevelHeaders-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getNumTopLevelHeaders","text":"clang_Module_getNumTopLevelHeaders(arg1, Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nthe number of top level headers associated with this module.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getParent-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getParent","text":"clang_Module_getParent(Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nthe parent of a sub-module or NULL if the given module is top-level, e.g. for 'std.vector' it will return the 'std' module.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_getTopLevelHeader-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_getTopLevelHeader","text":"clang_Module_getTopLevelHeader(arg1, Module, Index)\n\nParameters\n\nModule: a module object.\nIndex: top level header index (zero-based).\n\nReturns\n\nthe specified top level header associated with the module.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Module_isSystem-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Module_isSystem","text":"clang_Module_isSystem(Module)\n\nParameters\n\nModule: a module object.\n\nReturns\n\nnon-zero if the module is a system one.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ParamCommandComment_getDirection-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ParamCommandComment_getDirection","text":"clang_ParamCommandComment_getDirection(Comment)\n\nParameters\n\nComment: a CXComment_ParamCommand AST node.\n\nReturns\n\nparameter passing direction.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ParamCommandComment_getParamIndex-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ParamCommandComment_getParamIndex","text":"clang_ParamCommandComment_getParamIndex(Comment)\n\nParameters\n\nComment: a CXComment_ParamCommand AST node.\n\nReturns\n\nzero-based parameter index in function prototype.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ParamCommandComment_getParamName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ParamCommandComment_getParamName","text":"clang_ParamCommandComment_getParamName(Comment)\n\nParameters\n\nComment: a CXComment_ParamCommand AST node.\n\nReturns\n\nparameter name.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ParamCommandComment_isDirectionExplicit-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ParamCommandComment_isDirectionExplicit","text":"clang_ParamCommandComment_isDirectionExplicit(Comment)\n\nParameters\n\nComment: a CXComment_ParamCommand AST node.\n\nReturns\n\nnon-zero if parameter passing direction was specified explicitly in the comment.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_ParamCommandComment_isParamIndexValid-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_ParamCommandComment_isParamIndexValid","text":"clang_ParamCommandComment_isParamIndexValid(Comment)\n\nParameters\n\nComment: a CXComment_ParamCommand AST node.\n\nReturns\n\nnon-zero if the parameter that this AST node represents was found in the function prototype and clang_ParamCommandComment_getParamIndex function will return a meaningful value.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_PrintingPolicy_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_PrintingPolicy_dispose","text":"clang_PrintingPolicy_dispose(Policy)\n\nRelease a printing policy.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_PrintingPolicy_getProperty-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_PrintingPolicy_getProperty","text":"clang_PrintingPolicy_getProperty(Policy, Property)\n\nGet a property value for the given printing policy.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_PrintingPolicy_setProperty-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_PrintingPolicy_setProperty","text":"clang_PrintingPolicy_setProperty(Policy, Property, Value)\n\nSet a property value for the given printing policy.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Range_isNull-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Range_isNull","text":"clang_Range_isNull(range)\n\nReturns non-zero if range is null.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TParamCommandComment_getDepth-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TParamCommandComment_getDepth","text":"clang_TParamCommandComment_getDepth(Comment)\n\nFor example,\n\n     template<typename C, template<typename T> class TT>\n     void test(TT<int> aaa);\n\nfor C and TT nesting depth is 0, for T nesting depth is 1.\n\nParameters\n\nComment: a CXComment_TParamCommand AST node.\n\nReturns\n\nzero-based nesting depth of this parameter in the template parameter list.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TParamCommandComment_getIndex-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TParamCommandComment_getIndex","text":"clang_TParamCommandComment_getIndex(Comment, Depth)\n\nFor example,\n\n     template<typename C, template<typename T> class TT>\n     void test(TT<int> aaa);\n\nfor C and TT nesting depth is 0, so we can ask for index at depth 0: at depth 0 C's index is 0, TT's index is 1.\n\nFor T nesting depth is 1, so we can ask for index at depth 0 and 1: at depth 0 T's index is 1 (same as TT's), at depth 1 T's index is 0.\n\nParameters\n\nComment: a CXComment_TParamCommand AST node.\n\nReturns\n\nzero-based parameter index in the template parameter list at a given nesting depth.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TParamCommandComment_getParamName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TParamCommandComment_getParamName","text":"clang_TParamCommandComment_getParamName(Comment)\n\nParameters\n\nComment: a CXComment_TParamCommand AST node.\n\nReturns\n\ntemplate parameter name.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TParamCommandComment_isParamPositionValid-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TParamCommandComment_isParamPositionValid","text":"clang_TParamCommandComment_isParamPositionValid(Comment)\n\nParameters\n\nComment: a CXComment_TParamCommand AST node.\n\nReturns\n\nnon-zero if the parameter that this AST node represents was found in the template parameter list and clang_TParamCommandComment_getDepth and clang_TParamCommandComment_getIndex functions will return a meaningful value.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TargetInfo_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TargetInfo_dispose","text":"clang_TargetInfo_dispose(Info)\n\nDestroy the CXTargetInfo object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TargetInfo_getPointerWidth-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TargetInfo_getPointerWidth","text":"clang_TargetInfo_getPointerWidth(Info)\n\nGet the pointer width of the target in bits.\n\nReturns -1 in case of error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TargetInfo_getTriple-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TargetInfo_getTriple","text":"clang_TargetInfo_getTriple(Info)\n\nGet the normalized target triple as a string.\n\nReturns the empty string in case of any error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_TextComment_getText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_TextComment_getText","text":"clang_TextComment_getText(Comment)\n\nParameters\n\nComment: a CXComment_Text AST node.\n\nReturns\n\ntext contained in the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getAlignOf-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getAlignOf","text":"clang_Type_getAlignOf(T)\n\nReturn the alignment of a type in bytes as per C++[expr.alignof] standard.\n\nIf the type declaration is invalid, CXTypeLayoutError_Invalid is returned. If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete is returned. If the type declaration is a dependent type, CXTypeLayoutError_Dependent is returned. If the type declaration is not a constant size type, CXTypeLayoutError_NotConstantSize is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getCXXRefQualifier-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getCXXRefQualifier","text":"clang_Type_getCXXRefQualifier(T)\n\nRetrieve the ref-qualifier kind of a function or method.\n\nThe ref-qualifier is returned for C++ functions or methods. For other types or non-C++ declarations, CXRefQualifier_None is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getClassType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getClassType","text":"clang_Type_getClassType(T)\n\nReturn the class type of an member pointer type.\n\nIf a non-member-pointer type is passed in, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getModifiedType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getModifiedType","text":"clang_Type_getModifiedType(T)\n\nReturn the type that was modified by this attributed type.\n\nIf the type is not an attributed type, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getNamedType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getNamedType","text":"clang_Type_getNamedType(T)\n\nRetrieve the type named by the qualified-id.\n\nIf a non-elaborated type is passed in, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getNullability-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getNullability","text":"clang_Type_getNullability(T)\n\nRetrieve the nullability kind of a pointer type.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getNumObjCProtocolRefs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getNumObjCProtocolRefs","text":"clang_Type_getNumObjCProtocolRefs(T)\n\nRetrieve the number of protocol references associated with an ObjC object/id.\n\nIf the type is not an ObjC object, 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getNumObjCTypeArgs-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getNumObjCTypeArgs","text":"clang_Type_getNumObjCTypeArgs(T)\n\nRetrieve the number of type arguments associated with an ObjC object.\n\nIf the type is not an ObjC object, 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getNumTemplateArguments-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getNumTemplateArguments","text":"clang_Type_getNumTemplateArguments(T)\n\nReturns the number of template arguments for given template specialization, or -1 if type T is not a template specialization.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getObjCEncoding-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getObjCEncoding","text":"clang_Type_getObjCEncoding(type)\n\nReturns the Objective-C type encoding for the specified CXType.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getObjCObjectBaseType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getObjCObjectBaseType","text":"clang_Type_getObjCObjectBaseType(T)\n\nRetrieves the base type of the ObjCObjectType.\n\nIf the type is not an ObjC object, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getObjCProtocolDecl-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getObjCProtocolDecl","text":"clang_Type_getObjCProtocolDecl(T, i)\n\nRetrieve the decl for a protocol reference for an ObjC object/id.\n\nIf the type is not an ObjC object or there are not enough protocol references, an invalid cursor is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getObjCTypeArg-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getObjCTypeArg","text":"clang_Type_getObjCTypeArg(T, i)\n\nRetrieve a type argument associated with an ObjC object.\n\nIf the type is not an ObjC or the index is not valid, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getOffsetOf-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getOffsetOf","text":"clang_Type_getOffsetOf(T, S)\n\nReturn the offset of a field named S in a record of type T in bits as it would be returned by __offsetof__ as per C++11[18.2p4]\n\nIf the cursor is not a record field declaration, CXTypeLayoutError_Invalid is returned. If the field's type declaration is an incomplete type, CXTypeLayoutError_Incomplete is returned. If the field's type declaration is a dependent type, CXTypeLayoutError_Dependent is returned. If the field's name S is not found, CXTypeLayoutError_InvalidFieldName is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getSizeOf-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getSizeOf","text":"clang_Type_getSizeOf(T)\n\nReturn the size of a type in bytes as per C++[expr.sizeof] standard.\n\nIf the type declaration is invalid, CXTypeLayoutError_Invalid is returned. If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete is returned. If the type declaration is a dependent type, CXTypeLayoutError_Dependent is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getTemplateArgumentAsType-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getTemplateArgumentAsType","text":"clang_Type_getTemplateArgumentAsType(T, i)\n\nReturns the type template argument of a template class specialization at given index.\n\nThis function only returns template type arguments and does not handle template template arguments or variadic packs.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_getValueType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_getValueType","text":"clang_Type_getValueType(CT)\n\nGets the type contained by this atomic type.\n\nIf a non-atomic type is passed in, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_isTransparentTagTypedef-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_isTransparentTagTypedef","text":"clang_Type_isTransparentTagTypedef(T)\n\nDetermine if a typedef is 'transparent' tag.\n\nA typedef is considered 'transparent' if it shares a name and spelling location with its underlying tag type, as is the case with the NS_ENUM macro.\n\nReturns\n\nnon-zero if transparent and zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_Type_visitFields-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_Type_visitFields","text":"clang_Type_visitFields(T, visitor, client_data)\n\nVisit the fields of a particular type.\n\nThis function visits all the direct fields of the given cursor, invoking the given visitor function with the cursors of each visited field. The traversal may be ended prematurely, if the visitor returns CXFieldVisit_Break.\n\nParameters\n\nT: the record type whose field may be visited.\nvisitor: the visitor function that will be invoked for each field of T.\nclient_data: pointer data supplied by the client, which will be passed to the visitor each time it is invoked.\n\nReturns\n\na non-zero value if the traversal was terminated prematurely by the visitor returning CXFieldVisit_Break.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VerbatimBlockLineComment_getText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VerbatimBlockLineComment_getText","text":"clang_VerbatimBlockLineComment_getText(Comment)\n\nParameters\n\nComment: a CXComment_VerbatimBlockLine AST node.\n\nReturns\n\ntext contained in the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VerbatimLineComment_getText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VerbatimLineComment_getText","text":"clang_VerbatimLineComment_getText(Comment)\n\nParameters\n\nComment: a CXComment_VerbatimLine AST node.\n\nReturns\n\ntext contained in the AST node.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VirtualFileOverlay_addFileMapping-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VirtualFileOverlay_addFileMapping","text":"clang_VirtualFileOverlay_addFileMapping(arg1, virtualPath, realPath)\n\nMap an absolute virtual file path to an absolute real one. The virtual path must be canonicalized (not contain \".\"/\"..\").\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VirtualFileOverlay_create-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VirtualFileOverlay_create","text":"clang_VirtualFileOverlay_create(options)\n\nCreate a CXVirtualFileOverlay object. Must be disposed with clang_VirtualFileOverlay_dispose().\n\nParameters\n\noptions: is reserved, always pass 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VirtualFileOverlay_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VirtualFileOverlay_dispose","text":"clang_VirtualFileOverlay_dispose(arg1)\n\nDispose a CXVirtualFileOverlay object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VirtualFileOverlay_setCaseSensitivity-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VirtualFileOverlay_setCaseSensitivity","text":"clang_VirtualFileOverlay_setCaseSensitivity(arg1, caseSensitive)\n\nSet the case sensitivity for the CXVirtualFileOverlay object. The CXVirtualFileOverlay object is case-sensitive by default, this option can be used to override the default.\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_VirtualFileOverlay_writeToBuffer-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_VirtualFileOverlay_writeToBuffer","text":"clang_VirtualFileOverlay_writeToBuffer(arg1, options, out_buffer_ptr, out_buffer_size)\n\nWrite out the CXVirtualFileOverlay object to a char buffer.\n\nParameters\n\noptions: is reserved, always pass 0.\nout_buffer_ptr: pointer to receive the buffer pointer, which should be disposed using clang_free().\nout_buffer_size: pointer to receive the buffer size.\n\nReturns\n\n0 for success, non-zero to indicate an error.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_annotateTokens-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_annotateTokens","text":"clang_annotateTokens(TU, Tokens, NumTokens, Cursors)\n\nAnnotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.\n\nThis token-annotation routine is equivalent to invoking clang_getCursor() for the source locations of each of the tokens. The cursors provided are filtered, so that only those cursors that have a direct correspondence to the token are accepted. For example, given a function call f(x), clang_getCursor() would provide the following cursors:\n\nwhen the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'. * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'. * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n\nOnly the first and last of these cursors will occur within the annotate, since the tokens \"f\" and \"x' directly refer to a function and a variable, respectively, but the parentheses are just a small part of the full syntax of the function call expression, which is not provided as an annotation.\n\nParameters\n\nTU: the translation unit that owns the given tokens.\nTokens: the set of tokens to annotate.\nNumTokens: the number of tokens in Tokens.\nCursors: an array of NumTokens cursors, whose contents will be replaced with the cursors corresponding to each token.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteAt-NTuple{7, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteAt","text":"clang_codeCompleteAt(TU, complete_filename, complete_line, complete_column, unsaved_files, num_unsaved_files, options)\n\nPerform code completion at a given location in a translation unit.\n\nThis function performs code completion at a particular file, line, and column within source code, providing results that suggest potential code snippets based on the context of the completion. The basic model for code completion is that Clang will parse a complete source file, performing syntax checking up to the location where code-completion has been requested. At that point, a special code-completion token is passed to the parser, which recognizes this token and determines, based on the current location in the C/Objective-C/C++ grammar and the state of semantic analysis, what completions to provide. These completions are returned via a new CXCodeCompleteResults structure.\n\nCode completion itself is meant to be triggered by the client when the user types punctuation characters or whitespace, at which point the code-completion location will coincide with the cursor. For example, if p is a pointer, code-completion might be triggered after the \"-\" and then after the \">\" in p->. When the code-completion location is after the \">\", the completion results will provide, e.g., the members of the struct that \"p\" points to. The client is responsible for placing the cursor at the beginning of the token currently being typed, then filtering the results based on the contents of the token. For example, when code-completing for the expression p->get, the client should provide the location just after the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the client can filter the results based on the current token text (\"get\"), only showing those results that start with \"get\". The intent of this interface is to separate the relatively high-latency acquisition of code-completion results from the filtering of results on a per-character basis, which must have a lower latency.\n\nParameters\n\nTU: The translation unit in which code-completion should occur. The source files for this translation unit need not be completely up-to-date (and the contents of those source files may be overridden via unsaved_files). Cursors referring into the translation unit may be invalidated by this invocation.\ncomplete_filename: The name of the source file where code completion should be performed. This filename may be any file included in the translation unit.\ncomplete_line: The line at which code-completion should occur.\ncomplete_column: The column at which code-completion should occur. Note that the column should point just after the syntactic construct that initiated code completion, and not in the middle of a lexical token.\nunsaved_files: the Files that have not yet been saved to disk but may be required for parsing or code completion, including the contents of those files. The contents and name of these files (as specified by CXUnsavedFile) are copied when necessary, so the client only needs to guarantee their validity until the call to this function returns.\nnum_unsaved_files: The number of unsaved file entries in unsaved_files.\noptions: Extra options that control the behavior of code completion, expressed as a bitwise OR of the enumerators of the CXCodeComplete_Flags enumeration. The clang_defaultCodeCompleteOptions() function returns a default set of code-completion options.\n\nReturns\n\nIf successful, a new CXCodeCompleteResults structure containing code-completion results, which should eventually be freed with clang_disposeCodeCompleteResults(). If code completion fails, returns NULL.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetContainerKind-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetContainerKind","text":"clang_codeCompleteGetContainerKind(Results, IsIncomplete)\n\nReturns the cursor kind for the container for the current code completion context. The container is only guaranteed to be set for contexts where a container exists (i.e. member accesses or Objective-C message sends); if there is not a container, this function will return CXCursor_InvalidCode.\n\nParameters\n\nResults: the code completion results to query\nIsIncomplete: on return, this value will be false if Clang has complete information about the container. If Clang does not have complete information, this value will be true.\n\nReturns\n\nthe container kind, or CXCursor_InvalidCode if there is not a container\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetContainerUSR-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetContainerUSR","text":"clang_codeCompleteGetContainerUSR(Results)\n\nReturns the USR for the container for the current code completion context. If there is not a container for the current context, this function will return the empty string.\n\nParameters\n\nResults: the code completion results to query\n\nReturns\n\nthe USR for the container\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetContexts-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetContexts","text":"clang_codeCompleteGetContexts(Results)\n\nDetermines what completions are appropriate for the context the given code completion.\n\nParameters\n\nResults: the code completion results to query\n\nReturns\n\nthe kinds of completions that are appropriate for use along with the given code completion results.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetDiagnostic-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetDiagnostic","text":"clang_codeCompleteGetDiagnostic(Results, Index)\n\nRetrieve a diagnostic associated with the given code completion.\n\nParameters\n\nResults: the code completion results to query.\nIndex: the zero-based diagnostic number to retrieve.\n\nReturns\n\nthe requested diagnostic. This diagnostic must be freed via a call to clang_disposeDiagnostic().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetNumDiagnostics-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetNumDiagnostics","text":"clang_codeCompleteGetNumDiagnostics(Results)\n\nDetermine the number of diagnostics produced prior to the location where code completion was performed.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_codeCompleteGetObjCSelector-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_codeCompleteGetObjCSelector","text":"clang_codeCompleteGetObjCSelector(Results)\n\nReturns the currently-entered selector for an Objective-C message send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a non-empty string for CXCompletionContext_ObjCInstanceMessage and CXCompletionContext_ObjCClassMessage.\n\nParameters\n\nResults: the code completion results to query\n\nReturns\n\nthe selector (or partial selector) that has been entered thus far for an Objective-C message send.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCCategory-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCCategory","text":"clang_constructUSR_ObjCCategory(class_name, category_name)\n\nConstruct a USR for a specified Objective-C category.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCClass-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCClass","text":"clang_constructUSR_ObjCClass(class_name)\n\nConstruct a USR for a specified Objective-C class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCIvar-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCIvar","text":"clang_constructUSR_ObjCIvar(name, classUSR)\n\nConstruct a USR for a specified Objective-C instance variable and the USR for its containing class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCMethod-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCMethod","text":"clang_constructUSR_ObjCMethod(name, isInstanceMethod, classUSR)\n\nConstruct a USR for a specified Objective-C method and the USR for its containing class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCProperty-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCProperty","text":"clang_constructUSR_ObjCProperty(property, classUSR)\n\nConstruct a USR for a specified Objective-C property and the USR for its containing class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_constructUSR_ObjCProtocol-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_constructUSR_ObjCProtocol","text":"clang_constructUSR_ObjCProtocol(protocol_name)\n\nConstruct a USR for a specified Objective-C protocol.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_createCXCursorSet-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_createCXCursorSet","text":"clang_createCXCursorSet()\n\nCreates an empty CXCursorSet.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_createIndex-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_createIndex","text":"clang_createIndex(excludeDeclarationsFromPCH, displayDiagnostics)\n\nProvides a shared context for creating translation units.\n\nIt provides two options:\n\nexcludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\" declarations (when loading any new translation units). A \"local\" declaration is one that belongs in the translation unit itself and not in a precompiled header that was used by the translation unit. If zero, all declarations will be enumerated.\n\nHere is an example:\n\n   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n   Idx = clang_createIndex(1, 1);\n   // IndexTest.pch was produced with the following command:\n   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n   // This will load all the symbols from 'IndexTest.pch'\n   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n                       TranslationUnitVisitor, 0);\n   clang_disposeTranslationUnit(TU);\n   // This will load all the symbols from 'IndexTest.c', excluding symbols\n   // from 'IndexTest.pch'.\n   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n                                                  0, 0);\n   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n                       TranslationUnitVisitor, 0);\n   clang_disposeTranslationUnit(TU);\n\nThis process of creating the 'pch', loading it separately, and using it (via -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks (which gives the indexer the same performance benefit as the compiler).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_createTranslationUnit-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_createTranslationUnit","text":"clang_createTranslationUnit(CIdx, ast_filename)\n\nSame as clang_createTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_createTranslationUnit2-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_createTranslationUnit2","text":"clang_createTranslationUnit2(CIdx, ast_filename, out_TU)\n\nCreate a translation unit from an AST file (-emit-ast).\n\nParameters\n\nout_TU:[out] A non-NULL pointer to store the created CXTranslationUnit.\n\nReturns\n\nZero on success, otherwise returns an error code.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_createTranslationUnitFromSourceFile-NTuple{6, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_createTranslationUnitFromSourceFile","text":"clang_createTranslationUnitFromSourceFile(CIdx, source_filename, num_clang_command_line_args, clang_command_line_args, num_unsaved_files, unsaved_files)\n\nReturn the CXTranslationUnit for a given source file and the provided command line arguments one would pass to the compiler.\n\nNote: The 'source_filename' argument is optional. If the caller provides a NULL pointer, the name of the source file is expected to reside in the specified command line arguments.\n\nNote: When encountered in 'clang_command_line_args', the following options are ignored:\n\n'-c' '-emit-ast' '-fsyntax-only' '-o <output file>' (both '-o' and '<output file>' are ignored)\n\nParameters\n\nCIdx: The index object with which the translation unit will be associated.\nsource_filename: The name of the source file to load, or NULL if the source file is included in clang_command_line_args.\nnum_clang_command_line_args: The number of command-line arguments in clang_command_line_args.\nclang_command_line_args: The command-line arguments that would be passed to the clang executable if it were being invoked out-of-process. These command-line options will be parsed and will affect how the translation unit is parsed. Note that the following options are ignored: '-c', '-emit-ast', '-fsyntax-only' (which is the default), and '-o <output file>'.\nnum_unsaved_files: the number of unsaved file entries in unsaved_files.\nunsaved_files: the files that have not yet been saved to disk but may be required for code completion, including the contents of those files. The contents and name of these files (as specified by CXUnsavedFile) are copied when necessary, so the client only needs to guarantee their validity until the call to this function returns.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_defaultCodeCompleteOptions-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_defaultCodeCompleteOptions","text":"clang_defaultCodeCompleteOptions()\n\nReturns a default set of code-completion options that can be passed toclang_codeCompleteAt().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_defaultDiagnosticDisplayOptions-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_defaultDiagnosticDisplayOptions","text":"clang_defaultDiagnosticDisplayOptions()\n\nRetrieve the set of display options most similar to the default behavior of the clang compiler.\n\nReturns\n\nA set of display options suitable for use with clang_formatDiagnostic().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_defaultEditingTranslationUnitOptions-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_defaultEditingTranslationUnitOptions","text":"clang_defaultEditingTranslationUnitOptions()\n\nReturns the set of flags that is suitable for parsing a translation unit that is being edited.\n\nThe set of flags returned provide options for clang_parseTranslationUnit() to indicate that the translation unit is likely to be reparsed many times, either explicitly (via clang_reparseTranslationUnit()) or implicitly (e.g., by code completion (clang_codeCompletionAt())). The returned flag set contains an unspecified set of optimizations (e.g., the precompiled preamble) geared toward improving the performance of these routines. The set of optimizations enabled may change from one version to the next.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_defaultReparseOptions-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_defaultReparseOptions","text":"clang_defaultReparseOptions(TU)\n\nReturns the set of flags that is suitable for reparsing a translation unit.\n\nThe set of flags returned provide options for clang_reparseTranslationUnit() by default. The returned flag set contains an unspecified set of optimizations geared toward common uses of reparsing. The set of optimizations enabled may change from one version to the next.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_defaultSaveOptions-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_defaultSaveOptions","text":"clang_defaultSaveOptions(TU)\n\nReturns the set of flags that is suitable for saving a translation unit.\n\nThe set of flags returned provide options for clang_saveTranslationUnit() by default. The returned flag set contains an unspecified set of options that save translation units with the most commonly-requested data.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeCXCursorSet-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeCXCursorSet","text":"clang_disposeCXCursorSet(cset)\n\nDisposes a CXCursorSet and releases its associated memory.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeCXPlatformAvailability-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeCXPlatformAvailability","text":"clang_disposeCXPlatformAvailability(availability)\n\nFree the memory associated with a CXPlatformAvailability structure.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeCodeCompleteResults-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeCodeCompleteResults","text":"clang_disposeCodeCompleteResults(Results)\n\nFree the given set of code-completion results.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeDiagnostic-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeDiagnostic","text":"clang_disposeDiagnostic(Diagnostic)\n\nDestroy a diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeDiagnosticSet-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeDiagnosticSet","text":"clang_disposeDiagnosticSet(Diags)\n\nRelease a CXDiagnosticSet and all of its contained diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeIndex-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeIndex","text":"clang_disposeIndex(index)\n\nDestroy the given index.\n\nThe index must not be destroyed until all of the translation units created within that index have been destroyed.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeOverriddenCursors-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeOverriddenCursors","text":"clang_disposeOverriddenCursors(overridden)\n\nFree the set of overridden cursors returned by clang_getOverriddenCursors().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeSourceRangeList-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeSourceRangeList","text":"clang_disposeSourceRangeList(ranges)\n\nDestroy the given CXSourceRangeList.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeString-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeString","text":"clang_disposeString(string)\n\nFree the given string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeStringSet-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeStringSet","text":"clang_disposeStringSet(set)\n\nFree the given string set.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeTokens-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeTokens","text":"clang_disposeTokens(TU, Tokens, NumTokens)\n\nFree the given set of tokens.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_disposeTranslationUnit-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_disposeTranslationUnit","text":"clang_disposeTranslationUnit(arg1)\n\nDestroy the specified CXTranslationUnit object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_equalCursors-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_equalCursors","text":"clang_equalCursors(arg1, arg2)\n\nDetermine whether two cursors are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_equalLocations-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_equalLocations","text":"clang_equalLocations(loc1, loc2)\n\nDetermine whether two source locations, which must refer into the same translation unit, refer to exactly the same point in the source code.\n\nReturns\n\nnon-zero if the source locations refer to the same location, zero if they refer to different locations.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_equalRanges-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_equalRanges","text":"clang_equalRanges(range1, range2)\n\nDetermine whether two ranges are equivalent.\n\nReturns\n\nnon-zero if the ranges are the same, zero if they differ.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_equalTypes-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_equalTypes","text":"clang_equalTypes(A, B)\n\nDetermine whether two CXTypes represent the same type.\n\nReturns\n\nnon-zero if the CXTypes represent the same type and zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_findIncludesInFile-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_findIncludesInFile","text":"clang_findIncludesInFile(TU, file, visitor)\n\nFind #import/#include directives in a specific file.\n\nParameters\n\nTU: translation unit containing the file to query.\nfile: to search for #import/#include directives.\nvisitor: callback that will receive pairs of CXCursor/CXSourceRange for each directive found.\n\nReturns\n\none of the CXResult enumerators.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_findReferencesInFile-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_findReferencesInFile","text":"clang_findReferencesInFile(cursor, file, visitor)\n\nFind references of a declaration in a specific file.\n\nParameters\n\ncursor: pointing to a declaration or a reference of one.\nfile: to search for references.\nvisitor: callback that will receive pairs of CXCursor/CXSourceRange for each reference found. The CXSourceRange will point inside the file; if the reference is inside a macro (and not a macro argument) the CXSourceRange will be invalid.\n\nReturns\n\none of the CXResult enumerators.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_formatDiagnostic-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_formatDiagnostic","text":"clang_formatDiagnostic(Diagnostic, Options)\n\nFormat the given diagnostic in a manner that is suitable for display.\n\nThis routine will format the given diagnostic to a string, rendering the diagnostic according to the various options given. The clang_defaultDiagnosticDisplayOptions() function returns the set of options that most closely mimics the behavior of the clang compiler.\n\nParameters\n\nDiagnostic: The diagnostic to print.\nOptions: A set of options that control the diagnostic display, created by combining CXDiagnosticDisplayOptions values.\n\nReturns\n\nA new string containing for formatted diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_free-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_free","text":"clang_free(buffer)\n\nfree memory allocated by libclang, such as the buffer returned by CXVirtualFileOverlay() or clang_ModuleMapDescriptor_writeToBuffer().\n\nParameters\n\nbuffer: memory pointer to free.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getAddressSpace-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getAddressSpace","text":"clang_getAddressSpace(T)\n\nReturns the address space of the given type.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getAllSkippedRanges-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getAllSkippedRanges","text":"clang_getAllSkippedRanges(tu)\n\nRetrieve all ranges from all files that were skipped by the preprocessor.\n\nThe preprocessor will skip lines when they are surrounded by an if/ifdef/ifndef directive whose condition does not evaluate to true.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getArgType-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getArgType","text":"clang_getArgType(T, i)\n\nRetrieve the type of a parameter of a function type.\n\nIf a non-function type is passed in or the function does not have enough parameters, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getArrayElementType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getArrayElementType","text":"clang_getArrayElementType(T)\n\nReturn the element type of an array type.\n\nIf a non-array type is passed in, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getArraySize-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getArraySize","text":"clang_getArraySize(T)\n\nReturn the array size of a constant array.\n\nIf a non-array type is passed in, -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getBuildSessionTimestamp-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getBuildSessionTimestamp","text":"clang_getBuildSessionTimestamp()\n\nReturn the timestamp for use with Clang's -fbuild-session-timestamp= option.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCString-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCString","text":"clang_getCString(string)\n\nRetrieve the character data associated with the given string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCXTUResourceUsage-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCXTUResourceUsage","text":"clang_getCXTUResourceUsage(TU)\n\nReturn the memory usage of a translation unit. This object should be released with clang_disposeCXTUResourceUsage().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCXXAccessSpecifier-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCXXAccessSpecifier","text":"clang_getCXXAccessSpecifier(arg1)\n\nReturns the access control level for the referenced object.\n\nIf the cursor refers to a C++ declaration, its access control level within its parent scope is returned. Otherwise, if the cursor refers to a base specifier or access specifier, the specifier itself is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCanonicalCursor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCanonicalCursor","text":"clang_getCanonicalCursor(arg1)\n\nRetrieve the canonical cursor corresponding to the given cursor.\n\nIn the C family of languages, many kinds of entities can be declared several times within a single translation unit. For example, a structure type can be forward-declared (possibly multiple times) and later defined:\n\n struct X;\n struct X;\n struct X {\n   int member;\n };\n\nThe declarations and the definition of X are represented by three different cursors, all of which are declarations of the same underlying entity. One of these cursor is considered the \"canonical\" cursor, which is effectively the representative for the underlying entity. One can determine if two cursors are declarations of the same underlying entity by comparing their canonical cursors.\n\nReturns\n\nThe canonical cursor for the entity referred to by the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCanonicalType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCanonicalType","text":"clang_getCanonicalType(T)\n\nReturn the canonical type for a CXType.\n\nClang's type system explicitly models typedefs and all the ways a specific type can be represented. The canonical type is the underlying type with all the \"sugar\" removed. For example, if 'T' is a typedef for 'int', the canonical type for 'T' would be 'int'.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getChildDiagnostics-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getChildDiagnostics","text":"clang_getChildDiagnostics(D)\n\nRetrieve the child diagnostics of a CXDiagnostic.\n\nThis CXDiagnosticSet does not need to be released by clang_disposeDiagnosticSet.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getClangVersion-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getClangVersion","text":"clang_getClangVersion()\n\nReturn a version string, suitable for showing to a user, but not intended to be parsed (the format is not guaranteed to be stable).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionAnnotation-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionAnnotation","text":"clang_getCompletionAnnotation(completion_string, annotation_number)\n\nRetrieve the annotation associated with the given completion string.\n\nParameters\n\ncompletion_string: the completion string to query.\nannotation_number: the 0-based index of the annotation of the completion string.\n\nReturns\n\nannotation string associated with the completion at index annotation_number, or a NULL string if that annotation is not available.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionAvailability-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionAvailability","text":"clang_getCompletionAvailability(completion_string)\n\nDetermine the availability of the entity that this code-completion string refers to.\n\nParameters\n\ncompletion_string: The completion string to query.\n\nReturns\n\nThe availability of the completion string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionBriefComment-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionBriefComment","text":"clang_getCompletionBriefComment(completion_string)\n\nRetrieve the brief documentation comment attached to the declaration that corresponds to the given completion string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionChunkCompletionString-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionChunkCompletionString","text":"clang_getCompletionChunkCompletionString(completion_string, chunk_number)\n\nRetrieve the completion string associated with a particular chunk within a completion string.\n\nParameters\n\ncompletion_string: the completion string to query.\nchunk_number: the 0-based index of the chunk in the completion string.\n\nReturns\n\nthe completion string associated with the chunk at index chunk_number.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionChunkKind-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionChunkKind","text":"clang_getCompletionChunkKind(completion_string, chunk_number)\n\nDetermine the kind of a particular chunk within a completion string.\n\nParameters\n\ncompletion_string: the completion string to query.\nchunk_number: the 0-based index of the chunk in the completion string.\n\nReturns\n\nthe kind of the chunk at the index chunk_number.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionChunkText-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionChunkText","text":"clang_getCompletionChunkText(completion_string, chunk_number)\n\nRetrieve the text associated with a particular chunk within a completion string.\n\nParameters\n\ncompletion_string: the completion string to query.\nchunk_number: the 0-based index of the chunk in the completion string.\n\nReturns\n\nthe text associated with the chunk at index chunk_number.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionFixIt-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionFixIt","text":"clang_getCompletionFixIt(results, completion_index, fixit_index, replacement_range)\n\nFix-its that must be applied before inserting the text for the corresponding completion.\n\nBy default, clang_codeCompleteAt() only returns completions with empty fix-its. Extra completions with non-empty fix-its should be explicitly requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n\nFor the clients to be able to compute position of the cursor after applying fix-its, the following conditions are guaranteed to hold for replacement_range of the stored fix-its: - Ranges in the fix-its are guaranteed to never contain the completion point (or identifier under completion point, if any) inside them, except at the start or at the end of the range. - If a fix-it range starts or ends with completion point (or starts or ends after the identifier under completion point), it will contain at least one character. It allows to unambiguously recompute completion point after applying the fix-it.\n\nThe intuition is that provided fix-its change code around the identifier we complete, but are not allowed to touch the identifier itself or the completion point. One example of completions with corrections are the ones replacing '.' with '->' and vice versa:\n\nstd::unique_ptr<std::vector<int>> vec_ptr; In 'vec_ptr.^', one of the completions is 'push_back', it requires replacing '.' with '->'. In 'vec_ptr->^', one of the completions is 'release', it requires replacing '->' with '.'.\n\nParameters\n\nresults: The structure keeping all completion results\ncompletion_index: The index of the completion\nfixit_index: The index of the fix-it for the completion at completion_index\nreplacement_range: The fix-it range that must be replaced before the completion at completion_index can be applied\n\nReturns\n\nThe fix-it string that must replace the code at replacement_range before the completion at completion_index can be applied\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionNumAnnotations-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionNumAnnotations","text":"clang_getCompletionNumAnnotations(completion_string)\n\nRetrieve the number of annotations associated with the given completion string.\n\nParameters\n\ncompletion_string: the completion string to query.\n\nReturns\n\nthe number of annotations associated with the given completion string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionNumFixIts-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionNumFixIts","text":"clang_getCompletionNumFixIts(results, completion_index)\n\nRetrieve the number of fix-its for the given completion index.\n\nCalling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts option was set.\n\nParameters\n\nresults: The structure keeping all completion results\ncompletion_index: The index of the completion\n\nReturns\n\nThe number of fix-its which must be applied before the completion at completion_index can be applied\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionParent-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionParent","text":"clang_getCompletionParent(completion_string, kind)\n\nRetrieve the parent context of the given completion string.\n\nThe parent context of a completion string is the semantic parent of the declaration (if any) that the code completion represents. For example, a code completion for an Objective-C method would have the method's class or protocol as its context.\n\nParameters\n\ncompletion_string: The code completion string whose parent is being queried.\nkind: DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n\nReturns\n\nThe name of the completion parent, e.g., \"NSObject\" if the completion string represents a method in the NSObject class.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCompletionPriority-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCompletionPriority","text":"clang_getCompletionPriority(completion_string)\n\nDetermine the priority of this code completion.\n\nThe priority of a code completion indicates how likely it is that this particular completion is the completion that the user will select. The priority is selected by various internal heuristics.\n\nParameters\n\ncompletion_string: The completion string to query.\n\nReturns\n\nThe priority of this completion string. Smaller values indicate higher-priority (more likely) completions.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursor-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursor","text":"clang_getCursor(arg1, arg2)\n\nMap a source location to the cursor that describes the entity at that location in the source code.\n\nclang_getCursor() maps an arbitrary source location within a translation unit down to the most specific cursor that describes the entity at that location. For example, given an expression x + y, invoking clang_getCursor() with a source location pointing to \"x\" will return the cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor() will return a cursor referring to the \"+\" expression.\n\nReturns\n\na cursor representing the entity at the given source location, or a NULL cursor if no such entity can be found.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorAvailability-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorAvailability","text":"clang_getCursorAvailability(cursor)\n\nDetermine the availability of the entity that this cursor refers to, taking the current target platform into account.\n\nParameters\n\ncursor: The cursor to query.\n\nReturns\n\nThe availability of the cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorCompletionString-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorCompletionString","text":"clang_getCursorCompletionString(cursor)\n\nRetrieve a completion string for an arbitrary declaration or macro definition cursor.\n\nParameters\n\ncursor: The cursor to query.\n\nReturns\n\nA non-context-sensitive completion string for declaration and macro definition cursors, or NULL for other kinds of cursors.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorDefinition-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorDefinition","text":"clang_getCursorDefinition(arg1)\n\nFor a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity.\n\nSome entities can be declared multiple times within a translation unit, but only one of those declarations can also be a definition. For example, given:\n\n  int f(int, int);\n  int g(int x, int y) { return f(x, y); }\n  int f(int a, int b) { return a + b; }\n  int f(int, int);\n\nthere are three declarations of the function \"f\", but only the second one is a definition. The clang_getCursorDefinition() function will take any cursor pointing to a declaration of \"f\" (the first or fourth lines of the example) or a cursor referenced that uses \"f\" (the call to \"f' inside \"g\") and will return a declaration cursor pointing to the definition (the second \"f\" declaration).\n\nIf given a cursor for which there is no corresponding definition, e.g., because there is no definition of that entity within this translation unit, returns a NULL cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorDisplayName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorDisplayName","text":"clang_getCursorDisplayName(arg1)\n\nRetrieve the display name for the entity referenced by this cursor.\n\nThe display name contains extra information that helps identify the cursor, such as the parameters of a function or template or the arguments of a class template specialization.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorExceptionSpecificationType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorExceptionSpecificationType","text":"clang_getCursorExceptionSpecificationType(C)\n\nRetrieve the exception specification type associated with a given cursor. This is a value of type CXCursor_ExceptionSpecificationKind.\n\nThis only returns a valid result if the cursor refers to a function or method.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorExtent-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorExtent","text":"clang_getCursorExtent(arg1)\n\nRetrieve the physical extent of the source construct referenced by the given cursor.\n\nThe extent of a cursor starts with the file/line/column pointing at the first character within the source construct that the cursor refers to and ends with the last character within that source construct. For a declaration, the extent covers the declaration itself. For a reference, the extent covers the location of the reference (e.g., where the referenced entity was actually used).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorKind","text":"clang_getCursorKind(arg1)\n\nRetrieve the kind of the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorKindSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorKindSpelling","text":"clang_getCursorKindSpelling(Kind)\n\nCINDEX_DEBUG Debugging facilities\n\nThese routines are used for testing and debugging, only, and should not be relied upon.\n\n@{\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorLanguage-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorLanguage","text":"clang_getCursorLanguage(cursor)\n\nDetermine the \"language\" of the entity referred to by a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorLexicalParent-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorLexicalParent","text":"clang_getCursorLexicalParent(cursor)\n\nDetermine the lexical parent of the given cursor.\n\nThe lexical parent of a cursor is the cursor in which the given cursor was actually written. For many declarations, the lexical and semantic parents are equivalent (the semantic parent is returned by clang_getCursorSemanticParent()). They diverge when declarations or definitions are provided out-of-line. For example:\n\n class C {\n  void f();\n };\n void C::f() { }\n\nIn the out-of-line definition of C::f, the semantic parent is the class C, of which this function is a member. The lexical parent is the place where the declaration actually occurs in the source code; in this case, the definition occurs in the translation unit. In general, the lexical parent for a given entity can change without affecting the semantics of the program, and the lexical parent of different declarations of the same entity may be different. Changing the semantic parent of a declaration, on the other hand, can have a major impact on semantics, and redeclarations of a particular entity should all have the same semantic context.\n\nIn the example above, both declarations of C::f have C as their semantic context, while the lexical context of the first C::f is C and the lexical context of the second C::f is the translation unit.\n\nFor declarations written in the global scope, the lexical parent is the translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorLinkage-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorLinkage","text":"clang_getCursorLinkage(cursor)\n\nDetermine the linkage of the entity referred to by a given cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorLocation-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorLocation","text":"clang_getCursorLocation(arg1)\n\nRetrieve the physical location of the source constructor referenced by the given cursor.\n\nThe location of a declaration is typically the location of the name of that declaration, where the name of that declaration would occur if it is unnamed, or some keyword that introduces that particular declaration. The location of a reference is where that reference occurs within the source code.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorPlatformAvailability-NTuple{7, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorPlatformAvailability","text":"clang_getCursorPlatformAvailability(cursor, always_deprecated, deprecated_message, always_unavailable, unavailable_message, availability, availability_size)\n\nDetermine the availability of the entity that this cursor refers to on any platforms for which availability information is known.\n\nNote that the client is responsible for calling clang_disposeCXPlatformAvailability to free each of the platform-availability structures returned. There are min(N, availability_size) such structures.\n\nParameters\n\ncursor: The cursor to query.\nalways_deprecated: If non-NULL, will be set to indicate whether the entity is deprecated on all platforms.\ndeprecated_message: If non-NULL, will be set to the message text provided along with the unconditional deprecation of this entity. The client is responsible for deallocating this string.\nalways_unavailable: If non-NULL, will be set to indicate whether the entity is unavailable on all platforms.\nunavailable_message: If non-NULL, will be set to the message text provided along with the unconditional unavailability of this entity. The client is responsible for deallocating this string.\navailability: If non-NULL, an array of CXPlatformAvailability instances that will be populated with platform availability information, up to either the number of platforms for which availability information is available (as returned by this function) or availability_size, whichever is smaller.\navailability_size: The number of elements available in the availability array.\n\nReturns\n\nThe number of platforms (N) for which availability information is available (which is unrelated to availability_size).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorPrettyPrinted-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorPrettyPrinted","text":"clang_getCursorPrettyPrinted(Cursor, Policy)\n\nPretty print declarations.\n\nParameters\n\nCursor: The cursor representing a declaration.\nPolicy: The policy to control the entities being printed. If NULL, a default policy is used.\n\nReturns\n\nThe pretty printed declaration or the empty string for other cursors.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorPrintingPolicy-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorPrintingPolicy","text":"clang_getCursorPrintingPolicy(arg1)\n\nRetrieve the default policy for the cursor.\n\nThe policy should be released after use with clang_PrintingPolicy_dispose.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorReferenceNameRange-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorReferenceNameRange","text":"clang_getCursorReferenceNameRange(C, NameFlags, PieceIndex)\n\nGiven a cursor that references something else, return the source range covering that reference.\n\nParameters\n\nC: A cursor pointing to a member reference, a declaration reference, or an operator call.\nNameFlags: A bitset with three independent flags: CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and CXNameRange_WantSinglePiece.\nPieceIndex: For contiguous names or when passing the flag CXNameRange_WantSinglePiece, only one piece with index 0 is available. When the CXNameRange_WantSinglePiece flag is not passed for a non-contiguous names, this index can be used to retrieve the individual pieces of the name. See also CXNameRange_WantSinglePiece.\n\nReturns\n\nThe piece of the name pointed to by the given cursor. If there is no name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorReferenced-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorReferenced","text":"clang_getCursorReferenced(arg1)\n\nFor a cursor that is a reference, retrieve a cursor representing the entity that it references.\n\nReference cursors refer to other entities in the AST. For example, an Objective-C superclass reference cursor refers to an Objective-C class. This function produces the cursor for the Objective-C class from the cursor for the superclass reference. If the input cursor is a declaration or definition, it returns that declaration or definition unchanged. Otherwise, returns the NULL cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorResultType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorResultType","text":"clang_getCursorResultType(C)\n\nRetrieve the return type associated with a given cursor.\n\nThis only returns a valid type if the cursor refers to a function or method.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorSemanticParent-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorSemanticParent","text":"clang_getCursorSemanticParent(cursor)\n\nDetermine the semantic parent of the given cursor.\n\nThe semantic parent of a cursor is the cursor that semantically contains the given cursor. For many declarations, the lexical and semantic parents are equivalent (the lexical parent is returned by clang_getCursorLexicalParent()). They diverge when declarations or definitions are provided out-of-line. For example:\n\n class C {\n  void f();\n };\n void C::f() { }\n\nIn the out-of-line definition of C::f, the semantic parent is the class C, of which this function is a member. The lexical parent is the place where the declaration actually occurs in the source code; in this case, the definition occurs in the translation unit. In general, the lexical parent for a given entity can change without affecting the semantics of the program, and the lexical parent of different declarations of the same entity may be different. Changing the semantic parent of a declaration, on the other hand, can have a major impact on semantics, and redeclarations of a particular entity should all have the same semantic context.\n\nIn the example above, both declarations of C::f have C as their semantic context, while the lexical context of the first C::f is C and the lexical context of the second C::f is the translation unit.\n\nFor global declarations, the semantic parent is the translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorSpelling","text":"clang_getCursorSpelling(arg1)\n\nRetrieve a name for the entity referenced by this cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorTLSKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorTLSKind","text":"clang_getCursorTLSKind(cursor)\n\nDetermine the \"thread-local storage (TLS) kind\" of the declaration referred to by a cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorType","text":"clang_getCursorType(C)\n\nRetrieve the type of a CXCursor (if any).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorUSR-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorUSR","text":"clang_getCursorUSR(arg1)\n\nRetrieve a Unified Symbol Resolution (USR) for the entity referenced by the given cursor.\n\nA Unified Symbol Resolution (USR) is a string that identifies a particular entity (function, class, variable, etc.) within a program. USRs can be compared across translation units to determine, e.g., when references in one translation refer to an entity defined in another translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getCursorVisibility-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getCursorVisibility","text":"clang_getCursorVisibility(cursor)\n\nDescribe the visibility of the entity referred to by a cursor.\n\nThis returns the default visibility if not explicitly specified by a visibility attribute. The default visibility may be changed by commandline arguments.\n\nParameters\n\ncursor: The cursor to query.\n\nReturns\n\nThe visibility of the cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDeclObjCTypeEncoding-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDeclObjCTypeEncoding","text":"clang_getDeclObjCTypeEncoding(C)\n\nReturns the Objective-C type encoding for the specified declaration.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnostic-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnostic","text":"clang_getDiagnostic(Unit, Index)\n\nRetrieve a diagnostic associated with the given translation unit.\n\nParameters\n\nUnit: the translation unit to query.\nIndex: the zero-based diagnostic number to retrieve.\n\nReturns\n\nthe requested diagnostic. This diagnostic must be freed via a call to clang_disposeDiagnostic().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticCategory-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticCategory","text":"clang_getDiagnosticCategory(arg1)\n\nRetrieve the category number for this diagnostic.\n\nDiagnostics can be categorized into groups along with other, related diagnostics (e.g., diagnostics under the same warning flag). This routine retrieves the category number for the given diagnostic.\n\nReturns\n\nThe number of the category that contains this diagnostic, or zero if this diagnostic is uncategorized.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticCategoryName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticCategoryName","text":"clang_getDiagnosticCategoryName(Category)\n\nRetrieve the name of a particular diagnostic category. This is now deprecated. Use clang_getDiagnosticCategoryText() instead.\n\nParameters\n\nCategory: A diagnostic category number, as returned by clang_getDiagnosticCategory().\n\nReturns\n\nThe name of the given diagnostic category.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticCategoryText-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticCategoryText","text":"clang_getDiagnosticCategoryText(arg1)\n\nRetrieve the diagnostic category text for a given diagnostic.\n\nReturns\n\nThe text of the given diagnostic category.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticFixIt-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticFixIt","text":"clang_getDiagnosticFixIt(Diagnostic, FixIt, ReplacementRange)\n\nRetrieve the replacement information for a given fix-it.\n\nFix-its are described in terms of a source range whose contents should be replaced by a string. This approach generalizes over three kinds of operations: removal of source code (the range covers the code to be removed and the replacement string is empty), replacement of source code (the range covers the code to be replaced and the replacement string provides the new code), and insertion (both the start and end of the range point at the insertion location, and the replacement string provides the text to insert).\n\nParameters\n\nDiagnostic: The diagnostic whose fix-its are being queried.\nFixIt: The zero-based index of the fix-it.\nReplacementRange: The source range whose contents will be replaced with the returned replacement string. Note that source ranges are half-open ranges [a, b), so the source code should be replaced from a and up to (but not including) b.\n\nReturns\n\nA string containing text that should be replace the source code indicated by the ReplacementRange.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticInSet-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticInSet","text":"clang_getDiagnosticInSet(Diags, Index)\n\nRetrieve a diagnostic associated with the given CXDiagnosticSet.\n\nParameters\n\nDiags: the CXDiagnosticSet to query.\nIndex: the zero-based diagnostic number to retrieve.\n\nReturns\n\nthe requested diagnostic. This diagnostic must be freed via a call to clang_disposeDiagnostic().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticLocation-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticLocation","text":"clang_getDiagnosticLocation(arg1)\n\nRetrieve the source location of the given diagnostic.\n\nThis location is where Clang would print the caret ('^') when displaying the diagnostic on the command line.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticNumFixIts-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticNumFixIts","text":"clang_getDiagnosticNumFixIts(Diagnostic)\n\nDetermine the number of fix-it hints associated with the given diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticNumRanges-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticNumRanges","text":"clang_getDiagnosticNumRanges(arg1)\n\nDetermine the number of source ranges associated with the given diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticOption-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticOption","text":"clang_getDiagnosticOption(Diag, Disable)\n\nRetrieve the name of the command-line option that enabled this diagnostic.\n\nParameters\n\nDiag: The diagnostic to be queried.\nDisable: If non-NULL, will be set to the option that disables this diagnostic (if any).\n\nReturns\n\nA string that contains the command-line option used to enable this warning, such as \"-Wconversion\" or \"-pedantic\".\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticRange-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticRange","text":"clang_getDiagnosticRange(Diagnostic, Range)\n\nRetrieve a source range associated with the diagnostic.\n\nA diagnostic's source ranges highlight important elements in the source code. On the command line, Clang displays source ranges by underlining them with '~' characters.\n\nParameters\n\nDiagnostic: the diagnostic whose range is being extracted.\nRange: the zero-based index specifying which range to\n\nReturns\n\nthe requested source range.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticSetFromTU-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticSetFromTU","text":"clang_getDiagnosticSetFromTU(Unit)\n\nRetrieve the complete set of diagnostics associated with a translation unit.\n\nParameters\n\nUnit: the translation unit to query.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticSeverity-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticSeverity","text":"clang_getDiagnosticSeverity(arg1)\n\nDetermine the severity of the given diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getDiagnosticSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getDiagnosticSpelling","text":"clang_getDiagnosticSpelling(arg1)\n\nRetrieve the text of the given diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getElementType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getElementType","text":"clang_getElementType(T)\n\nReturn the element type of an array, complex, or vector type.\n\nIf a type is passed in that is not an array, complex, or vector type, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getEnumConstantDeclUnsignedValue-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getEnumConstantDeclUnsignedValue","text":"clang_getEnumConstantDeclUnsignedValue(C)\n\nRetrieve the integer value of an enum constant declaration as an unsigned long long.\n\nIf the cursor does not reference an enum constant declaration, ULLONG_MAX is returned. Since this is also potentially a valid constant value, the kind of the cursor must be verified before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getEnumConstantDeclValue-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getEnumConstantDeclValue","text":"clang_getEnumConstantDeclValue(C)\n\nRetrieve the integer value of an enum constant declaration as a signed long long.\n\nIf the cursor does not reference an enum constant declaration, LLONG_MIN is returned. Since this is also potentially a valid constant value, the kind of the cursor must be verified before calling this function.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getEnumDeclIntegerType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getEnumDeclIntegerType","text":"clang_getEnumDeclIntegerType(C)\n\nRetrieve the integer type of an enum declaration.\n\nIf the cursor does not reference an enum declaration, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getExceptionSpecificationType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getExceptionSpecificationType","text":"clang_getExceptionSpecificationType(T)\n\nRetrieve the exception specification type associated with a function type. This is a value of type CXCursor_ExceptionSpecificationKind.\n\nIf a non-function type is passed in, an error code of -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getExpansionLocation-NTuple{5, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getExpansionLocation","text":"clang_getExpansionLocation(location, file, line, column, offset)\n\nRetrieve the file, line, column, and offset represented by the given source location.\n\nIf the location refers into a macro expansion, retrieves the location of the macro expansion.\n\nParameters\n\nlocation: the location within a source file that will be decomposed into its parts.\nfile: [out] if non-NULL, will be set to the file to which the given source location points.\nline: [out] if non-NULL, will be set to the line to which the given source location points.\ncolumn: [out] if non-NULL, will be set to the column to which the given source location points.\noffset: [out] if non-NULL, will be set to the offset into the buffer to which the given source location points.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFieldDeclBitWidth-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFieldDeclBitWidth","text":"clang_getFieldDeclBitWidth(C)\n\nRetrieve the bit width of a bit field declaration as an integer.\n\nIf a cursor that is not a bit field declaration is passed in, -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFile-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFile","text":"clang_getFile(tu, file_name)\n\nRetrieve a file handle within the given translation unit.\n\nParameters\n\ntu: the translation unit\nfile_name: the name of the file.\n\nReturns\n\nthe file handle for the named file in the translation unit tu, or a NULL file handle if the file was not a part of this translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFileContents-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFileContents","text":"clang_getFileContents(tu, file, size)\n\nRetrieve the buffer associated with the given file.\n\nParameters\n\ntu: the translation unit\nfile: the file for which to retrieve the buffer.\nsize: [out] if non-NULL, will be set to the size of the buffer.\n\nReturns\n\na pointer to the buffer in memory that holds the contents of file, or a NULL pointer when the file is not loaded.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFileLocation-NTuple{5, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFileLocation","text":"clang_getFileLocation(location, file, line, column, offset)\n\nRetrieve the file, line, column, and offset represented by the given source location.\n\nIf the location refers into a macro expansion, return where the macro was expanded or where the macro argument was written, if the location points at a macro argument.\n\nParameters\n\nlocation: the location within a source file that will be decomposed into its parts.\nfile: [out] if non-NULL, will be set to the file to which the given source location points.\nline: [out] if non-NULL, will be set to the line to which the given source location points.\ncolumn: [out] if non-NULL, will be set to the column to which the given source location points.\noffset: [out] if non-NULL, will be set to the offset into the buffer to which the given source location points.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFileName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFileName","text":"clang_getFileName(SFile)\n\nRetrieve the complete file and path name of the given file.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFileTime-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFileTime","text":"clang_getFileTime(SFile)\n\nRetrieve the last modification time of the given file.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFileUniqueID-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFileUniqueID","text":"clang_getFileUniqueID(file, outID)\n\nRetrieve the unique ID for the given file.\n\nParameters\n\nfile: the file to get the ID for.\noutID: stores the returned CXFileUniqueID.\n\nReturns\n\nIf there was a failure getting the unique ID, returns non-zero, otherwise returns 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getFunctionTypeCallingConv-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getFunctionTypeCallingConv","text":"clang_getFunctionTypeCallingConv(T)\n\nRetrieve the calling convention associated with a function type.\n\nIf a non-function type is passed in, CXCallingConv_Invalid is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getIBOutletCollectionType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getIBOutletCollectionType","text":"clang_getIBOutletCollectionType(arg1)\n\nFor cursors representing an iboutletcollection attribute, this function returns the collection element type.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getIncludedFile-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getIncludedFile","text":"clang_getIncludedFile(cursor)\n\nRetrieve the file that is included by the given inclusion directive cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getInclusions-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getInclusions","text":"clang_getInclusions(tu, visitor, client_data)\n\nVisit the set of preprocessor inclusions in a translation unit. The visitor function is called with the provided data for every included file. This does not include headers included by the PCH file (unless one is inspecting the inclusions in the PCH file itself).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getInstantiationLocation-NTuple{5, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getInstantiationLocation","text":"clang_getInstantiationLocation(location, file, line, column, offset)\n\nLegacy API to retrieve the file, line, column, and offset represented by the given source location.\n\nThis interface has been replaced by the newer interface #clang_getExpansionLocation(). See that interface's documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getLocation-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getLocation","text":"clang_getLocation(tu, file, line, column)\n\nRetrieves the source location associated with a given file/line/column in a particular translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getLocationForOffset-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getLocationForOffset","text":"clang_getLocationForOffset(tu, file, offset)\n\nRetrieves the source location associated with a given character offset in a particular translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getModuleForFile-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getModuleForFile","text":"clang_getModuleForFile(arg1, arg2)\n\nGiven a CXFile header file, return the module that contains it, if one exists.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNullCursor-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNullCursor","text":"clang_getNullCursor()\n\nRetrieve the NULL cursor, which represents no entity.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNullLocation-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNullLocation","text":"clang_getNullLocation()\n\nRetrieve a NULL (invalid) source location.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNullRange-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNullRange","text":"clang_getNullRange()\n\nRetrieve a NULL (invalid) source range.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumArgTypes-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumArgTypes","text":"clang_getNumArgTypes(T)\n\nRetrieve the number of non-variadic parameters associated with a function type.\n\nIf a non-function type is passed in, -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumCompletionChunks-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumCompletionChunks","text":"clang_getNumCompletionChunks(completion_string)\n\nRetrieve the number of chunks in the given code-completion string.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumDiagnostics-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumDiagnostics","text":"clang_getNumDiagnostics(Unit)\n\nDetermine the number of diagnostics produced for the given translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumDiagnosticsInSet-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumDiagnosticsInSet","text":"clang_getNumDiagnosticsInSet(Diags)\n\nDetermine the number of diagnostics in a CXDiagnosticSet.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumElements-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumElements","text":"clang_getNumElements(T)\n\nReturn the number of elements of an array or vector type.\n\nIf a type is passed in that is not an array or vector type, -1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getNumOverloadedDecls-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getNumOverloadedDecls","text":"clang_getNumOverloadedDecls(cursor)\n\nDetermine the number of overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.\n\nParameters\n\ncursor: The cursor whose overloaded declarations are being queried.\n\nReturns\n\nThe number of overloaded declarations referenced by cursor. If it is not a CXCursor_OverloadedDeclRef cursor, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getOverloadedDecl-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getOverloadedDecl","text":"clang_getOverloadedDecl(cursor, index)\n\nRetrieve a cursor for one of the overloaded declarations referenced by a CXCursor_OverloadedDeclRef cursor.\n\nParameters\n\ncursor: The cursor whose overloaded declarations are being queried.\nindex: The zero-based index into the set of overloaded declarations in the cursor.\n\nReturns\n\nA cursor representing the declaration referenced by the given cursor at the specified index. If the cursor does not have an associated set of overloaded declarations, or if the index is out of bounds, returns clang_getNullCursor();\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getOverriddenCursors-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getOverriddenCursors","text":"clang_getOverriddenCursors(cursor, overridden, num_overridden)\n\nDetermine the set of methods that are overridden by the given method.\n\nIn both Objective-C and C++, a method (aka virtual member function, in C++) can override a virtual method in a base class. For Objective-C, a method is said to override any method in the class's base class, its protocols, or its categories' protocols, that has the same selector and is of the same kind (class or instance). If no such method exists, the search continues to the class's superclass, its protocols, and its categories, and so on. A method from an Objective-C implementation is considered to override the same methods as its corresponding method in the interface.\n\nFor C++, a virtual member function overrides any virtual member function with the same signature that occurs in its base classes. With multiple inheritance, a virtual member function can override several virtual member functions coming from different base classes.\n\nIn all cases, this function determines the immediate overridden method, rather than all of the overridden methods. For example, if a method is originally declared in a class A, then overridden in B (which in inherits from A) and also in C (which inherited from B), then the only overridden method returned from this function when invoked on C's method will be B's method. The client may then invoke this function again, given the previously-found overridden methods, to map out the complete method-override set.\n\nParameters\n\ncursor: A cursor representing an Objective-C or C++ method. This routine will compute the set of methods that this method overrides.\noverridden: A pointer whose pointee will be replaced with a pointer to an array of cursors, representing the set of overridden methods. If there are no overridden methods, the pointee will be set to NULL. The pointee must be freed via a call to clang_disposeOverriddenCursors().\nnum_overridden: A pointer to the number of overridden functions, will be set to the number of overridden functions in the array pointed to by overridden.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getPointeeType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getPointeeType","text":"clang_getPointeeType(T)\n\nFor pointer types, returns the type of the pointee.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getPresumedLocation-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getPresumedLocation","text":"clang_getPresumedLocation(location, filename, line, column)\n\nRetrieve the file, line and column represented by the given source location, as specified in a # line directive.\n\nExample: given the following source code in a file somefile.c\n\n #123 \"dummy.c\" 1\n static int func(void)\n {\n     return 0;\n }\n\nthe location information returned by this function would be\n\nFile: dummy.c Line: 124 Column: 12\n\nwhereas clang_getExpansionLocation would have returned\n\nFile: somefile.c Line: 3 Column: 12\n\nParameters\n\nlocation: the location within a source file that will be decomposed into its parts.\nfilename: [out] if non-NULL, will be set to the filename of the source location. Note that filenames returned will be for \"virtual\" files, which don't necessarily exist on the machine running clang - e.g. when parsing preprocessed output obtained from a different environment. If a non-NULL value is passed in, remember to dispose of the returned value using clang_disposeString() once you've finished with it. For an invalid source location, an empty string is returned.\nline: [out] if non-NULL, will be set to the line number of the source location. For an invalid source location, zero is returned.\ncolumn: [out] if non-NULL, will be set to the column number of the source location. For an invalid source location, zero is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getRange-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getRange","text":"clang_getRange(_begin, _end)\n\nRetrieve a source range given the beginning and ending source locations.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getRangeEnd-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getRangeEnd","text":"clang_getRangeEnd(range)\n\nRetrieve a source location representing the last character within a source range.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getRangeStart-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getRangeStart","text":"clang_getRangeStart(range)\n\nRetrieve a source location representing the first character within a source range.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getRemappings-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getRemappings","text":"clang_getRemappings(path)\n\nRetrieve a remapping.\n\nParameters\n\npath: the path that contains metadata about remappings.\n\nReturns\n\nthe requested remapping. This remapping must be freed via a call to clang_remap_dispose(). Can return NULL if an error occurred.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getRemappingsFromFileList-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getRemappingsFromFileList","text":"clang_getRemappingsFromFileList(filePaths, numFiles)\n\nRetrieve a remapping.\n\nParameters\n\nfilePaths: pointer to an array of file paths containing remapping info.\nnumFiles: number of file paths.\n\nReturns\n\nthe requested remapping. This remapping must be freed via a call to clang_remap_dispose(). Can return NULL if an error occurred.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getResultType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getResultType","text":"clang_getResultType(T)\n\nRetrieve the return type associated with a function type.\n\nIf a non-function type is passed in, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getSkippedRanges-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getSkippedRanges","text":"clang_getSkippedRanges(tu, file)\n\nRetrieve all ranges that were skipped by the preprocessor.\n\nThe preprocessor will skip lines when they are surrounded by an if/ifdef/ifndef directive whose condition does not evaluate to true.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getSpecializedCursorTemplate-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getSpecializedCursorTemplate","text":"clang_getSpecializedCursorTemplate(C)\n\nGiven a cursor that may represent a specialization or instantiation of a template, retrieve the cursor that represents the template that it specializes or from which it was instantiated.\n\nThis routine determines the template involved both for explicit specializations of templates and for implicit instantiations of the template, both of which are referred to as \"specializations\". For a class template specialization (e.g., std::vector<bool>), this routine will return either the primary template (std::vector) or, if the specialization was instantiated from a class template partial specialization, the class template partial specialization. For a class template partial specialization and a function template specialization (including instantiations), this this routine will return the specialized template.\n\nFor members of a class template (e.g., member functions, member classes, or static data members), returns the specialized or instantiated member. Although not strictly \"templates\" in the C++ language, members of class templates have the same notions of specializations and instantiations that templates do, so this routine treats them similarly.\n\nParameters\n\nC: A cursor that may be a specialization of a template or a member of a template.\n\nReturns\n\nIf the given cursor is a specialization or instantiation of a template or a member thereof, the template or member that it specializes or from which it was instantiated. Otherwise, returns a NULL cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getSpellingLocation-NTuple{5, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getSpellingLocation","text":"clang_getSpellingLocation(location, file, line, column, offset)\n\nRetrieve the file, line, column, and offset represented by the given source location.\n\nIf the location refers into a macro instantiation, return where the location was originally spelled in the source file.\n\nParameters\n\nlocation: the location within a source file that will be decomposed into its parts.\nfile: [out] if non-NULL, will be set to the file to which the given source location points.\nline: [out] if non-NULL, will be set to the line to which the given source location points.\ncolumn: [out] if non-NULL, will be set to the column to which the given source location points.\noffset: [out] if non-NULL, will be set to the offset into the buffer to which the given source location points.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTUResourceUsageName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTUResourceUsageName","text":"clang_getTUResourceUsageName(kind)\n\nReturns the human-readable null-terminated C string that represents the name of the memory category. This string should never be freed.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTemplateCursorKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTemplateCursorKind","text":"clang_getTemplateCursorKind(C)\n\nGiven a cursor that represents a template, determine the cursor kind of the specializations would be generated by instantiating the template.\n\nThis routine can be used to determine what flavor of function template, class template, or class template partial specialization is stored in the cursor. For example, it can describe whether a class template cursor is declared with \"struct\", \"class\" or \"union\".\n\nParameters\n\nC: The cursor to query. This cursor should represent a template declaration.\n\nReturns\n\nThe cursor kind of the specializations that would be generated by instantiating the template C. If C is not a template, returns CXCursor_NoDeclFound.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getToken-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getToken","text":"clang_getToken(TU, Location)\n\nGet the raw lexical token starting with the given location.\n\nParameters\n\nTU: the translation unit whose text is being tokenized.\nLocation: the source location with which the token starts.\n\nReturns\n\nThe token starting with the given location or NULL if no such token exist. The returned pointer must be freed with clang_disposeTokens before the translation unit is destroyed.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTokenExtent-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTokenExtent","text":"clang_getTokenExtent(arg1, arg2)\n\nRetrieve a source range that covers the given token.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTokenKind-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTokenKind","text":"clang_getTokenKind(arg1)\n\nDetermine the kind of the given token.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTokenLocation-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTokenLocation","text":"clang_getTokenLocation(arg1, arg2)\n\nRetrieve the source location of the given token.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTokenSpelling-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTokenSpelling","text":"clang_getTokenSpelling(arg1, arg2)\n\nDetermine the spelling of the given token.\n\nThe spelling of a token is the textual representation of that token, e.g., the text of an identifier or keyword.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTranslationUnitCursor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTranslationUnitCursor","text":"clang_getTranslationUnitCursor(arg1)\n\nRetrieve the cursor that represents the given translation unit.\n\nThe translation unit cursor can be used to start traversing the various declarations within the given translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTranslationUnitSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTranslationUnitSpelling","text":"clang_getTranslationUnitSpelling(CTUnit)\n\nGet the original translation unit source file name.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTranslationUnitTargetInfo-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTranslationUnitTargetInfo","text":"clang_getTranslationUnitTargetInfo(CTUnit)\n\nGet target information for this translation unit.\n\nThe CXTargetInfo object cannot outlive the CXTranslationUnit object.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTypeDeclaration-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTypeDeclaration","text":"clang_getTypeDeclaration(T)\n\nReturn the cursor for the declaration of the given type.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTypeKindSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTypeKindSpelling","text":"clang_getTypeKindSpelling(K)\n\nRetrieve the spelling of a given CXTypeKind.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTypeSpelling-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTypeSpelling","text":"clang_getTypeSpelling(CT)\n\nPretty-print the underlying type using the rules of the language of the translation unit from which it came.\n\nIf the type is invalid, an empty string is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTypedefDeclUnderlyingType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTypedefDeclUnderlyingType","text":"clang_getTypedefDeclUnderlyingType(C)\n\nRetrieve the underlying type of a typedef declaration.\n\nIf the cursor does not reference a typedef declaration, an invalid type is returned.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_getTypedefName-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_getTypedefName","text":"clang_getTypedefName(CT)\n\nReturns the typedef name of the given type.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_hashCursor-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_hashCursor","text":"clang_hashCursor(arg1)\n\nCompute a hash value for the given cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_indexLoc_getCXSourceLocation-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_indexLoc_getCXSourceLocation","text":"clang_indexLoc_getCXSourceLocation(loc)\n\nRetrieve the CXSourceLocation represented by the given CXIdxLoc.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_indexLoc_getFileLocation-NTuple{6, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_indexLoc_getFileLocation","text":"clang_indexLoc_getFileLocation(loc, indexFile, file, line, column, offset)\n\nRetrieve the CXIdxFile, file, line, column, and offset represented by the given CXIdxLoc.\n\nIf the location refers into a macro expansion, retrieves the location of the macro expansion and if it refers into a macro argument retrieves the location of the argument.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_indexSourceFile-NTuple{12, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_indexSourceFile","text":"clang_indexSourceFile(arg1, client_data, index_callbacks, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, out_TU, TU_options)\n\nIndex the given source file and the translation unit corresponding to that file via callbacks implemented through #IndexerCallbacks.\n\nThe rest of the parameters are the same as #clang_parseTranslationUnit.\n\nParameters\n\nclient_data: pointer data supplied by the client, which will be passed to the invoked callbacks.\nindex_callbacks: Pointer to indexing callbacks that the client implements.\nindex_callbacks_size: Size of #IndexerCallbacks structure that gets passed in index_callbacks.\nindex_options: A bitmask of options that affects how indexing is performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\nout_TU:[out] pointer to store a CXTranslationUnit that can be reused after indexing is finished. Set to NULL if you do not require it.\n\nReturns\n\n0 on success or if there were errors from which the compiler could recover. If there is a failure from which there is no recovery, returns a non-zero CXErrorCode.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_indexSourceFileFullArgv-NTuple{12, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_indexSourceFileFullArgv","text":"clang_indexSourceFileFullArgv(arg1, client_data, index_callbacks, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, out_TU, TU_options)\n\nSame as clang_indexSourceFile but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_indexTranslationUnit-NTuple{6, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_indexTranslationUnit","text":"clang_indexTranslationUnit(arg1, client_data, index_callbacks, index_callbacks_size, index_options, arg6)\n\nIndex the given translation unit via callbacks implemented through #IndexerCallbacks.\n\nThe order of callback invocations is not guaranteed to be the same as when indexing a source file. The high level order will be:\n\n-Preprocessor callbacks invocations -Declaration/reference callbacks invocations -Diagnostic callback invocations\n\nThe parameters are the same as #clang_indexSourceFile.\n\nReturns\n\nIf there is a failure from which there is no recovery, returns non-zero, otherwise returns 0.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_index_getClientContainer-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_index_getClientContainer","text":"clang_index_getClientContainer(arg1)\n\nFor retrieving a custom CXIdxClientContainer attached to a container.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_index_getClientEntity-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_index_getClientEntity","text":"clang_index_getClientEntity(arg1)\n\nFor retrieving a custom CXIdxClientEntity attached to an entity.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_index_setClientContainer-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_index_setClientContainer","text":"clang_index_setClientContainer(arg1, arg2)\n\nFor setting a custom CXIdxClientContainer attached to a container.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_index_setClientEntity-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_index_setClientEntity","text":"clang_index_setClientEntity(arg1, arg2)\n\nFor setting a custom CXIdxClientEntity attached to an entity.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_install_aborting_llvm_fatal_error_handler-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_install_aborting_llvm_fatal_error_handler","text":"clang_install_aborting_llvm_fatal_error_handler()\n\nInstalls error handler that prints error message to stderr and calls abort(). Replaces currently installed error handler (if any).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isAttribute-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isAttribute","text":"clang_isAttribute(arg1)\n\nDetermine whether the given cursor kind represents an attribute.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isConstQualifiedType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isConstQualifiedType","text":"clang_isConstQualifiedType(T)\n\nDetermine whether a CXType has the \"const\" qualifier set, without looking through typedefs that may have added \"const\" at a different level.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isCursorDefinition-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isCursorDefinition","text":"clang_isCursorDefinition(arg1)\n\nDetermine whether the declaration pointed to by this cursor is also a definition of that entity.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isDeclaration-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isDeclaration","text":"clang_isDeclaration(arg1)\n\nDetermine whether the given cursor kind represents a declaration.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isExpression-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isExpression","text":"clang_isExpression(arg1)\n\nDetermine whether the given cursor kind represents an expression.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isFileMultipleIncludeGuarded-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isFileMultipleIncludeGuarded","text":"clang_isFileMultipleIncludeGuarded(tu, file)\n\nDetermine whether the given header is guarded against multiple inclusions, either with the conventional #ifndef/#define/#endif macro guards or with #pragma once.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isFunctionTypeVariadic-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isFunctionTypeVariadic","text":"clang_isFunctionTypeVariadic(T)\n\nReturn 1 if the CXType is a variadic function type, and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isInvalid-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isInvalid","text":"clang_isInvalid(arg1)\n\nDetermine whether the given cursor kind represents an invalid cursor.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isInvalidDeclaration-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isInvalidDeclaration","text":"clang_isInvalidDeclaration(arg1)\n\nDetermine whether the given declaration is invalid.\n\nA declaration is invalid if it could not be parsed successfully.\n\nReturns\n\nnon-zero if the cursor represents a declaration and it is invalid, otherwise NULL.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isPODType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isPODType","text":"clang_isPODType(T)\n\nReturn 1 if the CXType is a POD (plain old data) type, and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isPreprocessing-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isPreprocessing","text":"clang_isPreprocessing(arg1)\n\nDetermine whether the given cursor represents a preprocessing element, such as a preprocessor directive or macro instantiation.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isReference-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isReference","text":"clang_isReference(arg1)\n\nDetermine whether the given cursor kind represents a simple reference.\n\nNote that other kinds of cursors (such as expressions) can also refer to other cursors. Use clang_getCursorReferenced() to determine whether a particular cursor refers to another entity.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isRestrictQualifiedType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isRestrictQualifiedType","text":"clang_isRestrictQualifiedType(T)\n\nDetermine whether a CXType has the \"restrict\" qualifier set, without looking through typedefs that may have added \"restrict\" at a different level.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isStatement-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isStatement","text":"clang_isStatement(arg1)\n\nDetermine whether the given cursor kind represents a statement.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isTranslationUnit-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isTranslationUnit","text":"clang_isTranslationUnit(arg1)\n\nDetermine whether the given cursor kind represents a translation unit.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isUnexposed-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isUnexposed","text":"clang_isUnexposed(arg1)\n\nDetermine whether the given cursor represents a currently unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isVirtualBase-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isVirtualBase","text":"clang_isVirtualBase(arg1)\n\nReturns 1 if the base class specified by the cursor with kind CX_CXXBaseSpecifier is virtual.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_isVolatileQualifiedType-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_isVolatileQualifiedType","text":"clang_isVolatileQualifiedType(T)\n\nDetermine whether a CXType has the \"volatile\" qualifier set, without looking through typedefs that may have added \"volatile\" at a different level.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_loadDiagnostics-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_loadDiagnostics","text":"clang_loadDiagnostics(file, error, errorString)\n\nDeserialize a set of diagnostics from a Clang diagnostics bitcode file.\n\nParameters\n\nfile: The name of the file to deserialize.\nerror: A pointer to a enum value recording if there was a problem deserializing the diagnostics.\nerrorString: A pointer to a CXString for recording the error string if the file was not successfully loaded.\n\nReturns\n\nA loaded CXDiagnosticSet if successful, and NULL otherwise. These diagnostics should be released using clang_disposeDiagnosticSet().\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_parseTranslationUnit-NTuple{7, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_parseTranslationUnit","text":"clang_parseTranslationUnit(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options)\n\nSame as clang_parseTranslationUnit2, but returns the CXTranslationUnit instead of an error code. In case of an error this routine returns a NULL CXTranslationUnit, without further detailed error codes.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_parseTranslationUnit2-NTuple{8, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_parseTranslationUnit2","text":"clang_parseTranslationUnit2(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU)\n\nParse the given source file and the translation unit corresponding to that file.\n\nThis routine is the main entry point for the Clang C API, providing the ability to parse a source file into a translation unit that can then be queried by other functions in the API. This routine accepts a set of command-line arguments so that the compilation can be configured in the same way that the compiler is configured on the command line.\n\nParameters\n\nCIdx: The index object with which the translation unit will be associated.\nsource_filename: The name of the source file to load, or NULL if the source file is included in command_line_args.\ncommand_line_args: The command-line arguments that would be passed to the clang executable if it were being invoked out-of-process. These command-line options will be parsed and will affect how the translation unit is parsed. Note that the following options are ignored: '-c', '-emit-ast', '-fsyntax-only' (which is the default), and '-o <output file>'.\nnum_command_line_args: The number of command-line arguments in command_line_args.\nunsaved_files: the files that have not yet been saved to disk but may be required for parsing, including the contents of those files. The contents and name of these files (as specified by CXUnsavedFile) are copied when necessary, so the client only needs to guarantee their validity until the call to this function returns.\nnum_unsaved_files: the number of unsaved file entries in unsaved_files.\noptions: A bitmask of options that affects how the translation unit is managed but not its compilation. This should be a bitwise OR of the CXTranslationUnit_XXX flags.\nout_TU:[out] A non-NULL pointer to store the created CXTranslationUnit, describing the parsed code and containing any diagnostics produced by the compiler.\n\nReturns\n\nZero on success, otherwise returns an error code.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_parseTranslationUnit2FullArgv-NTuple{8, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_parseTranslationUnit2FullArgv","text":"clang_parseTranslationUnit2FullArgv(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU)\n\nSame as clang_parseTranslationUnit2 but requires a full command line for command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_remap_dispose-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_remap_dispose","text":"clang_remap_dispose(arg1)\n\nDispose the remapping.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_remap_getFilenames-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_remap_getFilenames","text":"clang_remap_getFilenames(arg1, index, original, transformed)\n\nGet the original and the associated filename from the remapping.\n\nParameters\n\noriginal: If non-NULL, will be set to the original filename.\ntransformed: If non-NULL, will be set to the filename that the original is associated with.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_remap_getNumFiles-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_remap_getNumFiles","text":"clang_remap_getNumFiles(arg1)\n\nDetermine the number of remappings.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_reparseTranslationUnit-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_reparseTranslationUnit","text":"clang_reparseTranslationUnit(TU, num_unsaved_files, unsaved_files, options)\n\nReparse the source files that produced this translation unit.\n\nThis routine can be used to re-parse the source files that originally created the given translation unit, for example because those source files have changed (either on disk or as passed via unsaved_files). The source code will be reparsed with the same command-line options as it was originally parsed.\n\nReparsing a translation unit invalidates all cursors and source locations that refer into that translation unit. This makes reparsing a translation unit semantically equivalent to destroying the translation unit and then creating a new translation unit with the same command-line arguments. However, it may be more efficient to reparse a translation unit using this routine.\n\nParameters\n\nTU: The translation unit whose contents will be re-parsed. The translation unit must originally have been built with clang_createTranslationUnitFromSourceFile().\nnum_unsaved_files: The number of unsaved file entries in unsaved_files.\nunsaved_files: The files that have not yet been saved to disk but may be required for parsing, including the contents of those files. The contents and name of these files (as specified by CXUnsavedFile) are copied when necessary, so the client only needs to guarantee their validity until the call to this function returns.\noptions: A bitset of options composed of the flags in CXReparse_Flags. The function clang_defaultReparseOptions() produces a default set of options recommended for most uses, based on the translation unit.\n\nReturns\n\n0 if the sources could be reparsed. A non-zero error code will be returned if reparsing was impossible, such that the translation unit is invalid. In such cases, the only valid call for TU is clang_disposeTranslationUnit(TU). The error codes returned by this routine are described by the CXErrorCode enum.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_saveTranslationUnit-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_saveTranslationUnit","text":"clang_saveTranslationUnit(TU, FileName, options)\n\nSaves a translation unit into a serialized representation of that translation unit on disk.\n\nAny translation unit that was parsed without error can be saved into a file. The translation unit can then be deserialized into a new CXTranslationUnit with clang_createTranslationUnit() or, if it is an incomplete translation unit that corresponds to a header, used as a precompiled header when parsing other translation units.\n\nParameters\n\nTU: The translation unit to save.\nFileName: The file to which the translation unit will be saved.\noptions: A bitmask of options that affects how the translation unit is saved. This should be a bitwise OR of the CXSaveTranslationUnit_XXX flags.\n\nReturns\n\nA value that will match one of the enumerators of the CXSaveError enumeration. Zero (CXSaveError_None) indicates that the translation unit was saved successfully, while a non-zero value indicates that a problem occurred.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_sortCodeCompletionResults-Tuple{Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_sortCodeCompletionResults","text":"clang_sortCodeCompletionResults(Results, NumResults)\n\nSort the code-completion results in case-insensitive alphabetical order.\n\nParameters\n\nResults: The set of results to sort.\nNumResults: The number of results in Results.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_suspendTranslationUnit-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_suspendTranslationUnit","text":"clang_suspendTranslationUnit(arg1)\n\nSuspend a translation unit in order to free memory associated with it.\n\nA suspended translation unit uses significantly less memory but on the other side does not support any other calls than clang_reparseTranslationUnit to resume it or clang_disposeTranslationUnit to dispose it completely.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_toggleCrashRecovery-Tuple{Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_toggleCrashRecovery","text":"clang_toggleCrashRecovery(isEnabled)\n\nEnable/disable crash recovery.\n\nParameters\n\nisEnabled: Flag to indicate if crash recovery is enabled. A non-zero value enables crash recovery, while 0 disables it.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_tokenize-NTuple{4, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_tokenize","text":"clang_tokenize(TU, Range, Tokens, NumTokens)\n\nTokenize the source code described by the given range into raw lexical tokens.\n\nParameters\n\nTU: the translation unit whose text is being tokenized.\nRange: the source range in which text should be tokenized. All of the tokens produced by tokenization will fall within this source range,\nTokens: this pointer will be set to point to the array of tokens that occur within the given source range. The returned pointer must be freed with clang_disposeTokens() before the translation unit is destroyed.\nNumTokens: will be set to the number of tokens in the *Tokens array.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_uninstall_llvm_fatal_error_handler-Tuple{}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_uninstall_llvm_fatal_error_handler","text":"clang_uninstall_llvm_fatal_error_handler()\n\nRemoves currently installed error handler (if any). If no error handler is intalled, the default strategy is to print error message to stderr and call exit(1).\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.clang_visitChildren-Tuple{Any, Any, Any}","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.clang_visitChildren","text":"clang_visitChildren(parent, visitor, client_data)\n\nVisit the children of a particular cursor.\n\nThis function visits all the direct children of the given cursor, invoking the given visitor function with the cursors of each visited child. The traversal may be recursive, if the visitor returns CXChildVisit_Recurse. The traversal may also be ended prematurely, if the visitor returns CXChildVisit_Break.\n\nParameters\n\nparent: the cursor whose child may be visited. All kinds of cursors can be visited, including invalid cursors (which, by definition, have no children).\nvisitor: the visitor function that will be invoked for each child of parent.\nclient_data: pointer data supplied by the client, which will be passed to the visitor each time it is invoked.\n\nReturns\n\na non-zero value if the traversal was terminated prematurely by the visitor returning CXChildVisit_Break.\n\n\n\n\n\n","category":"method"},{"location":"libclang/#Clang.LibClang.CXAvailabilityKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXAvailabilityKind","text":"CXAvailabilityKind\n\nDescribes the availability of a particular entity, which indicates whether the use of this entity will result in a warning or error due to it being deprecated or unavailable.\n\nEnumerator Note\nCXAvailability_Available The entity is available.\nCXAvailability_Deprecated The entity is available, but has been deprecated (and its use is not recommended).\nCXAvailability_NotAvailable The entity is not available; any use of it will be an error.\nCXAvailability_NotAccessible The entity is available, but not accessible; any use of it will be an error.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCallingConv","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCallingConv","text":"CXCallingConv\n\nDescribes the calling convention of a function type\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXChildVisitResult","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXChildVisitResult","text":"CXChildVisitResult\n\nDescribes how the traversal of the children of a particular cursor should proceed after visiting a particular child cursor.\n\nA value of this enumeration type should be returned by each CXCursorVisitor to indicate how clang_visitChildren() proceed.\n\nEnumerator Note\nCXChildVisit_Break Terminates the cursor traversal.\nCXChildVisit_Continue Continues the cursor traversal with the next sibling of the cursor just visited, without visiting its children.\nCXChildVisit_Recurse Recursively traverse the children of this cursor, using the same visitor and client data.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXClientData","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXClientData","text":"Opaque pointer representing client data that will be passed through to various callbacks and visitors.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCodeCompleteResults","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCodeCompleteResults","text":"CXCodeCompleteResults\n\nContains the results of code-completion.\n\nThis data structure contains the results of code completion, as produced by clang_codeCompleteAt(). Its contents must be freed by clang_disposeCodeCompleteResults.\n\nField Note\nResults The code-completion results.\nNumResults The number of code-completion results stored in the Results array.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCodeComplete_Flags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCodeComplete_Flags","text":"CXCodeComplete_Flags\n\nFlags that can be passed to clang_codeCompleteAt() to modify its behavior.\n\nThe enumerators in this enumeration can be bitwise-OR'd together to provide multiple options to clang_codeCompleteAt().\n\nEnumerator Note\nCXCodeComplete_IncludeMacros Whether to include macros within the set of code completions returned.\nCXCodeComplete_IncludeCodePatterns Whether to include code patterns for language constructs within the set of code completions, e.g., for loops.\nCXCodeComplete_IncludeBriefComments Whether to include brief documentation within the set of code completions returned.\nCXCodeComplete_SkipPreamble Whether to speed up completion by omitting top- or namespace-level entities defined in the preamble. There's no guarantee any particular entity is omitted. This may be useful if the headers are indexed externally.\nCXCodeComplete_IncludeCompletionsWithFixIts Whether to include completions with small fix-its, e.g. change '.' to '->' on member access, etc.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXComment","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXComment","text":"CXComment\n\nA parsed comment.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCommentInlineCommandRenderKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCommentInlineCommandRenderKind","text":"CXCommentInlineCommandRenderKind\n\nThe most appropriate rendering mode for an inline command, chosen on command semantics in Doxygen.\n\nEnumerator Note\nCXCommentInlineCommandRenderKind_Normal Command argument should be rendered in a normal font.\nCXCommentInlineCommandRenderKind_Bold Command argument should be rendered in a bold font.\nCXCommentInlineCommandRenderKind_Monospaced Command argument should be rendered in a monospaced font.\nCXCommentInlineCommandRenderKind_Emphasized Command argument should be rendered emphasized (typically italic font).\nCXCommentInlineCommandRenderKind_Anchor Command argument should not be rendered (since it only defines an anchor).\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCommentKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCommentKind","text":"CXCommentKind\n\nDescribes the type of the comment AST node (CXComment). A comment node can be considered block content (e. g., paragraph), inline content (plain text) or neither (the root AST node).\n\nEnumerator Note\nCXComment_Null Null comment. No AST node is constructed at the requested location because there is no text or a syntax error.\nCXComment_Text Plain text. Inline content.\nCXComment_InlineCommand A command with word-like arguments that is considered inline content.  For example: \\c command.\nCXComment_HTMLStartTag HTML start tag with attributes (name-value pairs). Considered inline content.  For example:  c++  <br> <br /> <a href=\"http://example.org/\">\nCXComment_HTMLEndTag HTML end tag. Considered inline content.  For example:  c++  </a>\nCXComment_Paragraph A paragraph, contains inline comment. The paragraph itself is block content.\nCXComment_BlockCommand A command that has zero or more word-like arguments (number of word-like arguments depends on command name) and a paragraph as an argument. Block command is block content.  Paragraph argument is also a child of the block command.  For example:  0 word-like arguments and a paragraph argument.  AST nodes of special kinds that parser knows about (e. g., \\param command) have their own node kinds.\nCXComment_ParamCommand A \\param or \\arg command that describes the function parameter (name, passing direction, description).  For example: \\param [in] ParamName description.\nCXComment_TParamCommand A \\tparam command that describes a template parameter (name and description).  For example: \\tparam T description.\nCXComment_VerbatimBlockCommand A verbatim block command (e. g., preformatted code). Verbatim block has an opening and a closing command and contains multiple lines of text (CXComment_VerbatimBlockLine child nodes).  For example: \\verbatim aaa \\endverbatim\nCXComment_VerbatimBlockLine A line of text that is contained within a CXComment_VerbatimBlockCommand node.\nCXComment_VerbatimLine A verbatim line command. Verbatim line has an opening command, a single line of text (up to the newline after the opening command) and has no closing command.\nCXComment_FullComment A full comment attached to a declaration, contains block content.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCommentParamPassDirection","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCommentParamPassDirection","text":"CXCommentParamPassDirection\n\nDescribes parameter passing direction for \\param or \\arg command.\n\nEnumerator Note\nCXCommentParamPassDirection_In The parameter is an input parameter.\nCXCommentParamPassDirection_Out The parameter is an output parameter.\nCXCommentParamPassDirection_InOut The parameter is an input and output parameter.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompilationDatabase","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompilationDatabase","text":"A compilation database holds all information used to compile files in a project. For each file in the database, it can be queried for the working directory or the command line used for the compiler invocation.\n\nMust be freed by clang_CompilationDatabase_dispose\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompilationDatabase_Error","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompilationDatabase_Error","text":"CXCompilationDatabase_Error\n\nError codes for Compilation Database\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompileCommand","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompileCommand","text":"Represents the command line invocation to compile a specific file.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompileCommands","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompileCommands","text":"Contains the results of a search in the compilation database\n\nWhen searching for the compile command for a file, the compilation db can return several commands, as the file may have been compiled with different options in different places of the project. This choice of compile commands is wrapped in this opaque data structure. It must be freed by clang_CompileCommands_dispose.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompletionChunkKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompletionChunkKind","text":"CXCompletionChunkKind\n\nDescribes a single piece of text within a code-completion string.\n\nEach \"chunk\" within a code-completion string (CXCompletionString) is either a piece of text with a specific \"kind\" that describes how that text should be interpreted by the client or is another completion string.\n\nEnumerator Note\nCXCompletionChunk_Optional A code-completion string that describes \"optional\" text that could be a part of the template (but is not required).  The Optional chunk is the only kind of chunk that has a code-completion string for its representation, which is accessible via clang_getCompletionChunkCompletionString(). The code-completion string describes an additional part of the template that is completely optional. For example, optional chunks can be used to describe the placeholders for arguments that match up with defaulted function parameters, e.g. given:  c++  void f(int x, float y = 3.14, double z = 2.71828);  The code-completion string for this function would contain: - a TypedText chunk for \"f\". - a LeftParen chunk for \"(\". - a Placeholder chunk for \"int x\" - an Optional chunk containing the remaining defaulted arguments, e.g., - a Comma chunk for \",\" - a Placeholder chunk for \"float y\" - an Optional chunk containing the last defaulted argument: - a Comma chunk for \",\" - a Placeholder chunk for \"double z\" - a RightParen chunk for \")\"  There are many ways to handle Optional chunks. Two simple approaches are: - Completely ignore optional chunks, in which case the template for the function \"f\" would only include the first parameter (\"int x\"). - Fully expand all optional chunks, in which case the template for the function \"f\" would have all of the parameters.\nCXCompletionChunk_TypedText Text that a user would be expected to type to get this code-completion result.  There will be exactly one \"typed text\" chunk in a semantic string, which will typically provide the spelling of a keyword or the name of a declaration that could be used at the current code point. Clients are expected to filter the code-completion results based on the text in this chunk.\nCXCompletionChunk_Text Text that should be inserted as part of a code-completion result.  A \"text\" chunk represents text that is part of the template to be inserted into user code should this particular code-completion result be selected.\nCXCompletionChunk_Placeholder Placeholder text that should be replaced by the user.  A \"placeholder\" chunk marks a place where the user should insert text into the code-completion template. For example, placeholders might mark the function parameters for a function declaration, to indicate that the user should provide arguments for each of those parameters. The actual text in a placeholder is a suggestion for the text to display before the user replaces the placeholder with real code.\nCXCompletionChunk_Informative Informative text that should be displayed but never inserted as part of the template.  An \"informative\" chunk contains annotations that can be displayed to help the user decide whether a particular code-completion result is the right option, but which is not part of the actual template to be inserted by code completion.\nCXCompletionChunk_CurrentParameter Text that describes the current parameter when code-completion is referring to function call, message send, or template specialization.  A \"current parameter\" chunk occurs when code-completion is providing information about a parameter corresponding to the argument at the code-completion point. For example, given a function  c++  int add(int x, int y);  and the source code add(, where the code-completion point is after the \"(\", the code-completion string will contain a \"current parameter\" chunk for \"int x\", indicating that the current argument will initialize that parameter. After typing further, to add(17, (where the code-completion point is after the \",\"), the code-completion string will contain a \"current parameter\" chunk to \"int y\".\nCXCompletionChunk_LeftParen A left parenthesis ('('), used to initiate a function call or signal the beginning of a function parameter list.\nCXCompletionChunk_RightParen A right parenthesis (')'), used to finish a function call or signal the end of a function parameter list.\nCXCompletionChunk_LeftBracket A left bracket ('[').\nCXCompletionChunk_RightBracket A right bracket (']').\nCXCompletionChunk_LeftBrace A left brace ('{').\nCXCompletionChunk_RightBrace A right brace ('}').\nCXCompletionChunk_LeftAngle A left angle bracket ('<').\nCXCompletionChunk_RightAngle A right angle bracket ('>').\nCXCompletionChunk_Comma A comma separator (',').\nCXCompletionChunk_ResultType Text that specifies the result type of a given result.  This special kind of informative chunk is not meant to be inserted into the text buffer. Rather, it is meant to illustrate the type that an expression using the given completion string would have.\nCXCompletionChunk_Colon A colon (':').\nCXCompletionChunk_SemiColon A semicolon (';').\nCXCompletionChunk_Equal An '=' sign.\nCXCompletionChunk_HorizontalSpace Horizontal space (' ').\nCXCompletionChunk_VerticalSpace Vertical space ('\\n'), after which it is generally a good idea to perform indentation.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompletionContext","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompletionContext","text":"CXCompletionContext\n\nBits that represent the context under which completion is occurring.\n\nThe enumerators in this enumeration may be bitwise-OR'd together if multiple contexts are occurring simultaneously.\n\nEnumerator Note\nCXCompletionContext_Unexposed The context for completions is unexposed, as only Clang results should be included. (This is equivalent to having no context bits set.)\nCXCompletionContext_AnyType Completions for any possible type should be included in the results.\nCXCompletionContext_AnyValue Completions for any possible value (variables, function calls, etc.) should be included in the results.\nCXCompletionContext_ObjCObjectValue Completions for values that resolve to an Objective-C object should be included in the results.\nCXCompletionContext_ObjCSelectorValue Completions for values that resolve to an Objective-C selector should be included in the results.\nCXCompletionContext_CXXClassTypeValue Completions for values that resolve to a C++ class type should be included in the results.\nCXCompletionContext_DotMemberAccess Completions for fields of the member being accessed using the dot operator should be included in the results.\nCXCompletionContext_ArrowMemberAccess Completions for fields of the member being accessed using the arrow operator should be included in the results.\nCXCompletionContext_ObjCPropertyAccess Completions for properties of the Objective-C object being accessed using the dot operator should be included in the results.\nCXCompletionContext_EnumTag Completions for enum tags should be included in the results.\nCXCompletionContext_UnionTag Completions for union tags should be included in the results.\nCXCompletionContext_StructTag Completions for struct tags should be included in the results.\nCXCompletionContext_ClassTag Completions for C++ class names should be included in the results.\nCXCompletionContext_Namespace Completions for C++ namespaces and namespace aliases should be included in the results.\nCXCompletionContext_NestedNameSpecifier Completions for C++ nested name specifiers should be included in the results.\nCXCompletionContext_ObjCInterface Completions for Objective-C interfaces (classes) should be included in the results.\nCXCompletionContext_ObjCProtocol Completions for Objective-C protocols should be included in the results.\nCXCompletionContext_ObjCCategory Completions for Objective-C categories should be included in the results.\nCXCompletionContext_ObjCInstanceMessage Completions for Objective-C instance messages should be included in the results.\nCXCompletionContext_ObjCClassMessage Completions for Objective-C class messages should be included in the results.\nCXCompletionContext_ObjCSelectorName Completions for Objective-C selector names should be included in the results.\nCXCompletionContext_MacroName Completions for preprocessor macro names should be included in the results.\nCXCompletionContext_NaturalLanguage Natural language completions should be included in the results.\nCXCompletionContext_IncludedFile #include file completions should be included in the results.\nCXCompletionContext_Unknown The current context is unknown, so set all contexts.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompletionResult","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompletionResult","text":"CXCompletionResult\n\nA single result of code completion.\n\nField Note\nCursorKind The kind of entity that this completion refers to.  The cursor kind will be a macro, keyword, or a declaration (one of the *Decl cursor kinds), describing the entity that the completion is referring to.  \\todo In the future, we would like to provide a full cursor, to allow the client to extract additional information from declaration.\nCompletionString The code-completion string that describes how to insert this code-completion result into the editing buffer.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCompletionString","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCompletionString","text":"A semantic string that describes a code-completion result.\n\nA semantic string that describes the formatting of a code-completion result as a single \"template\" of text that should be inserted into the source buffer when a particular code-completion result is selected. Each semantic string is made up of some number of \"chunks\", each of which contains some text along with a description of what that text means, e.g., the name of the entity being referenced, whether the text chunk is part of the template, or whether it is a \"placeholder\" that the user should replace with actual code,of a specific kind. See CXCompletionChunkKind for a description of the different kinds of chunks.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCursor","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCursor","text":"CXCursor\n\nA cursor representing some element in the abstract syntax tree for a translation unit.\n\nThe cursor abstraction unifies the different kinds of entities in a programdeclaration, statements, expressions, references to declarations, etc.under a single \"cursor\" abstraction with a common set of operations. Common operation for a cursor include: getting the physical location in a source file where the cursor points, getting the name associated with a cursor, and retrieving cursors for any child nodes of a particular cursor.\n\nCursors can be produced in two specific ways. clang_getTranslationUnitCursor() produces a cursor for a translation unit, from which one can use clang_visitChildren() to explore the rest of the translation unit. clang_getCursor() maps from a physical source location to the entity that resides at that location, allowing one to map from the source code into the AST.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCursorKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCursorKind","text":"CXCursorKind\n\nDescribes the kind of entity that a cursor refers to.\n\nEnumerator Note\nCXCursor_UnexposedDecl A declaration whose specific kind is not exposed via this interface.  Unexposed declarations have the same operations as any other kind of declaration; one can extract their location information, spelling, find their definitions, etc. However, the specific kind of the declaration is not reported.\nCXCursor_StructDecl A C or C++ struct.\nCXCursor_UnionDecl A C or C++ union.\nCXCursor_ClassDecl A C++ class.\nCXCursor_EnumDecl An enumeration.\nCXCursor_FieldDecl A field (in C) or non-static data member (in C++) in a struct, union, or C++ class.\nCXCursor_EnumConstantDecl An enumerator constant.\nCXCursor_FunctionDecl A function.\nCXCursor_VarDecl A variable.\nCXCursor_ParmDecl A function or method parameter.\nCXCursor_ObjCInterfaceDecl An Objective-C @interface.\nCXCursor_ObjCCategoryDecl An Objective-C @interface for a category.\nCXCursor_ObjCProtocolDecl An Objective-C @protocol declaration.\nCXCursor_ObjCPropertyDecl An Objective-C @property declaration.\nCXCursor_ObjCIvarDecl An Objective-C instance variable.\nCXCursor_ObjCInstanceMethodDecl An Objective-C instance method.\nCXCursor_ObjCClassMethodDecl An Objective-C class method.\nCXCursor_ObjCImplementationDecl An Objective-C @implementation.\nCXCursor_ObjCCategoryImplDecl An Objective-C @implementation for a category.\nCXCursor_TypedefDecl A typedef.\nCXCursor_CXXMethod A C++ class method.\nCXCursor_Namespace A C++ namespace.\nCXCursor_LinkageSpec A linkage specification, e.g. 'extern \"C\"'.\nCXCursor_Constructor A C++ constructor.\nCXCursor_Destructor A C++ destructor.\nCXCursor_ConversionFunction A C++ conversion function.\nCXCursor_TemplateTypeParameter A C++ template type parameter.\nCXCursor_NonTypeTemplateParameter A C++ non-type template parameter.\nCXCursor_TemplateTemplateParameter A C++ template template parameter.\nCXCursor_FunctionTemplate A C++ function template.\nCXCursor_ClassTemplate A C++ class template.\nCXCursor_ClassTemplatePartialSpecialization A C++ class template partial specialization.\nCXCursor_NamespaceAlias A C++ namespace alias declaration.\nCXCursor_UsingDirective A C++ using directive.\nCXCursor_UsingDeclaration A C++ using declaration.\nCXCursor_TypeAliasDecl A C++ alias declaration\nCXCursor_ObjCSynthesizeDecl An Objective-C @synthesize definition.\nCXCursor_ObjCDynamicDecl An Objective-C @dynamic definition.\nCXCursor_CXXAccessSpecifier An access specifier.\nCXCursor_FirstDecl \nCXCursor_LastDecl \nCXCursor_FirstRef \nCXCursor_ObjCSuperClassRef \nCXCursor_ObjCProtocolRef \nCXCursor_ObjCClassRef \nCXCursor_TypeRef A reference to a type declaration.  A type reference occurs anywhere where a type is named but not declared. For example, given:  c++  typedef unsigned size_type;  size_type size;  The typedef is a declaration of size_type (CXCursor_TypedefDecl), while the type of the variable \"size\" is referenced. The cursor referenced by the type of size is the typedef for size_type.\nCXCursor_CXXBaseSpecifier \nCXCursor_TemplateRef A reference to a class template, function template, template template parameter, or class template partial specialization.\nCXCursor_NamespaceRef A reference to a namespace or namespace alias.\nCXCursor_MemberRef A reference to a member of a struct, union, or class that occurs in some non-expression context, e.g., a designated initializer.\nCXCursor_LabelRef A reference to a labeled statement.  This cursor kind is used to describe the jump to \"start_over\" in the goto statement in the following example:  c++    start_over:      ++counter;      goto start_over;  A label reference cursor refers to a label statement.\nCXCursor_OverloadedDeclRef A reference to a set of overloaded functions or function templates that has not yet been resolved to a specific function or function template.  An overloaded declaration reference cursor occurs in C++ templates where a dependent name refers to a function. For example:  c++  template<typename T> void swap(T&, T&);  struct X { ... };  void swap(X&, X&);  template<typename T>  void reverse(T* first, T* last) {    while (first < last - 1) {      swap(*first, *--last);      ++first;    }  }  struct Y { };  void swap(Y&, Y&);  Here, the identifier \"swap\" is associated with an overloaded declaration reference. In the template definition, \"swap\" refers to either of the two \"swap\" functions declared above, so both results will be available. At instantiation time, \"swap\" may also refer to other functions found via argument-dependent lookup (e.g., the \"swap\" function at the end of the example).  The functions clang_getNumOverloadedDecls() and clang_getOverloadedDecl() can be used to retrieve the definitions referenced by this cursor.\nCXCursor_VariableRef A reference to a variable that occurs in some non-expression context, e.g., a C++ lambda capture list.\nCXCursor_LastRef \nCXCursor_FirstInvalid \nCXCursor_InvalidFile \nCXCursor_NoDeclFound \nCXCursor_NotImplemented \nCXCursor_InvalidCode \nCXCursor_LastInvalid \nCXCursor_FirstExpr \nCXCursor_UnexposedExpr An expression whose specific kind is not exposed via this interface.  Unexposed expressions have the same operations as any other kind of expression; one can extract their location information, spelling, children, etc. However, the specific kind of the expression is not reported.\nCXCursor_DeclRefExpr An expression that refers to some value declaration, such as a function, variable, or enumerator.\nCXCursor_MemberRefExpr An expression that refers to a member of a struct, union, class, Objective-C class, etc.\nCXCursor_CallExpr An expression that calls a function.\nCXCursor_ObjCMessageExpr An expression that sends a message to an Objective-C object or class.\nCXCursor_BlockExpr An expression that represents a block literal.\nCXCursor_IntegerLiteral An integer literal.\nCXCursor_FloatingLiteral A floating point number literal.\nCXCursor_ImaginaryLiteral An imaginary number literal.\nCXCursor_StringLiteral A string literal.\nCXCursor_CharacterLiteral A character literal.\nCXCursor_ParenExpr A parenthesized expression, e.g. \"(1)\".  This AST node is only formed if full location information is requested.\nCXCursor_UnaryOperator This represents the unary-expression's (except sizeof and alignof).\nCXCursor_ArraySubscriptExpr [C99 6.5.2.1] Array Subscripting.\nCXCursor_BinaryOperator A builtin binary operation expression such as \"x + y\" or \"x <= y\".\nCXCursor_CompoundAssignOperator Compound assignment such as \"+=\".\nCXCursor_ConditionalOperator The ?: ternary operator.\nCXCursor_CStyleCastExpr An explicit cast in C (C99 6.5.4) or a C-style cast in C++ (C++ [expr.cast]), which uses the syntax (Type)expr.  For example: (int)f.\nCXCursor_CompoundLiteralExpr [C99 6.5.2.5]\nCXCursor_InitListExpr Describes an C or C++ initializer list.\nCXCursor_AddrLabelExpr The GNU address of label extension, representing &&label.\nCXCursor_StmtExpr This is the GNU Statement Expression extension: ({int X=4; X;})\nCXCursor_GenericSelectionExpr Represents a C11 generic selection.\nCXCursor_GNUNullExpr Implements the GNU __null extension, which is a name for a null pointer constant that has integral type (e.g., int or long) and is the same size and alignment as a pointer.  The __null extension is typically only used by system headers, which define NULL as __null in C++ rather than using 0 (which is an integer that may not match the size of a pointer).\nCXCursor_CXXStaticCastExpr C++'s static_cast<> expression.\nCXCursor_CXXDynamicCastExpr C++'s dynamic_cast<> expression.\nCXCursor_CXXReinterpretCastExpr C++'s reinterpret_cast<> expression.\nCXCursor_CXXConstCastExpr C++'s const_cast<> expression.\nCXCursor_CXXFunctionalCastExpr Represents an explicit C++ type conversion that uses \"functional\" notion (C++ [expr.type.conv]).  Example:  c++    x = int(0.5);\nCXCursor_CXXTypeidExpr A C++ typeid expression (C++ [expr.typeid]).\nCXCursor_CXXBoolLiteralExpr [C++ 2.13.5] C++ Boolean Literal.\nCXCursor_CXXNullPtrLiteralExpr [C++0x 2.14.7] C++ Pointer Literal.\nCXCursor_CXXThisExpr Represents the \"this\" expression in C++\nCXCursor_CXXThrowExpr [C++ 15] C++ Throw Expression.  This handles 'throw' and 'throw' assignment-expression. When assignment-expression isn't present, Op will be null.\nCXCursor_CXXNewExpr A new expression for memory allocation and constructor calls, e.g: \"new CXXNewExpr(foo)\".\nCXCursor_CXXDeleteExpr A delete expression for memory deallocation and destructor calls, e.g. \"delete[] pArray\".\nCXCursor_UnaryExpr A unary expression. (noexcept, sizeof, or other traits)\nCXCursor_ObjCStringLiteral An Objective-C string literal i.e. \"foo\".\nCXCursor_ObjCEncodeExpr An Objective-C @encode expression.\nCXCursor_ObjCSelectorExpr An Objective-C @selector expression.\nCXCursor_ObjCProtocolExpr An Objective-C @protocol expression.\nCXCursor_ObjCBridgedCastExpr An Objective-C \"bridged\" cast expression, which casts between Objective-C pointers and C pointers, transferring ownership in the process.  c++    NSString *str = (__bridge_transfer NSString *)CFCreateString();\nCXCursor_PackExpansionExpr Represents a C++0x pack expansion that produces a sequence of expressions.  A pack expansion expression contains a pattern (which itself is an expression) followed by an ellipsis. For example:  c++  template<typename F, typename ...Types>  void forward(F f, Types &&...args) {   f(static_cast<Types&&>(args)...);  }\nCXCursor_SizeOfPackExpr Represents an expression that computes the length of a parameter pack.  c++  template<typename ...Types>  struct count {    static const unsigned value = sizeof...(Types);  };\nCXCursor_ObjCBoolLiteralExpr Objective-c Boolean Literal.\nCXCursor_ObjCSelfExpr Represents the \"self\" expression in an Objective-C method.\nCXCursor_OMPArraySectionExpr OpenMP 5.0 [2.1.5, Array Section].\nCXCursor_ObjCAvailabilityCheckExpr Represents an (...) check.\nCXCursor_FixedPointLiteral Fixed point literal\nCXCursor_OMPArrayShapingExpr OpenMP 5.0 [2.1.4, Array Shaping].\nCXCursor_OMPIteratorExpr OpenMP 5.0 [2.1.6 Iterators]\nCXCursor_CXXAddrspaceCastExpr OpenCL's addrspace_cast<> expression.\nCXCursor_LastExpr \nCXCursor_FirstStmt \nCXCursor_UnexposedStmt A statement whose specific kind is not exposed via this interface.  Unexposed statements have the same operations as any other kind of statement; one can extract their location information, spelling, children, etc. However, the specific kind of the statement is not reported.\nCXCursor_LabelStmt A labelled statement in a function.  This cursor kind is used to describe the \"start_over:\" label statement in the following example:  c++    start_over:      ++counter;\nCXCursor_CompoundStmt A group of statements like { stmt stmt }.  This cursor kind is used to describe compound statements, e.g. function bodies.\nCXCursor_CaseStmt A case statement.\nCXCursor_DefaultStmt A default statement.\nCXCursor_IfStmt An if statement\nCXCursor_SwitchStmt A switch statement.\nCXCursor_WhileStmt A while statement.\nCXCursor_DoStmt A do statement.\nCXCursor_ForStmt A for statement.\nCXCursor_GotoStmt A goto statement.\nCXCursor_IndirectGotoStmt An indirect goto statement.\nCXCursor_ContinueStmt A continue statement.\nCXCursor_BreakStmt A break statement.\nCXCursor_ReturnStmt A return statement.\nCXCursor_GCCAsmStmt A GCC inline assembly statement extension.\nCXCursor_AsmStmt \nCXCursor_ObjCAtTryStmt Objective-C's overall @try-@catch-@finally statement.\nCXCursor_ObjCAtCatchStmt Objective-C's @catch statement.\nCXCursor_ObjCAtFinallyStmt Objective-C's @finally statement.\nCXCursor_ObjCAtThrowStmt Objective-C's @throw statement.\nCXCursor_ObjCAtSynchronizedStmt Objective-C's @synchronized statement.\nCXCursor_ObjCAutoreleasePoolStmt Objective-C's autorelease pool statement.\nCXCursor_ObjCForCollectionStmt Objective-C's collection statement.\nCXCursor_CXXCatchStmt C++'s catch statement.\nCXCursor_CXXTryStmt C++'s try statement.\nCXCursor_CXXForRangeStmt C++'s for (* : *) statement.\nCXCursor_SEHTryStmt Windows Structured Exception Handling's try statement.\nCXCursor_SEHExceptStmt Windows Structured Exception Handling's except statement.\nCXCursor_SEHFinallyStmt Windows Structured Exception Handling's finally statement.\nCXCursor_MSAsmStmt A MS inline assembly statement extension.\nCXCursor_NullStmt The null statement \";\": C99 6.8.3p3.  This cursor kind is used to describe the null statement.\nCXCursor_DeclStmt Adaptor class for mixing declarations with statements and expressions.\nCXCursor_OMPParallelDirective OpenMP parallel directive.\nCXCursor_OMPSimdDirective OpenMP SIMD directive.\nCXCursor_OMPForDirective OpenMP for directive.\nCXCursor_OMPSectionsDirective OpenMP sections directive.\nCXCursor_OMPSectionDirective OpenMP section directive.\nCXCursor_OMPSingleDirective OpenMP single directive.\nCXCursor_OMPParallelForDirective OpenMP parallel for directive.\nCXCursor_OMPParallelSectionsDirective OpenMP parallel sections directive.\nCXCursor_OMPTaskDirective OpenMP task directive.\nCXCursor_OMPMasterDirective OpenMP master directive.\nCXCursor_OMPCriticalDirective OpenMP critical directive.\nCXCursor_OMPTaskyieldDirective OpenMP taskyield directive.\nCXCursor_OMPBarrierDirective OpenMP barrier directive.\nCXCursor_OMPTaskwaitDirective OpenMP taskwait directive.\nCXCursor_OMPFlushDirective OpenMP flush directive.\nCXCursor_SEHLeaveStmt Windows Structured Exception Handling's leave statement.\nCXCursor_OMPOrderedDirective OpenMP ordered directive.\nCXCursor_OMPAtomicDirective OpenMP atomic directive.\nCXCursor_OMPForSimdDirective OpenMP for SIMD directive.\nCXCursor_OMPParallelForSimdDirective OpenMP parallel for SIMD directive.\nCXCursor_OMPTargetDirective OpenMP target directive.\nCXCursor_OMPTeamsDirective OpenMP teams directive.\nCXCursor_OMPTaskgroupDirective OpenMP taskgroup directive.\nCXCursor_OMPCancellationPointDirective OpenMP cancellation point directive.\nCXCursor_OMPCancelDirective OpenMP cancel directive.\nCXCursor_OMPTargetDataDirective OpenMP target data directive.\nCXCursor_OMPTaskLoopDirective OpenMP taskloop directive.\nCXCursor_OMPTaskLoopSimdDirective OpenMP taskloop simd directive.\nCXCursor_OMPDistributeDirective OpenMP distribute directive.\nCXCursor_OMPTargetEnterDataDirective OpenMP target enter data directive.\nCXCursor_OMPTargetExitDataDirective OpenMP target exit data directive.\nCXCursor_OMPTargetParallelDirective OpenMP target parallel directive.\nCXCursor_OMPTargetParallelForDirective OpenMP target parallel for directive.\nCXCursor_OMPTargetUpdateDirective OpenMP target update directive.\nCXCursor_OMPDistributeParallelForDirective OpenMP distribute parallel for directive.\nCXCursor_OMPDistributeParallelForSimdDirective OpenMP distribute parallel for simd directive.\nCXCursor_OMPDistributeSimdDirective OpenMP distribute simd directive.\nCXCursor_OMPTargetParallelForSimdDirective OpenMP target parallel for simd directive.\nCXCursor_OMPTargetSimdDirective OpenMP target simd directive.\nCXCursor_OMPTeamsDistributeDirective OpenMP teams distribute directive.\nCXCursor_OMPTeamsDistributeSimdDirective OpenMP teams distribute simd directive.\nCXCursor_OMPTeamsDistributeParallelForSimdDirective OpenMP teams distribute parallel for simd directive.\nCXCursor_OMPTeamsDistributeParallelForDirective OpenMP teams distribute parallel for directive.\nCXCursor_OMPTargetTeamsDirective OpenMP target teams directive.\nCXCursor_OMPTargetTeamsDistributeDirective OpenMP target teams distribute directive.\nCXCursor_OMPTargetTeamsDistributeParallelForDirective OpenMP target teams distribute parallel for directive.\nCXCursor_OMPTargetTeamsDistributeParallelForSimdDirective OpenMP target teams distribute parallel for simd directive.\nCXCursor_OMPTargetTeamsDistributeSimdDirective OpenMP target teams distribute simd directive.\nCXCursor_BuiltinBitCastExpr C++2a std::bit_cast expression.\nCXCursor_OMPMasterTaskLoopDirective OpenMP master taskloop directive.\nCXCursor_OMPParallelMasterTaskLoopDirective OpenMP parallel master taskloop directive.\nCXCursor_OMPMasterTaskLoopSimdDirective OpenMP master taskloop simd directive.\nCXCursor_OMPParallelMasterTaskLoopSimdDirective OpenMP parallel master taskloop simd directive.\nCXCursor_OMPParallelMasterDirective OpenMP parallel master directive.\nCXCursor_OMPDepobjDirective OpenMP depobj directive.\nCXCursor_OMPScanDirective OpenMP scan directive.\nCXCursor_OMPTileDirective OpenMP tile directive.\nCXCursor_OMPCanonicalLoop OpenMP canonical loop.\nCXCursor_OMPInteropDirective OpenMP interop directive.\nCXCursor_OMPDispatchDirective OpenMP dispatch directive.\nCXCursor_OMPMaskedDirective OpenMP masked directive.\nCXCursor_OMPUnrollDirective OpenMP unroll directive.\nCXCursor_LastStmt \nCXCursor_TranslationUnit Cursor that represents the translation unit itself.  The translation unit cursor exists primarily to act as the root cursor for traversing the contents of a translation unit.\nCXCursor_FirstAttr \nCXCursor_UnexposedAttr An attribute whose specific kind is not exposed via this interface.\nCXCursor_IBActionAttr \nCXCursor_IBOutletAttr \nCXCursor_IBOutletCollectionAttr \nCXCursor_CXXFinalAttr \nCXCursor_CXXOverrideAttr \nCXCursor_AnnotateAttr \nCXCursor_AsmLabelAttr \nCXCursor_PackedAttr \nCXCursor_PureAttr \nCXCursor_ConstAttr \nCXCursor_NoDuplicateAttr \nCXCursor_CUDAConstantAttr \nCXCursor_CUDADeviceAttr \nCXCursor_CUDAGlobalAttr \nCXCursor_CUDAHostAttr \nCXCursor_CUDASharedAttr \nCXCursor_VisibilityAttr \nCXCursor_DLLExport \nCXCursor_DLLImport \nCXCursor_NSReturnsRetained \nCXCursor_NSReturnsNotRetained \nCXCursor_NSReturnsAutoreleased \nCXCursor_NSConsumesSelf \nCXCursor_NSConsumed \nCXCursor_ObjCException \nCXCursor_ObjCNSObject \nCXCursor_ObjCIndependentClass \nCXCursor_ObjCPreciseLifetime \nCXCursor_ObjCReturnsInnerPointer \nCXCursor_ObjCRequiresSuper \nCXCursor_ObjCRootClass \nCXCursor_ObjCSubclassingRestricted \nCXCursor_ObjCExplicitProtocolImpl \nCXCursor_ObjCDesignatedInitializer \nCXCursor_ObjCRuntimeVisible \nCXCursor_ObjCBoxable \nCXCursor_FlagEnum \nCXCursor_ConvergentAttr \nCXCursor_WarnUnusedAttr \nCXCursor_WarnUnusedResultAttr \nCXCursor_AlignedAttr \nCXCursor_LastAttr \nCXCursor_PreprocessingDirective \nCXCursor_MacroDefinition \nCXCursor_MacroExpansion \nCXCursor_MacroInstantiation \nCXCursor_InclusionDirective \nCXCursor_FirstPreprocessing \nCXCursor_LastPreprocessing \nCXCursor_ModuleImportDecl A module import declaration.\nCXCursor_TypeAliasTemplateDecl \nCXCursor_StaticAssert A static_assert or _Static_assert node\nCXCursor_FriendDecl a friend declaration.\nCXCursor_FirstExtraDecl \nCXCursor_LastExtraDecl \nCXCursor_OverloadCandidate A code completion overload candidate.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCursorSet","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCursorSet","text":"A fast container representing a set of CXCursors.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCursorVisitor","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCursorVisitor","text":"Visitor invoked for each cursor found by a traversal.\n\nThis visitor function will be invoked for each cursor found by clang_visitCursorChildren(). Its first argument is the cursor being visited, its second argument is the parent visitor for that cursor, and its third argument is the client data provided to clang_visitCursorChildren().\n\nThe visitor should return one of the CXChildVisitResult values to direct clang_visitCursorChildren().\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXCursor_ExceptionSpecificationKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXCursor_ExceptionSpecificationKind","text":"CXCursor_ExceptionSpecificationKind\n\nDescribes the exception specification of a cursor.\n\nA negative value indicates that the cursor is not a function declaration.\n\nEnumerator Note\nCXCursor_ExceptionSpecificationKind_None The cursor has no exception specification.\nCXCursor_ExceptionSpecificationKind_DynamicNone The cursor has exception specification throw()\nCXCursor_ExceptionSpecificationKind_Dynamic The cursor has exception specification throw(T1, T2)\nCXCursor_ExceptionSpecificationKind_MSAny The cursor has exception specification throw(...).\nCXCursor_ExceptionSpecificationKind_BasicNoexcept The cursor has exception specification basic noexcept.\nCXCursor_ExceptionSpecificationKind_ComputedNoexcept The cursor has exception specification computed noexcept.\nCXCursor_ExceptionSpecificationKind_Unevaluated The exception specification has not yet been evaluated.\nCXCursor_ExceptionSpecificationKind_Uninstantiated The exception specification has not yet been instantiated.\nCXCursor_ExceptionSpecificationKind_Unparsed The exception specification has not been parsed yet.\nCXCursor_ExceptionSpecificationKind_NoThrow The cursor has a __declspec(nothrow) exception specification.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXDiagnostic","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXDiagnostic","text":"A single diagnostic, containing the diagnostic's severity, location, text, source ranges, and fix-it hints.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXDiagnosticDisplayOptions","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXDiagnosticDisplayOptions","text":"CXDiagnosticDisplayOptions\n\nOptions to control the display of diagnostics.\n\nThe values in this enum are meant to be combined to customize the behavior of clang_formatDiagnostic().\n\nEnumerator Note\nCXDiagnostic_DisplaySourceLocation Display the source-location information where the diagnostic was located.  When set, diagnostics will be prefixed by the file, line, and (optionally) column to which the diagnostic refers. For example,  c++  test.c:28: warning: extra tokens at end of #endif directive  This option corresponds to the clang flag -fshow-source-location.\nCXDiagnostic_DisplayColumn If displaying the source-location information of the diagnostic, also include the column number.  This option corresponds to the clang flag -fshow-column.\nCXDiagnostic_DisplaySourceRanges If displaying the source-location information of the diagnostic, also include information about source ranges in a machine-parsable format.  This option corresponds to the clang flag -fdiagnostics-print-source-range-info.\nCXDiagnostic_DisplayOption Display the option name associated with this diagnostic, if any.  The option name displayed (e.g., -Wconversion) will be placed in brackets after the diagnostic text. This option corresponds to the clang flag -fdiagnostics-show-option.\nCXDiagnostic_DisplayCategoryId Display the category number associated with this diagnostic, if any.  The category number is displayed within brackets after the diagnostic text. This option corresponds to the clang flag -fdiagnostics-show-category=id.\nCXDiagnostic_DisplayCategoryName Display the category name associated with this diagnostic, if any.  The category name is displayed within brackets after the diagnostic text. This option corresponds to the clang flag -fdiagnostics-show-category=name.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXDiagnosticSet","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXDiagnosticSet","text":"A group of CXDiagnostics.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXDiagnosticSeverity","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXDiagnosticSeverity","text":"CXDiagnosticSeverity\n\nDescribes the severity of a particular diagnostic.\n\nEnumerator Note\nCXDiagnostic_Ignored A diagnostic that has been suppressed, e.g., by a command-line option.\nCXDiagnostic_Note This diagnostic is a note that should be attached to the previous (non-note) diagnostic.\nCXDiagnostic_Warning This diagnostic indicates suspicious code that may not be wrong.\nCXDiagnostic_Error This diagnostic indicates that the code is ill-formed.\nCXDiagnostic_Fatal This diagnostic indicates that the code is ill-formed such that future parser recovery is unlikely to produce useful results.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXErrorCode","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXErrorCode","text":"CXErrorCode\n\nError codes returned by libclang routines.\n\nZero (CXError_Success) is the only error code indicating success. Other error codes, including not yet assigned non-zero values, indicate errors.\n\nEnumerator Note\nCXError_Success No error.\nCXError_Failure A generic error code, no further details are available.  Errors of this kind can get their own specific error codes in future libclang versions.\nCXError_Crashed libclang crashed while performing the requested operation.\nCXError_InvalidArguments The function detected that the arguments violate the function contract.\nCXError_ASTReadError An AST deserialization error has occurred.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXEvalResult","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXEvalResult","text":"Evaluation result of a cursor\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXFieldVisitor","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXFieldVisitor","text":"Visitor invoked for each field found by a traversal.\n\nThis visitor function will be invoked for each field found by clang_Type_visitFields. Its first argument is the cursor being visited, its second argument is the client data provided to clang_Type_visitFields.\n\nThe visitor should return one of the CXVisitorResult values to direct clang_Type_visitFields.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXFile","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXFile","text":"A particular source file that is part of a translation unit.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXFileUniqueID","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXFileUniqueID","text":"CXFileUniqueID\n\nUniquely identifies a CXFile, that refers to the same underlying file, across an indexing session.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXGlobalOptFlags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXGlobalOptFlags","text":"CXGlobalOptFlags\n\nEnumerator Note\nCXGlobalOpt_None Used to indicate that no special CXIndex options are needed.\nCXGlobalOpt_ThreadBackgroundPriorityForIndexing Used to indicate that threads that libclang creates for indexing purposes should use background priority.  Affects #clang_indexSourceFile, #clang_indexTranslationUnit, #clang_parseTranslationUnit, #clang_saveTranslationUnit.\nCXGlobalOpt_ThreadBackgroundPriorityForEditing Used to indicate that threads that libclang creates for editing purposes should use background priority.  Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt, #clang_annotateTokens\nCXGlobalOpt_ThreadBackgroundPriorityForAll Used to indicate that all threads that libclang creates should use background priority.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxClientASTFile","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxClientASTFile","text":"The client's data object that is associated with an AST file (PCH or module).\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxClientContainer","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxClientContainer","text":"The client's data object that is associated with a semantic container of entities.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxClientEntity","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxClientEntity","text":"The client's data object that is associated with a semantic entity.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxClientFile","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxClientFile","text":"The client's data object that is associated with a CXFile.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxDeclInfo","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxDeclInfo","text":"CXIdxDeclInfo\n\nField Note\nlexicalContainer Generally same as #semanticContainer but can be different in cases like out-of-line C++ member functions.\nisImplicit Whether the declaration exists in code or was created implicitly by the compiler, e.g. implicit Objective-C methods for properties.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxEntityCXXTemplateKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxEntityCXXTemplateKind","text":"CXIdxEntityCXXTemplateKind\n\nExtra C++ template information for an entity. This can apply to: CXIdxEntity_Function CXIdxEntity_CXXClass CXIdxEntity_CXXStaticMethod CXIdxEntity_CXXInstanceMethod CXIdxEntity_CXXConstructor CXIdxEntity_CXXConversionFunction CXIdxEntity_CXXTypeAlias\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxEntityRefInfo","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxEntityRefInfo","text":"CXIdxEntityRefInfo\n\nData for IndexerCallbacks#indexEntityReference.\n\nField Note\ncursor Reference cursor.\nreferencedEntity The entity that gets referenced.\nparentEntity Immediate \"parent\" of the reference. For example:  c++  Foo *var;  The parent of reference of type 'Foo' is the variable 'var'. For references inside statement bodies of functions/methods, the parentEntity will be the function/method.\ncontainer Lexical container context of the reference.\nrole Sets of symbol roles of the reference.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxEntityRefKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxEntityRefKind","text":"CXIdxEntityRefKind\n\nData for IndexerCallbacks#indexEntityReference.\n\nThis may be deprecated in a future version as this duplicates the CXSymbolRole_Implicit bit in CXSymbolRole.\n\nEnumerator Note\nCXIdxEntityRef_Direct The entity is referenced directly in user's code.\nCXIdxEntityRef_Implicit An implicit reference, e.g. a reference of an Objective-C method via the dot syntax.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxImportedASTFileInfo","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxImportedASTFileInfo","text":"CXIdxImportedASTFileInfo\n\nData for IndexerCallbacks#importedASTFile.\n\nField Note\nfile Top level AST file containing the imported PCH, module or submodule.\nmodule The imported module or NULL if the AST file is a PCH.\nloc Location where the file is imported. Applicable only for modules.\nisImplicit Non-zero if an inclusion directive was automatically turned into a module import. Applicable only for modules.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxIncludedFileInfo","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxIncludedFileInfo","text":"CXIdxIncludedFileInfo\n\nData for ppIncludedFile callback.\n\nField Note\nhashLoc Location of '#' in the #include/#import directive.\nfilename Filename as written in the #include/#import directive.\nfile The actual file that the #include/#import directive resolved to.\nisModuleImport Non-zero if the directive was automatically turned into a module import.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIdxLoc","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIdxLoc","text":"CXIdxLoc\n\nSource location passed to index callbacks.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXInclusionVisitor","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXInclusionVisitor","text":"Visitor invoked for each file in a translation unit (used with clang_getInclusions()).\n\nThis visitor function will be invoked by clang_getInclusions() for each file included (either at the top-level or by #include directives) within a translation unit. The first argument is the file being included, and the second and third arguments provide the inclusion stack. The array is sorted in order of immediate inclusion. For example, the first element refers to the location that included 'included_file'.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIndex","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIndex","text":"An \"index\" that consists of a set of translation units that would typically be linked together into an executable or library.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIndexAction","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIndexAction","text":"An indexing action/session, to be applied to one or multiple translation units.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXIndexOptFlags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXIndexOptFlags","text":"CXIndexOptFlags\n\nEnumerator Note\nCXIndexOpt_None Used to indicate that no special indexing options are needed.\nCXIndexOpt_SuppressRedundantRefs Used to indicate that IndexerCallbacks#indexEntityReference should be invoked for only one reference of an entity per source file that does not also include a declaration/definition of the entity.\nCXIndexOpt_IndexFunctionLocalSymbols Function-local symbols should be indexed. If this is not set function-local symbols will be ignored.\nCXIndexOpt_IndexImplicitTemplateInstantiations Implicit function/class template instantiations should be indexed. If this is not set, implicit instantiations will be ignored.\nCXIndexOpt_SuppressWarnings Suppress all compiler warnings when parsing for indexing.\nCXIndexOpt_SkipParsedBodiesInSession Skip a function/method body that was already parsed during an indexing session associated with a CXIndexAction object. Bodies in system headers are always skipped.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXLanguageKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXLanguageKind","text":"CXLanguageKind\n\nDescribe the \"language\" of the entity referred to by a cursor.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXLinkageKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXLinkageKind","text":"CXLinkageKind\n\nDescribe the linkage of the entity referred to by a cursor.\n\nEnumerator Note\nCXLinkage_Invalid This value indicates that no linkage information is available for a provided CXCursor.\nCXLinkage_NoLinkage This is the linkage for variables, parameters, and so on that have automatic storage. This covers normal (non-extern) local variables.\nCXLinkage_Internal This is the linkage for static variables and static functions.\nCXLinkage_UniqueExternal This is the linkage for entities with external linkage that live in C++ anonymous namespaces.\nCXLinkage_External This is the linkage for entities with true, external linkage.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXLoadDiag_Error","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXLoadDiag_Error","text":"CXLoadDiag_Error\n\nDescribes the kind of error that occurred (if any) in a call to clang_loadDiagnostics.\n\nEnumerator Note\nCXLoadDiag_None Indicates that no error occurred.\nCXLoadDiag_Unknown Indicates that an unknown error occurred while attempting to deserialize diagnostics.\nCXLoadDiag_CannotLoad Indicates that the file containing the serialized diagnostics could not be opened.\nCXLoadDiag_InvalidFile Indicates that the serialized diagnostics file is invalid or corrupt.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXModule","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXModule","text":"CINDEX_MODULE Module introspection\n\nThe functions in this group provide access to information about modules.\n\n@{\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXModuleMapDescriptor","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXModuleMapDescriptor","text":"Object encapsulating information about a module.map file.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXNameRefFlags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXNameRefFlags","text":"CXNameRefFlags\n\nEnumerator Note\nCXNameRange_WantQualifier Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the range.\nCXNameRange_WantTemplateArgs Include the explicit template arguments, e.g. <int> in x.f<int>, in the range.\nCXNameRange_WantSinglePiece If the name is non-contiguous, return the full spanning range.  Non-contiguous names occur in Objective-C when a selector with two or more parameters is used, or in C++ when using an operator:  c++  [object doSomething:here withValue:there]; // Objective-C  return some_vector[1]; // C++\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXObjCDeclQualifierKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXObjCDeclQualifierKind","text":"CXObjCDeclQualifierKind\n\n'Qualifiers' written next to the return and parameter types in Objective-C method declarations.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXObjCPropertyAttrKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXObjCPropertyAttrKind","text":"CXObjCPropertyAttrKind\n\nProperty attributes for a CXCursor_ObjCPropertyDecl.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXPlatformAvailability","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXPlatformAvailability","text":"CXPlatformAvailability\n\nDescribes the availability of a given entity on a particular platform, e.g., a particular class might only be available on Mac OS 10.7 or newer.\n\nField Note\nPlatform A string that describes the platform for which this structure provides availability information.  Possible values are \"ios\" or \"macos\".\nIntroduced The version number in which this entity was introduced.\nDeprecated The version number in which this entity was deprecated (but is still available).\nObsoleted The version number in which this entity was obsoleted, and therefore is no longer available.\nUnavailable Whether the entity is unconditionally unavailable on this platform.\nMessage An optional message to provide to a user of this API, e.g., to suggest replacement APIs.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXPrintingPolicy","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXPrintingPolicy","text":"Opaque pointer representing a policy that controls pretty printing for clang_getCursorPrettyPrinted.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXPrintingPolicyProperty","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXPrintingPolicyProperty","text":"CXPrintingPolicyProperty\n\nProperties for the printing policy.\n\nSee clang::PrintingPolicy for more information.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXRefQualifierKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXRefQualifierKind","text":"CXRefQualifierKind\n\nEnumerator Note\nCXRefQualifier_None No ref-qualifier was provided.\nCXRefQualifier_LValue An lvalue ref-qualifier was provided (&).\nCXRefQualifier_RValue An rvalue ref-qualifier was provided (&&).\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXRemapping","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXRemapping","text":"A remapping of original source files and their translated files.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXReparse_Flags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXReparse_Flags","text":"CXReparse_Flags\n\nFlags that control the reparsing of translation units.\n\nThe enumerators in this enumeration type are meant to be bitwise ORed together to specify which options should be used when reparsing the translation unit.\n\nEnumerator Note\nCXReparse_None Used to indicate that no special reparsing options are needed.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXResult","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXResult","text":"CXResult\n\nEnumerator Note\nCXResult_Success Function returned successfully.\nCXResult_Invalid One of the parameters was invalid for the function.\nCXResult_VisitBreak The function was terminated by a callback (e.g. it returned CXVisit_Break)\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSaveError","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSaveError","text":"CXSaveError\n\nDescribes the kind of error that occurred (if any) in a call to clang_saveTranslationUnit().\n\nEnumerator Note\nCXSaveError_None Indicates that no error occurred while saving a translation unit.\nCXSaveError_Unknown Indicates that an unknown error occurred while attempting to save the file.  This error typically indicates that file I/O failed when attempting to write the file.\nCXSaveError_TranslationErrors Indicates that errors during translation prevented this attempt to save the translation unit.  Errors that prevent the translation unit from being saved can be extracted using clang_getNumDiagnostics() and clang_getDiagnostic().\nCXSaveError_InvalidTU Indicates that the translation unit to be saved was somehow invalid (e.g., NULL).\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSaveTranslationUnit_Flags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSaveTranslationUnit_Flags","text":"CXSaveTranslationUnit_Flags\n\nFlags that control how translation units are saved.\n\nThe enumerators in this enumeration type are meant to be bitwise ORed together to specify which options should be used when saving the translation unit.\n\nEnumerator Note\nCXSaveTranslationUnit_None Used to indicate that no special saving options are needed.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSourceLocation","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSourceLocation","text":"CXSourceLocation\n\nIdentifies a specific source location within a translation unit.\n\nUse clang_getExpansionLocation() or clang_getSpellingLocation() to map a source location to a particular file, line, and column.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSourceRange","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSourceRange","text":"CXSourceRange\n\nIdentifies a half-open character range in the source code.\n\nUse clang_getRangeStart() and clang_getRangeEnd() to retrieve the starting and end locations from a source range, respectively.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSourceRangeList","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSourceRangeList","text":"CXSourceRangeList\n\nIdentifies an array of ranges.\n\nField Note\ncount The number of ranges in the ranges array.\nranges An array of CXSourceRanges.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXString","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXString","text":"CXString\n\nA character string.\n\nThe CXString type is used to return strings from the interface when the ownership of that string might differ from one call to the next. Use clang_getCString() to retrieve the string data and, once finished with the string data, call clang_disposeString() to free the string.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXSymbolRole","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXSymbolRole","text":"CXSymbolRole\n\nRoles that are attributed to symbol occurrences.\n\nInternal: this currently mirrors low 9 bits of clang::index::SymbolRole with higher bits zeroed. These high bits may be exposed in the future.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTLSKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTLSKind","text":"CXTLSKind\n\nDescribe the \"thread-local storage (TLS) kind\" of the declaration referred to by a cursor.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTUResourceUsage","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTUResourceUsage","text":"CXTUResourceUsage\n\nThe memory usage of a CXTranslationUnit, broken into categories.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTUResourceUsageKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTUResourceUsageKind","text":"CXTUResourceUsageKind\n\nCategorizes how memory is being used by a translation unit.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTargetInfo","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTargetInfo","text":"An opaque type representing target information for a given translation unit.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTemplateArgumentKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTemplateArgumentKind","text":"CXTemplateArgumentKind\n\nDescribes the kind of a template argument.\n\nSee the definition of llvm::clang::TemplateArgument::ArgKind for full element descriptions.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXToken","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXToken","text":"CXToken\n\nDescribes a single preprocessing token.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTokenKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTokenKind","text":"CXTokenKind\n\nDescribes a kind of token.\n\nEnumerator Note\nCXToken_Punctuation A token that contains some kind of punctuation.\nCXToken_Keyword A language keyword.\nCXToken_Identifier An identifier (that is not a keyword).\nCXToken_Literal A numeric, string, or character literal.\nCXToken_Comment A comment.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTranslationUnit","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTranslationUnit","text":"A single translation unit, which resides in an index.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTranslationUnit_Flags","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTranslationUnit_Flags","text":"CXTranslationUnit_Flags\n\nFlags that control the creation of translation units.\n\nThe enumerators in this enumeration type are meant to be bitwise ORed together to specify which options should be used when constructing the translation unit.\n\nEnumerator Note\nCXTranslationUnit_None Used to indicate that no special translation-unit options are needed.\nCXTranslationUnit_DetailedPreprocessingRecord Used to indicate that the parser should construct a \"detailed\" preprocessing record, including all macro definitions and instantiations.  Constructing a detailed preprocessing record requires more memory and time to parse, since the information contained in the record is usually not retained. However, it can be useful for applications that require more detailed information about the behavior of the preprocessor.\nCXTranslationUnit_Incomplete Used to indicate that the translation unit is incomplete.  When a translation unit is considered \"incomplete\", semantic analysis that is typically performed at the end of the translation unit will be suppressed. For example, this suppresses the completion of tentative declarations in C and of instantiation of implicitly-instantiation function templates in C++. This option is typically used when parsing a header with the intent of producing a precompiled header.\nCXTranslationUnit_PrecompiledPreamble Used to indicate that the translation unit should be built with an implicit precompiled header for the preamble.  An implicit precompiled header is used as an optimization when a particular translation unit is likely to be reparsed many times when the sources aren't changing that often. In this case, an implicit precompiled header will be built containing all of the initial includes at the top of the main file (what we refer to as the \"preamble\" of the file). In subsequent parses, if the preamble or the files in it have not changed, clang_reparseTranslationUnit() will re-use the implicit precompiled header to improve parsing performance.\nCXTranslationUnit_CacheCompletionResults Used to indicate that the translation unit should cache some code-completion results with each reparse of the source file.  Caching of code-completion results is a performance optimization that introduces some overhead to reparsing but improves the performance of code-completion operations.\nCXTranslationUnit_ForSerialization Used to indicate that the translation unit will be serialized with clang_saveTranslationUnit.  This option is typically used when parsing a header with the intent of producing a precompiled header.\nCXTranslationUnit_CXXChainedPCH DEPRECATED: Enabled chained precompiled preambles in C++.  Note: this is a temporary option that is available only while we are testing C++ precompiled preamble support. It is deprecated.\nCXTranslationUnit_SkipFunctionBodies Used to indicate that function/method bodies should be skipped while parsing.  This option can be used to search for declarations/definitions while ignoring the usages.\nCXTranslationUnit_IncludeBriefCommentsInCodeCompletion Used to indicate that brief documentation comments should be included into the set of code completions returned from this translation unit.\nCXTranslationUnit_CreatePreambleOnFirstParse Used to indicate that the precompiled preamble should be created on the first parse. Otherwise it will be created on the first reparse. This trades runtime on the first parse (serializing the preamble takes time) for reduced runtime on the second parse (can now reuse the preamble).\nCXTranslationUnit_KeepGoing Do not stop processing when fatal errors are encountered.  When fatal errors are encountered while parsing a translation unit, semantic analysis is typically stopped early when compiling code. A common source for fatal errors are unresolvable include files. For the purposes of an IDE, this is undesirable behavior and as much information as possible should be reported. Use this flag to enable this behavior.\nCXTranslationUnit_SingleFileParse Sets the preprocessor in a mode for parsing a single file only.\nCXTranslationUnit_LimitSkipFunctionBodiesToPreamble Used in combination with CXTranslationUnit_SkipFunctionBodies to constrain the skipping of function bodies to the preamble.  The function bodies of the main file are not skipped.\nCXTranslationUnit_IncludeAttributedTypes Used to indicate that attributed types should be included in CXType.\nCXTranslationUnit_VisitImplicitAttributes Used to indicate that implicit attributes should be visited.\nCXTranslationUnit_IgnoreNonErrorsFromIncludedFiles Used to indicate that non-errors from included files should be ignored.  If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from included files anymore. This speeds up clang_getDiagnosticSetFromTU() for the case where these warnings are not of interest, as for an IDE for example, which typically shows only the diagnostics in the main file.\nCXTranslationUnit_RetainExcludedConditionalBlocks Tells the preprocessor not to skip excluded conditional blocks.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXType","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXType","text":"CXType\n\nThe type of an element in the abstract syntax tree.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTypeKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTypeKind","text":"CXTypeKind\n\nDescribes the kind of type\n\nEnumerator Note\nCXType_Invalid Represents an invalid type (e.g., where no type is available).\nCXType_Unexposed A type whose specific kind is not exposed via this interface.\nCXType_Void \nCXType_Bool \nCXType_Char_U \nCXType_UChar \nCXType_Char16 \nCXType_Char32 \nCXType_UShort \nCXType_UInt \nCXType_ULong \nCXType_ULongLong \nCXType_UInt128 \nCXType_Char_S \nCXType_SChar \nCXType_WChar \nCXType_Short \nCXType_Int \nCXType_Long \nCXType_LongLong \nCXType_Int128 \nCXType_Float \nCXType_Double \nCXType_LongDouble \nCXType_NullPtr \nCXType_Overload \nCXType_Dependent \nCXType_ObjCId \nCXType_ObjCClass \nCXType_ObjCSel \nCXType_Float128 \nCXType_Half \nCXType_Float16 \nCXType_ShortAccum \nCXType_Accum \nCXType_LongAccum \nCXType_UShortAccum \nCXType_UAccum \nCXType_ULongAccum \nCXType_BFloat16 \nCXType_FirstBuiltin \nCXType_LastBuiltin \nCXType_Complex \nCXType_Pointer \nCXType_BlockPointer \nCXType_LValueReference \nCXType_RValueReference \nCXType_Record \nCXType_Enum \nCXType_Typedef \nCXType_ObjCInterface \nCXType_ObjCObjectPointer \nCXType_FunctionNoProto \nCXType_FunctionProto \nCXType_ConstantArray \nCXType_Vector \nCXType_IncompleteArray \nCXType_VariableArray \nCXType_DependentSizedArray \nCXType_MemberPointer \nCXType_Auto \nCXType_Elaborated Represents a type that was referred to using an elaborated type keyword.  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\nCXType_Pipe \nCXType_OCLImage1dRO \nCXType_OCLImage1dArrayRO \nCXType_OCLImage1dBufferRO \nCXType_OCLImage2dRO \nCXType_OCLImage2dArrayRO \nCXType_OCLImage2dDepthRO \nCXType_OCLImage2dArrayDepthRO \nCXType_OCLImage2dMSAARO \nCXType_OCLImage2dArrayMSAARO \nCXType_OCLImage2dMSAADepthRO \nCXType_OCLImage2dArrayMSAADepthRO \nCXType_OCLImage3dRO \nCXType_OCLImage1dWO \nCXType_OCLImage1dArrayWO \nCXType_OCLImage1dBufferWO \nCXType_OCLImage2dWO \nCXType_OCLImage2dArrayWO \nCXType_OCLImage2dDepthWO \nCXType_OCLImage2dArrayDepthWO \nCXType_OCLImage2dMSAAWO \nCXType_OCLImage2dArrayMSAAWO \nCXType_OCLImage2dMSAADepthWO \nCXType_OCLImage2dArrayMSAADepthWO \nCXType_OCLImage3dWO \nCXType_OCLImage1dRW \nCXType_OCLImage1dArrayRW \nCXType_OCLImage1dBufferRW \nCXType_OCLImage2dRW \nCXType_OCLImage2dArrayRW \nCXType_OCLImage2dDepthRW \nCXType_OCLImage2dArrayDepthRW \nCXType_OCLImage2dMSAARW \nCXType_OCLImage2dArrayMSAARW \nCXType_OCLImage2dMSAADepthRW \nCXType_OCLImage2dArrayMSAADepthRW \nCXType_OCLImage3dRW \nCXType_OCLSampler \nCXType_OCLEvent \nCXType_OCLQueue \nCXType_OCLReserveID \nCXType_ObjCObject \nCXType_ObjCTypeParam \nCXType_Attributed \nCXType_OCLIntelSubgroupAVCMcePayload \nCXType_OCLIntelSubgroupAVCImePayload \nCXType_OCLIntelSubgroupAVCRefPayload \nCXType_OCLIntelSubgroupAVCSicPayload \nCXType_OCLIntelSubgroupAVCMceResult \nCXType_OCLIntelSubgroupAVCImeResult \nCXType_OCLIntelSubgroupAVCRefResult \nCXType_OCLIntelSubgroupAVCSicResult \nCXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout \nCXType_OCLIntelSubgroupAVCImeResultDualRefStreamout \nCXType_OCLIntelSubgroupAVCImeSingleRefStreamin \nCXType_OCLIntelSubgroupAVCImeDualRefStreamin \nCXType_ExtVector \nCXType_Atomic \n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTypeLayoutError","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTypeLayoutError","text":"CXTypeLayoutError\n\nList the possible error codes for clang_Type_getSizeOf, clang_Type_getAlignOf, clang_Type_getOffsetOf and clang_Cursor_getOffsetOf.\n\nA value of this enumeration type can be returned if the target type is not a valid argument to sizeof, alignof or offsetof.\n\nEnumerator Note\nCXTypeLayoutError_Invalid Type is of kind CXType_Invalid.\nCXTypeLayoutError_Incomplete The type is an incomplete Type.\nCXTypeLayoutError_Dependent The type is a dependent Type.\nCXTypeLayoutError_NotConstantSize The type is not a constant size type.\nCXTypeLayoutError_InvalidFieldName The Field name is not valid for this record.\nCXTypeLayoutError_Undeduced The type is undeduced.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXTypeNullabilityKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXTypeNullabilityKind","text":"CXTypeNullabilityKind\n\nEnumerator Note\nCXTypeNullability_NonNull Values of this type can never be null.\nCXTypeNullability_Nullable Values of this type can be null.\nCXTypeNullability_Unspecified Whether values of this type can be null is (explicitly) unspecified. This captures a (fairly rare) case where we can't conclude anything about the nullability of the type even though it has been considered.\nCXTypeNullability_Invalid Nullability is not applicable to this type.\nCXTypeNullability_NullableResult Generally behaves like Nullable, except when used in a block parameter that was imported into a swift async method. There, swift will assume that the parameter can get null even if no error occured. _Nullable parameters are assumed to only get null on error.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXUnsavedFile","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXUnsavedFile","text":"CXUnsavedFile\n\nProvides the contents of a file that has not yet been saved to disk.\n\nEach CXUnsavedFile instance provides the name of a file on the system along with the current contents of that file that have not yet been saved to disk.\n\nField Note\nFilename The file whose contents have not yet been saved.  This file must already exist in the file system.\nContents A buffer containing the unsaved contents of this file.\nLength The length of the unsaved contents of this buffer.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXVersion","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXVersion","text":"CXVersion\n\nDescribes a version number of the form major.minor.subminor.\n\nField Note\nMajor The major version number, e.g., the '10' in '10.7.3'. A negative value indicates that there is no version number at all.\nMinor The minor version number, e.g., the '7' in '10.7.3'. This value will be negative if no minor version number was provided, e.g., for version '10'.\nSubminor The subminor version number, e.g., the '3' in '10.7.3'. This value will be negative if no minor or subminor version number was provided, e.g., in version '10' or '10.7'.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXVirtualFileOverlay","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXVirtualFileOverlay","text":"Object encapsulating information about overlaying virtual file/directories over the real file system.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXVisibilityKind","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXVisibilityKind","text":"CXVisibilityKind\n\nEnumerator Note\nCXVisibility_Invalid This value indicates that no visibility information is available for a provided CXCursor.\nCXVisibility_Hidden Symbol not seen by the linker.\nCXVisibility_Protected Symbol seen by the linker but resolves to a symbol inside this object.\nCXVisibility_Default Symbol seen by the linker and acts like a normal symbol.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CXVisitorResult","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CXVisitorResult","text":"CXVisitorResult\n\nCINDEX_HIGH Higher level API functions\n\n@{\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CX_CXXAccessSpecifier","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CX_CXXAccessSpecifier","text":"CX_CXXAccessSpecifier\n\nRepresents the C++ access control level to a base class for a cursor with kind CX_CXXBaseSpecifier.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.CX_StorageClass","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.CX_StorageClass","text":"CX_StorageClass\n\nRepresents the storage classes as declared in the source. CX_SC_Invalid was added for the case that the passed cursor in not a declaration.\n\n\n\n\n\n","category":"type"},{"location":"libclang/#Clang.LibClang.IndexerCallbacks","page":"LibClang Wrapper API Reference","title":"Clang.LibClang.IndexerCallbacks","text":"IndexerCallbacks\n\nA group of callbacks used by #clang_indexSourceFile and #clang_indexTranslationUnit.\n\nField Note\nabortQuery Called periodically to check whether indexing should be aborted. Should return 0 to continue, and non-zero to abort.\ndiagnostic Called at the end of indexing; passes the complete diagnostic set.\nppIncludedFile Called when a file gets #included/#imported.\nimportedASTFile Called when a AST file (PCH or module) gets imported.  AST files will not get indexed (there will not be callbacks to index all the entities in an AST file). The recommended action is that, if the AST file is not already indexed, to initiate a new indexing job specific to the AST file.\nstartedTranslationUnit Called at the beginning of indexing a translation unit.\nindexEntityReference Called to index a reference of an entity.\n\n\n\n\n\n","category":"type"},{"location":"#Clang","page":"Introduction","title":"Clang","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides a Julia language wrapper for libclang: the stable, C-exported interface to the LLVM Clang compiler. The libclang API documentation provides background on the functionality available through libclang, and thus through the Julia wrapper. The repository also hosts related tools built on top of libclang functionality.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Now, the package provides an out-of-box installation experience on Linux, macOS and Windows. You could simply install it by running:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add Clang","category":"page"},{"location":"#C-bindings-generator","page":"Introduction","title":"C-bindings generator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package includes a generator to create Julia wrappers for C libraries from a collection of header files. The following declarations are currently supported:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function: translated to Julia ccall (some caveats about variadic functions, see Variadic Function)\nstruct: translated to Julia struct\nenum: translated to Enum or CEnum\nunion: translated to Julia struct\ntypedef: translated to Julia typealias to underlying intrinsic type\nmacro: limited support\nbitfield: experimental support","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following example wraps include/clang-c/*.h from Clang_jll and prints the wrapper to LibClang.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"First write a configuration script generator.toml.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[general]\nlibrary_name = \"libclang\"\noutput_file_path = \"./LibClang.jl\"\nmodule_name = \"LibClang\"\njll_pkg_name = \"Clang_jll\"\nexport_symbol_prefixes = [\"CX\", \"clang_\"]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then load the configurations and generate a wrapper.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Clang.Generators\nusing Clang.LibClang.Clang_jll\n\ncd(@__DIR__)\n\ninclude_dir = normpath(Clang_jll.artifact_dir, \"include\")\nclang_dir = joinpath(include_dir, \"clang-c\")\n\n# wrapper generator options\noptions = load_options(joinpath(@__DIR__, \"generator.toml\"))\n\n# add compiler flags, e.g. \"-DXXXXXXXXX\"\nargs = get_default_args()\npush!(args, \"-I$include_dir\")\n\nheaders = [joinpath(clang_dir, header) for header in readdir(clang_dir) if endswith(header, \".h\")]\n# there is also an experimental `detect_headers` function for auto-detecting top-level headers in the directory\n# headers = detect_headers(clang_dir, args)\n\n# create context\nctx = create_context(headers, args, options)\n\n# run generator\nbuild!(ctx)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Compatibility\nThe generator above is introduced in Clang.jl 0.14. If you are working with older versions of Clang.jl, check older versions of documentation","category":"page"},{"location":"#LibClang","page":"Introduction","title":"LibClang","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"LibClang is a thin wrapper over libclang. It's one-to-one mapped to the libclang APIs. By using Clang.LibClang, all of the CX/clang_-prefixed libclang APIs are imported into the current namespace, with which you could build up your own tools from scratch. If you are unfamiliar with the Clang AST, a good starting point is the Introduction to the Clang AST.","category":"page"},{"location":"tutorial/#LibClang-Tutorial","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Clang is an open-source compiler built on the LLVM framework and targeting C, C++, and Objective-C (LLVM is also the JIT backend for Julia). Due to a highly modular design, Clang has in recent years become the core of a growing number of projects utilizing pieces of the compiler, such as tools for source-to-source translation, static analysis and security evaluation, and editor tools for code completion, formatting, etc.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"While LLVM and Clang are written in C++, the Clang project maintains a C-exported interface called \"libclang\" which provides access to the abstract syntax tree and type representations. Thanks to the ubiquity of support for C calling conventions, a number of languages have utilized libclang as a basis for tooling related to C and C++.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The Clang.jl Julia package wraps libclang, provides a small convenience API for Julia-style programming, and provides a C-to-Julia wrapper generator built on libclang functionality.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Here is the header file example.h used in the following examples:  ","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"// example.h\nstruct ExStruct {\n    int    kind;\n    char*  name;\n    float* data;\n};\n\nvoid* ExFunction (int kind, char* name, float* data) {\n    struct ExStruct st;\n    st.kind = kind;\n    st.name = name;\n    st.data = data;\n}","category":"page"},{"location":"tutorial/#Printing-Struct-Fields","page":"LibClang Tutorial","title":"Printing Struct Fields","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To motivate the discussion with a succinct example, consider this struct:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"struct ExStruct {\n    int    kind;\n    char*  name;\n    float* data;\n};","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Parsing and querying the fields of this struct requires just a few lines of code:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> using Clang\n\njulia> trans_unit = Clang.parse_header(Index(), \"example.h\")\nTranslationUnit(Ptr{Nothing} @0x00007fe13cdc8a00, Index(Ptr{Nothing} @0x00007fe13cc8dde0, 0, 1))\n\njulia> root_cursor = Clang.getTranslationUnitCursor(trans_unit)\nCLCursor (CLTranslationUnit) example.h\n\njulia> struct_cursor = search(root_cursor, \"ExStruct\") |> only\nCLCursor (CLStructDecl) ExStruct\n\njulia> for c in children(struct_cursor)  # print children\n           println(\"Cursor: \", c, \"\\n  Kind: \", kind(c), \"\\n  Name: \", name(c), \"\\n  Type: \", Clang.getCursorType(c))\n       end\nCursor: CLCursor (CLFieldDecl) kind\n  Kind: CXCursor_FieldDecl(6)\n  Name: kind\n  Type: CLType (CLInt)\nCursor: CLCursor (CLFieldDecl) name\n  Kind: CXCursor_FieldDecl(6)\n  Name: name\n  Type: CLType (CLPointer)\nCursor: CLCursor (CLFieldDecl) data\n  Kind: CXCursor_FieldDecl(6)\n  Name: data\n  Type: CLType (CLPointer)","category":"page"},{"location":"tutorial/#AST-Representation","page":"LibClang Tutorial","title":"AST Representation","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Let's examine the example above, starting with the variable trans_unit:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> trans_unit\nTranslationUnit(Ptr{Nothing} @0x00007fa9ac6a9f90, Index(Ptr{Nothing} @0x00007fa9ac6b4080, 0, 1))","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"A TranslationUnit is the entry point to the libclang AST. In the example above, trans_unit is a TranslationUnit for the parsed file example.h. The libclang AST is represented as a directed acyclic graph of cursor nodes carrying three pieces of essential information:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Kind: purpose of cursor node\nType: type of the object represented by cursor\nChildren: list of child nodes","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> root_cursor\nCLCursor (CLTranslationUnit) example.h","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"root_cursor is the root cursor node of the TranslationUnit.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"In Clang.jl the cursor type is encapsulated by a Julia type deriving from the abstract type CLCursor. Under the hood, libclang represents each cursor (CXCursor) kind and type (CXType) as an enum value. These enum values are used to automatically map all CXCursor and CXType objects to Julia types. Thus, it is possible to write multiple-dispatch methods against CLCursor or CLType variables.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> dump(root_cursor)\nCLTranslationUnit\n  cursor: Clang.LibClang.CXCursor\n    kind: Clang.LibClang.CXCursorKind CXCursor_TranslationUnit(300)\n    xdata: Int32 0\n    data: Tuple{Ptr{Nothing},Ptr{Nothing},Ptr{Nothing}}\n      1: Ptr{Nothing} @0x00007fe13b3552e8\n      2: Ptr{Nothing} @0x0000000000000001\n      3: Ptr{Nothing} @0x00007fe13cdc8a00","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Under the hood, libclang represents each cursor kind and type as an enum value. These enums are translated into Julia as a subtype of Cenum:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> dump(Clang.LibClang.CXCursorKind)\nClang.LibClang.CXCursorKind <: Clang.LibClang.CEnum.Cenum{UInt32}","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The example demonstrates two different ways of accessing child nodes of a given cursor. Here, the children function returns an iterator over the child nodes of the given cursor:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> children(struct_cursor)\n3-element Array{CLCursor,1}:\n CLCursor (CLFieldDecl) kind\n CLCursor (CLFieldDecl) name\n CLCursor (CLFieldDecl) data","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"And here, the search function returns a list of child node(s) matching the given name:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> search(root_cursor, \"ExStruct\")\n1-element Array{CLCursor,1}:\n CLCursor (CLStructDecl) ExStruct","category":"page"},{"location":"tutorial/#Type-representation","page":"LibClang Tutorial","title":"Type representation","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The above example also demonstrates querying of the type associated with a given cursor using the helper function type. In the output:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Cursor: CLCursor (CLFieldDecl) kind\n  Kind: CXCursor_FieldDecl(6)\n  Name: kind\n  Type: CLType (CLInt)\nCursor: CLCursor (CLFieldDecl) name\n  Kind: CXCursor_FieldDecl(6)\n  Name: name\n  Type: CLType (CLPointer)\nCursor: CLCursor (CLFieldDecl) data\n  Kind: CXCursor_FieldDecl(6)\n  Name: data\n  Type: CLType (CLPointer)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Each CLFieldDecl cursor has an associated CLType object, with an identity reflecting the field type for the given struct member. It is critical to note the difference between the representation for the kind field and the name and data fields. kind is represented directly as an CLInt object, but name and data are represented as CLPointer CLTypes. As explored in the next section, the full type of the CLPointer can be queried to retrieve the full char * and float * types of these members. User-defined types are captured using a similar scheme.","category":"page"},{"location":"tutorial/#Function-Arguments-and-Types","page":"LibClang Tutorial","title":"Function Arguments and Types","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To further explore type representations, consider the following function (included in example.h):","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"void* ExFunction (int kind, char* name, float* data) {\n    struct ExStruct st;\n    st.kind = kind;\n    st.name = name;\n    st.data = data;\n}","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"To find the cursor for this function declaration, we use function search to retrieve nodes of kind  CXCursor_FunctionDecl , and select the final one in the list:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> using Clang.LibClang  # CXCursor_FunctionDecl is exposed from LibClang\n\njulia> fdecl = search(root_cursor, CXCursor_FunctionDecl) |> only\nCLCursor (CLFunctionDecl) ExFunction(int, char *, float *)\n\njulia> fdecl_children = [c for c in children(fdecl)]\n4-element Array{CLCursor,1}:\n CLCursor (CLParmDecl) kind\n CLCursor (CLParmDecl) name\n CLCursor (CLParmDecl) data\n CLCursor (CLCompoundStmt)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"The first three children are CLParmDecl cursors with the same name as the arguments in the function signature. Checking the types of the CLParmDecl cursors indicates a similarity to the function signature:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> [Clang.getCursorType(t) for t in fdecl_children[1:3]]\n3-element Array{CLType,1}:\n CLType (CLInt)     \n CLType (CLPointer)\n CLType (CLPointer)","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"And, finally, retrieving the target type of each CLPointer argument confirms that these cursors represent the function argument type declaration:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> [Clang.getPointeeType(Clang.getCursorType(t)) for t in fdecl_children[2:3]]\n2-element Array{CLType,1}:\n CLType (CLChar_S)\n CLType (CLFloat)  ","category":"page"},{"location":"tutorial/#Printing-Indented-Cursor-Hierarchy","page":"LibClang Tutorial","title":"Printing Indented Cursor Hierarchy","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"As a closing example, here is a simple, indented AST printer using CLType- and CLCursor-related functions, and utilizing various aspects of Julia's type system.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"printind(ind::Int, st...) = println(join([repeat(\" \", 2*ind), st...]))\n\nprintobj(cursor::CLCursor) = printobj(0, cursor)\nprintobj(t::CLType) = join(typeof(t), \" \", spelling(t))\nprintobj(t::CLInt) = t\nprintobj(t::CLPointer) = Clang.getPointeeType(t)\nprintobj(ind::Int, t::CLType) = printind(ind, printobj(t))\n\nfunction printobj(ind::Int, cursor::Union{CLFieldDecl, CLParmDecl})\n    printind(ind+1, typeof(cursor), \" \", printobj(Clang.getCursorType(cursor)), \" \", name(cursor))\nend\n\nfunction printobj(ind::Int, node::Union{CLCursor, CLStructDecl, CLCompoundStmt,\n                                        CLFunctionDecl, CLBinaryOperator})\n    printind(ind, \" \", typeof(node), \" \", name(node))\n    for c in children(node)\n        printobj(ind + 1, c)\n    end\nend","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"julia> printobj(root_cursor)\n CLTranslationUnit example.h\n   CLStructDecl ExStruct\n      CLFieldDecl CLType (CLInt)  kind\n      CLFieldDecl CLType (CLChar_S)  name\n      CLFieldDecl CLType (CLFloat)  data\n   CLFunctionDecl ExFunction(int, char *, float *)\n      CLParmDecl CLType (CLInt)  kind\n      CLParmDecl CLType (CLChar_S)  name\n      CLParmDecl CLType (CLFloat)  data\n     CLCompoundStmt\n       CLDeclStmt\n         CLVarDecl st\n           CLTypeRef struct ExStruct\n       CLBinaryOperator\n         CLMemberRefExpr kind\n           CLDeclRefExpr st\n         CLUnexposedExpr kind\n           CLDeclRefExpr kind\n       CLBinaryOperator\n         CLMemberRefExpr name\n           CLDeclRefExpr st\n         CLUnexposedExpr name\n           CLDeclRefExpr name\n       CLBinaryOperator\n         CLMemberRefExpr data\n           CLDeclRefExpr st\n         CLUnexposedExpr data\n           CLDeclRefExpr data","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Note that a generic printobj function has been defined for the abstract CLType and CLCursor types, and multiple dispatch is used to define the printers for various specific types needing custom behavior. In particular, the following function handles all cursor types for which recursive printing of child nodes is required:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"function printobj(ind::Int, node::Union{CLCursor, CLStructDecl, CLCompoundStmt, CLFunctionDecl})","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Now, printobj has been moved into Clang.jl with a new name: dumpobj.","category":"page"},{"location":"tutorial/#Parsing-Summary","page":"LibClang Tutorial","title":"Parsing Summary","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"As discussed above, there are several key aspects of the Clang.jl/libclang API:","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"tree of Cursor nodes representing the AST, notes have unique children.\neach Cursor node has a Julia type identifying the syntactic construct represented by the node.\neach node also has an associated CLType referencing either intrinsic or user-defined datatypes.","category":"page"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"There are a number of details omitted from this post, especially concerning the full variety of CLCursor and CLType representations available via libclang. For further information, please see the libclang documentation.","category":"page"},{"location":"tutorial/#Acknowledgement","page":"LibClang Tutorial","title":"Acknowledgement","text":"","category":"section"},{"location":"tutorial/","page":"LibClang Tutorial","title":"LibClang Tutorial","text":"Eli Bendersky's post Parsing C++ in Python with Clang has been an extremely helpful reference.","category":"page"}]
}
